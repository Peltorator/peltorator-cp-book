<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on peltorator</title>
    <link>https://peltorator.ru/posts/</link>
    <description>Recent content in Posts on peltorator</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <lastBuildDate>Tue, 21 Sep 2021 11:52:23 +0300</lastBuildDate><atom:link href="https://peltorator.ru/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Обращение Мёбиуса, свертка Дирихле</title>
      <link>https://peltorator.ru/posts/mobius_convolution/</link>
      <pubDate>Tue, 21 Sep 2021 11:52:23 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/mobius_convolution/</guid>
      
      <description>&lt;!--- TODO: упростить доказательства---&gt;
&lt;p&gt;Рассмотрим различные свертки функций. Функции мы будем рассматривать арифметические, то есть действующие из $\mathbb{N}$ в $\mathbb{N}$, $\mathbb{Z}$, $\mathbb{R}$ или $\mathbb{C}$.
В каком-то смысле можно думать про арифметические функции как про последовательности чисел:
$f(1), f(2), \ldots, f(n), \ldots$&lt;/p&gt;
&lt;p&gt;Возможно, вам уже знакомы некоторые свертки. К примеру, свертка умножения:&lt;/p&gt;
&lt;p&gt;$$c_n = \sum \limits_{k = 0}^{n} a_k \cdot b_{n - k} \textcolor{gray}{\text{  / здесь последовательности нумеруются с нуля /}}$$&lt;/p&gt;
&lt;p&gt;Быстрое преобразование Фурье как раз строит по последовательностям $a$ и $b$ их свертку умножения.&lt;/p&gt;
&lt;p&gt;В этом разделе мы рассмотрим несколько примеров других сверток.&lt;/p&gt;
&lt;h2 id=&#34;формула-обращения-мёбиуса&#34;&gt;Формула обращения Мёбиуса&lt;/h2&gt;
&lt;p&gt;Часто бывает так, что две функции связаны между собой следующим отношением:&lt;/p&gt;
&lt;p&gt;$$g(n) = \sum \limits_{d | n} f(d)$$&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;color:gray&#34;&gt;/ Запись $d | n$ означает &amp;laquo;$d$ делит $n$&amp;raquo;, то есть сумма берется по всем делителям числа $n$ /&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Определение:&lt;/strong&gt;
Функция Мёбиуса.&lt;/p&gt;
&lt;p&gt;$$\mu(n) = \begin{cases}
0, \text{ если $n$ не свободно от квадратов,} \\&lt;br&gt;
(-1)^k, \text{ если $n$ свободно от квадратов, и у него ровно $k$ простых делителей}
\end{cases}$$&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;color:gray&#34;&gt;/ Число свободно от квадратов, если все простые входят в его разложение в степени ровно один /&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Количество делителей числа: $\tau(n) = \sum \limits_{d | n} 1$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Сумма делителей числа: $\sigma(n) = \sum \limits_{d | n} d$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Функция, которая равна единице в единице и нулю во всех остальных натуральных числах:
$\chi_1 = \sum \limits_{d | n} \mu(d)$.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
3. Пусть $n = p_1^{\alpha_1} \cdot p_2^{\alpha_2} \cdot \ldots \cdot p_k^{\alpha_k}$.
Если $\mu(d) \neq 0$, то каждую $p$-шку мы взяли в него либо в нулевой степени, либо в первой.
Тогда есть $\sum \limits_{i = 0}^{\left\lfloor \frac{k}{2} \right\rfloor} {k \choose 2i}$ $d$-шек, для которых $\mu(d) = 1$
и $\sum \limits_{i = 0}^{\left\lfloor \frac{k-1}{2} \right\rfloor} {k \choose 2i + 1}$ $d$-шек, для которых $\mu(d) = -1$.
А такие суммы равны при $n &amp;gt; 1$ (сумма четных биномиальных коэффициентов равна сумме нечетных), так что вся сумма равна нулю.
При $n = 1$ легко произвести подстановку и проверить, что $\chi_1(1) = 1$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Определение:&lt;/strong&gt;
Функция Эйлера $\varphi(n)$ — это количество чисел, не больших $n$, которые взаимно просты с $n$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Есть формула для функции Эйлера, которая имеет похожий вид:&lt;/p&gt;
&lt;p&gt;$\varphi(n) = n \prod \limits_{p | n} (1 - \frac{1}{p})$,
где произведение берется по всем простым делителям $n$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема:&lt;/strong&gt; &lt;strong&gt;Формула обращения Мёбиуса&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Пусть $f$ и $g$ — арифметические функции. Тогда&lt;/p&gt;
&lt;p&gt;$g(n) = \sum \limits_{d | n} f(d) \Leftrightarrow f(n) = \sum \limits_{d | n} \mu(d) g \left (\frac{n}{d} \right )$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
$$\sum \limits_{d | n} \mu(d) g \left (\frac{n}{d} \right ) =
\textcolor{gray}{\text{/ по левой формуле, которая у нас уже есть /}} = $$&lt;/p&gt;
&lt;p&gt;$$ = \sum \limits_{d | n} \mu(d)  \left (\sum \limits_{d&#39; | \frac{n}{d}} f(d&#39;) \right ) =
\sum \limits_{d, d&#39; : (d \cdot d&#39;) | n} \mu(d) \cdot f(d&#39;) =
\textcolor{gray}{\text{/ поменяем местами обозначения /}} = $$&lt;/p&gt;
&lt;p&gt;$$ = \sum \limits_{d, d&#39; : (d \cdot d&#39;) | n} \mu(d&#39;) \cdot f(d) =
\sum \limits_{d | n} f(d) \left (\sum \limits_{d&#39; | \frac{n}{d}} \mu(d&#39;) \right ) =
\textcolor{gray}{\text{/ по примеру 3 /}}
= \sum \limits_{d | n} f(d) \chi_1\left(\frac{n}{d}\right) = f(n)$$&lt;/p&gt;
&lt;p&gt;Последнее равенство верно, потому что у всех слагаемых кроме $d = n$ будет множитель $0$.&lt;/p&gt;
&lt;p&gt;В обратную сторону аналогично. Нужно тоже подставить.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;
Подставим в эту формулу примеры выше:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$1 = \sum \limits_{d | n} \mu(d) \tau \left ( \frac{n}{d} \right )$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$n = \sum \limits_{d | n} \mu(d) \sigma \left ( \frac{n}{d} \right )$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\mu(n) = \sum \limits_{d | n} \mu(d) \chi_1 \left ( \frac{n}{d} \right )$ (что очевидно, но показывает, что формула из третьего примера является частным случаем формулы обращения Мёбиуса).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;
Существует такое тождество: $n = \sum \limits_{d | n} \varphi(d)$. Применим формулу обращения Мёбиуса и получим, что
$\varphi(n) = \sum \limits_{d | n} \mu(d) \cdot \frac{n}{d}$.&lt;/p&gt;
&lt;p&gt;Неожиданно получили связь функций Эйлера и Мёбиуса.&lt;/p&gt;
&lt;h2 id=&#34;свертка-дирихле&#34;&gt;Свертка Дирихле&lt;/h2&gt;
&lt;p&gt;$\sum \limits_{d | n} \mu(d) g \left ( \frac{n}{d} \right )$ является частным случаем свертки Дирихле:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Определение:&lt;/strong&gt;
Свертка Дирихле двух арифметических функций определяется следующим образом:&lt;/p&gt;
&lt;p&gt;$(f * g)(n) = \sum \limits_{d | n} f(d) g \left ( \frac{n}{d} \right ) = \sum \limits_{ab = n} f(a) g(b)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Тогда формулу обращения Мёбиуса можно коротко записать как&lt;/p&gt;
&lt;p&gt;$$
g = f * 1 \Leftrightarrow f = g * \mu
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Определение:&lt;/strong&gt;
Арифметическая функция $f$ называется мультипликативной, если
$f(a \cdot b) = f(a) \cdot f(b) \ \forall \ a, b \in \mathbb{N}$, таких что $gcd(a, b) = 1$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
$\mu, \varphi, \tau, \sigma, \chi_1, id, 1$ — мультипликативные арифметические функции.
&lt;span style=&#34;color:gray&#34;&gt;/ 1 — это фунция, равная единице во всех точках /&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Свойства:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$(f * g) * h = f * (g * h)$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$f * g = g * f$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$f * (g + h) = f * g + f * h$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$f * \chi_1 = \chi_1 * f = f$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$f * 0 = 0 * f = 0$ ($0$ — это функция, которая всегда равна нулю).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Если $f$ и $g$ — мультипликативные, то $f * g$ тоже является мультипликативной.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
1-5. Очевидно. Проверяется подстановкой.&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;$gcd(n, m)=1$, $(f*g)(n \cdot m) =  \sum \limits_{d|n \cdot m} f(d)g(\frac{n \cdot m}{d}) = $
&lt;span style=&#34;color:gray&#34;&gt;/ здесь мы пользуемся тем, что числа взаимно просты; иначе мы бы получили сумму с повторениями /&lt;/span&gt;
$= \sum \limits_{d_1|n, d_2|m} f(d_1 \cdot d_2) g(\frac{n \cdot m}{d_1 \cdot d_2}) =$
&lt;span style=&#34;color:gray&#34;&gt;/ а здесь тем, что числа делители взаимно простых чисел взаимно просты /&lt;/span&gt;
$=\sum \limits_{d_1|n, d_2|m} f(d_1) f(d_2) g(\frac{n}{d_1}) g(\frac{m}{d_2}) = $
$\left(\sum \limits_{d_1|n} f(d_1) g(\frac{n}{d_1})\right) \cdot \left(\sum \limits_{d_2|m} f(d_2) g(\frac{m}{d_2})\right) = (f * g)(n) \cdot (f * g)(m)$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Получили, что арифметические функции образуют коммутативное кольцо с единицей относительно свертки Дирихле и поточечного сложения.
Нулем в этом кольце является тождественно нулевая функция, а единицей — функция $\chi_1$. Это кольцо называется &lt;strong&gt;кольцом Дирихле&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;
a. $\tau = 1 * 1$.&lt;/p&gt;
&lt;p&gt;b. $\sigma = id * 1$.&lt;/p&gt;
&lt;p&gt;c. $\chi_1 = 1 * \mu$.&lt;/p&gt;
&lt;p&gt;d. $1 = \tau * \mu$.&lt;/p&gt;
&lt;p&gt;e. $id = \sigma * \mu$.&lt;/p&gt;
&lt;p&gt;f. $id = \varphi * 1$.&lt;/p&gt;
&lt;p&gt;g. $\sigma = \varphi * \tau$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Определение:&lt;/strong&gt;
Обращением Дирихле функции $f$ назовем такую функцию $g$, что
$f * g = \chi_1$, то есть функция $g = f^{-1}$ в кольце Дирихле.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема:&lt;/strong&gt;
$\ \forall \ f : f(1) \neq 0 \ \exists \ g : f * g = \chi_1$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
$g(1) = \frac{1}{f(1)}$.&lt;/p&gt;
&lt;p&gt;А для $n &amp;gt; 1$ функцию $g$ можно вычислить рекурсивно:&lt;/p&gt;
&lt;p&gt;$g(n) = -\frac{1}{f(1)} \sum \limits_{d | n, d \neq n} f(\frac{n}{d}) g(d)$.&lt;/p&gt;
&lt;p&gt;Доказывается, что такая функция подходит, домножением на $f(1)$ и переносом всего в левую часть.&lt;/p&gt;
&lt;h2 id=&#34;поиск-количества-пар-взаимнопростых-не-больших-n&#34;&gt;Поиск количества пар взаимнопростых, не больших $n$&lt;/h2&gt;
&lt;p&gt;Зачем это все нужно?
Рассмотрим, как решать задачи при помощи обращения Мёбиуса и свертки Дирихле.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Обозначение:&lt;/strong&gt;
$[P]$ — это функция, которая равна единице, если $P$ верно, и нулю, если $P$ неверно.&lt;/p&gt;
&lt;p&gt;Давайте сначала разберемся, как пользоваться линейным решетом Эратосфена.
Можно считать мультипликативную функцию $f$ для всех чисел от $1$ до $n$ за $O(n)$, если за $O(1)$ можно находить $f(p^k)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;
Дано число $n$. Надо найти количество упорядоченных пар взаимно простых чисел $x, y \le n$.&lt;/p&gt;
&lt;p&gt;Обозначим ответ за $f(n)$.&lt;/p&gt;
&lt;p&gt;Сначала заметим, что  $f(n) = 2 \cdot \sum \limits_{k = 1}^{n} \varphi(k) - 1$, потому что каждую неупорядоченную пару
$x, y$ мы посчитаем один раз в $\varphi(max(x, y))$, а нам надо посчитать упорядоченные пары, поэтому необходимо умножить на $2$. Осталось вычесть
пары из двух одинаковых чисел. Но число взаимно просто с собой только если оно равно единице. Этой формулы нам уже хватит на самом деле, но давайте придумаем альтернативную, потому что в более сложных случаях все будет аналогично.&lt;/p&gt;
&lt;p&gt;Запишем формулу: $f(n) = \sum \limits_{i = 1}^{n} \sum \limits_{j = 1}^{n} [gcd(i, j) = 1]$.
Заметим, что $[gcd(i, j) = 1] = \chi_1(gcd(i, j))$, так что можно применить свертку Мёбиуса:&lt;/p&gt;
&lt;p&gt;$$\sum \limits_{i = 1}^{n} \sum \limits_{j = 1}^{n} \sum \limits_{d | gcd(i, j)} \mu(d) =
\sum \limits_{i = 1}^{n} \sum \limits_{j = 1}^{n} \sum \limits_{d = 1}^{n} [d | gcd(i, j)] \cdot \mu(d) = $$&lt;/p&gt;
&lt;p&gt;$$ = \sum \limits_{i = 1}^{n} \sum \limits_{j = 1}^{n} \sum \limits_{d = 1}^{n} [d | i] \cdot [d | j] \cdot \mu(d) =
\textcolor{gray}{\text{/ меняем порядок суммирования /}} = $$&lt;/p&gt;
&lt;p&gt;$$= \sum \limits_{d = 1}^{n} \mu(d) \left ( \sum \limits_{i = 1}^{n} [d | i] \right )
\left ( \sum \limits_{j = 1}^{n} [d | j] \right)$$&lt;/p&gt;
&lt;p&gt;При этом $\sum \limits_{i = 1}^{n} [d | i] = \sum \limits_{j = 1}^{n} [d | j] = $ количеству чисел, делящихся на $d$,
то есть $\left\lfloor \frac{n}{d}  \right\rfloor$.
Тогда получается, что
$f(n) = \sum \limits_{d = 1}^{n} \mu(d) \cdot \left\lfloor \frac{n}{d} \right\rfloor^2$.&lt;/p&gt;
&lt;p&gt;А эту формулу можно посчитать уже за линейное время (все значения $\mu$ считаются при помощи линейного решета за
$O(n)$).&lt;/p&gt;
&lt;p&gt;Нырнем глубже! Мы хотим еще быстрее.
Пусть у нас есть некоторая мультипликативная функция $f$, и мы хотим посчитать ее префиксную сумму.
Обозначим $s_f(n) = \sum \limits_{k = 1}^{n} f(k)$.
Предположим, что мы обнаружили такую мультипликативную функцию $g$, что $s_g$ и $s_{f * g}$ можно быстро считать. Тогда научимся быстро считать $s_f$:&lt;/p&gt;
&lt;p&gt;$$s_{f * g}(n) = \sum \limits_{k = 1}^{n} \sum \limits_{d | k} g(d) f \left ( \frac{k}{d} \right ) =
\sum \limits_{d = 1}^{n} g(d) \sum \limits_{k = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} f(k) = $$&lt;/p&gt;
&lt;p&gt;$$=g(1) \sum \limits_{k = 1}^{n} f(k) +
\sum \limits_{d = 2}^{n} g(d) \sum \limits_{k = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} f(k) =
g(1) s_f(n) + \sum \limits_{d = 2}^{n} g(d) s_f\left(\left\lfloor \frac{n}{d} \right\rfloor\right)$$&lt;/p&gt;
&lt;p&gt;Теперь перенесем $s_f(n)$ в одну часть, а все остальное в другую:&lt;/p&gt;
&lt;p&gt;$$s_f(n) = \frac{s_{f * g}(n) - \sum_{d = 2}^{n} s_f \left ( \left\lfloor \frac{n}{d} \right\rfloor \right ) g(d)}{g(1)}$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Обратите внимание, что если $g$ — мультипликативная функция, то $g(k) = g(1) \cdot g(k)$ для любого $k$, поэтому если $g$ — это не тождественный ноль, то $g(1) = 1$, так что делить на знаменатель нам не придется.&lt;/p&gt;
&lt;p&gt;Осталось научиться быстро считать сумму в числителе.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Лемма:&lt;/strong&gt;
Среди чисел $\left\lfloor \frac{n}{1} \right\rfloor, \left\lfloor \frac{n}{2} \right\rfloor, \ldots,
\left\lfloor \frac{n}{n} \right\rfloor$ не более $2 \sqrt{n}$ различных.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
Стандартное доказательство. Есть $\sqrt{n}$ чисел вида $\left\lfloor \frac{n}{d} \right\rfloor$, где $d &amp;lt; \sqrt{n}$,
а для $d \ge \sqrt{n}$ будет выполнено $\left\lfloor \frac{n}{d} \right\rfloor \le \sqrt{n}$, поэтому
среди них тоже не больше, чем $\sqrt{n}$ различных.&lt;/p&gt;
&lt;p&gt;Также есть простой алгоритм перебора отрезков одинаковых значений $\left\lfloor \frac{n}{d} \right\rfloor$:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// in [left; right) values of n/d are equal
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Из леммы следует, что сумма в числителе разбивается на $O(\sqrt{n})$ рекурсивных вызовов
$s_f(\left\lfloor \frac{n}{d} \right\rfloor)$ и подсчетов $g$ на отрезке, но сумма $g$ на отрезке — это разность
двух префиксных сумм, которые мы по предположению задачи умеем быстро считать.&lt;/p&gt;
&lt;p&gt;Получился рекурсивный алгоритм. Соптимизируем его, сохраняя уже посчитанные значения $s_f(k)$ в хеш-таблицу,
чтобы не считать их заново.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Лемма:&lt;/strong&gt;
Пусть $a$, $b$ и $c$~ — натуральные числа. Тогда&lt;/p&gt;
&lt;p&gt;$$\left\lfloor \frac{\left\lfloor \frac{a}{b} \right\rfloor}{c} \right\rfloor = \left\lfloor \frac{a}{bc} \right\rfloor$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
Очевидно, что $0 \le \frac{a}{b} - \left\lfloor \frac{a}{b} \right\rfloor &amp;lt; 1$,
поэтому $0 \le \frac{a}{bc} - \frac{\left\lfloor \frac{a}{b} \right\rfloor}{c} &amp;lt; \frac{1}{c}$.
При этом $\left\lfloor \frac{a}{b} \right\rfloor$ — целое число, поэтому
дробная часть $\frac{\left\lfloor \frac{a}{b} \right\rfloor}{c}$ не больше $\frac{c - 1}{c}$, так что при прибавлении
чего-то меньшего, чем $\frac{1}{c}$, мы не перепрыгнем на следующюю целую часть.&lt;/p&gt;
&lt;p&gt;Из леммы слеудет, что за время алгоритма мы посетим только числа вида $\left\lfloor \frac{n}{d} \right\rfloor$,
потому что $\left\lfloor \frac{\left\lfloor \frac{n}{d_1} \right\rfloor}{d_2} \right\rfloor =
\left\lfloor \frac{n}{d_1 d_2} \right\rfloor$.&lt;/p&gt;
&lt;p&gt;Подсчет $s_f(k)$ занимает $O(\sqrt{k})$ времени + рекурсивные вызовы.
Так что итоговая асимптотика будет равна&lt;/p&gt;
&lt;p&gt;$$O\left(\sum \limits_{k = 1}^{n} \sqrt{\left\lfloor \frac{n}{k} \right\rfloor}\right)
\textcolor{gray}{\text{/ сумма берется по различным значениям /}}
\le O\left(\sum \limits_{k = 1}^{\sqrt{n}} \sqrt{k} + \sum \limits_{k = 1}^{\sqrt{n}} \sqrt{\frac{n}{k}}\right)$$&lt;/p&gt;
&lt;p&gt;Когда в асимптотике есть сумма возрастающей/убывающей функции, эту сумму можно заменить на интеграл без потерь.&lt;/p&gt;
&lt;p&gt;$\sum \limits_{k = 1}^{\sqrt{n}} \sqrt{k} \sim \int \limits_{1}^{\sqrt{n}} \sqrt{k} dk = \frac{2}{3} k^{\frac{3}{2}} |_1^{\sqrt{n}} =
O(n^{\frac{3}{4}})$&lt;/p&gt;
&lt;p&gt;$\sum \limits_{k = 1}^{\sqrt{n}} \sqrt{\frac{n}{k}} \sim \int \limits_{1}^{\sqrt{n}} \sqrt{\frac{n}{k}} dk = $
$2 \sqrt{nk} |_1^{\sqrt{n}} = O(n^{\frac{3}{4}})$&lt;/p&gt;
&lt;p&gt;Получили, что асимптотика — $O(n^{\frac{3}{4}})$.&lt;/p&gt;
&lt;p&gt;Самое время вспомнить о том, что функция $f$ мультипликативная.
А для мультипликативных функций мы умеем считать ее первые $k$ значений за $O(k)$ при помощи линейного решета Эратосфена.
Тогда и префиксные суммы мы тоже можем посчитать за $O(k)$.
Пусть мы предпосчитали префиксные суммы для первых $k \ge \sqrt{n}$ чисел.
Тогда нам надо брать сумму времени работы только для таких $\left\lfloor \frac{n}{d} \right\rfloor$, которые больше $k$.
Получаем асимптотику
$O(k + \sum \limits_{i = 1}^{\frac{n}{k}} \sqrt{\frac{n}{i}}) = O(k + \frac{n}{\sqrt{k}})$
(этот интеграл мы уже брали, надо подставить только в другой точке).
Минимума эта величина достигает при $k = O(n^{\frac{2}{3}})$ (сумма возрастающей и убывающей функций достигает асимптотического минимума в точке пересечения). В этом случае асимптотика получается равна $O(n^{\frac{2}{3}})$.&lt;/p&gt;
&lt;p&gt;Ура, мы научились искать префиксную сумму мультипликативной функции $f$ за $O(n^{\frac{2}{3}})$, если
есть такая функция $g$, что $s_g$ и $s_{f * g}$ мы умеем считать за $O(1)$.&lt;/p&gt;
&lt;p&gt;Откуда же взять эту функцию $g$? Мы знаем несколько примеров таких функций: $\chi_1, id, 1$ и так далее.
Надо поперебирать эти функции, пока их свертка с $f$ не получится равной тоже какой-то простой функции.
Если не нашлось, то очень жаль, ничего не получилось.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;
Вернемся к нашей задаче поиска количества упорядоченных пар взаимно простых чисел $x, y \le n$.&lt;/p&gt;
&lt;p&gt;Мы уже выяснили, что $f(n) = \sum \limits_{d = 1}^{n} \mu(d) \left\lfloor \frac{n}{d} \right\rfloor^2$.
Как мы уже поняли, среди чисел вида $\left\lfloor \frac{n}{d} \right\rfloor$ всего $\sqrt{n}$ различных.
А $\mu$ является мультипликативной функцией, при этом
$\mu * 1 = \chi_1$. Так что сумму $\mu$ на отрезке мы умеем считать быстро.
Посмотрим, в каких точках $m$ нам надо будет считать $s_{\mu}(m)$.
Это будут такие $m$, что на них число $\left\lfloor \frac{n}{m} \right\rfloor$ увеличилось.
Нетрудно понять, что это будут как раз числа вида $\left\lfloor \frac{n}{k} \right\rfloor$.
Поэтому нам надо будет посчитать $s_{\mu}$ ровно в точках вида $\left\lfloor \frac{n}{k} \right\rfloor$,
а это мы умеем делать суммарно за $O(n^{\frac{2}{3}})$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;
$\varphi * 1 = id$. Так что $s_{\varphi}$ тоже можно считать за $O(n^{\frac{2}{3}})$. И в действительности в данном случае нам этого достаточно, потому что мы с самого начала выразили количество пар взаимно простых через префиксные суммы $\varphi$.&lt;/p&gt;
&lt;h2 id=&#34;сумма-попарных-нодов-чисел-не-больших-n&#34;&gt;Сумма попарных НОДов чисел, не больших $n$&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;
Дано число $n$. Надо найти&lt;/p&gt;
&lt;p&gt;$$\sum_{i = 1}^n \sum_{j = 1}^n gcd(i, j)$$&lt;/p&gt;
&lt;p&gt;То есть сумму попарных НОДов всех чисел, которые не больше $n$.&lt;/p&gt;
&lt;p&gt;Давайте воспользуемся похожими на пример с парами взаимно простых свойствами. Давайте перебирать этот самый НОД $d$ от $1$ до $n$ и считать количество пар чисел, у которых НОД равен $d$. Если НОД равен $d$, то точно оба числа $i$ и $j$ делятся на $d$, однако если мы поделим их на $d$ и получим числа $i&#39;$ и $j&#39;$, то эти два числа уже взаимно просты. Поэтому на самом деле количество пар чисел $i$ и $j$, НОД которых равен $d$, совпадает с количеством пар чисел $i&#39;$ и $j&#39;$, которые не больше $\left\lfloor \frac{n}{d} \right\rfloor$, и при этом взаимно просты. А это как раз $f(\left\lfloor \frac{n}{d} \right\rfloor)$ в обозначениях прошлого примера. То есть формула получается такая:&lt;/p&gt;
&lt;p&gt;$$\sum_{d = 1}^{n} d \cdot f(\left\lfloor \frac{n}{d} \right\rfloor)$$&lt;/p&gt;
&lt;p&gt;Как и раньше, мы знаем, что $\left\lfloor \frac{n}{d} \right\rfloor$ меняется не очень часто, поэтому есть $\sqrt{n}$ отрезков равенства, на которых нужно один раз посчитать $f$, а также высчитать сумму $d$ на отрезке. Так же, как и в примере с $\mu$ в прошлый раз, вызов $f(n)$ посчитает сразу же все нужные нам значения $f$, поэтому итоговая асимптотика будет $O(n^{\frac{2}{3}})$.&lt;/p&gt;
&lt;h2 id=&#34;сумма-попарных-ноков-чисел-не-больших-n&#34;&gt;Сумма попарных НОКов чисел, не больших $n$&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;
Дано число $n$. Надо найти&lt;/p&gt;
&lt;p&gt;$$\sum_{i = 1}^n \sum_{j = 1}^n lcm(i, j)$$&lt;/p&gt;
&lt;p&gt;То есть сумму попарных НОКов всех чисел, которые не больше $n$.&lt;/p&gt;
&lt;p&gt;В этом нам поможет следующий общеизвестный факт:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$a \cdot b = gcd(a, b) \cdot lcm(a, b)$$&lt;/p&gt;
&lt;p&gt;Давайте запишем нашу сумму как обычно:&lt;/p&gt;
&lt;p&gt;$$
\sum_{i = 1}^{n} \sum_{j = 1}^{n} \sum_{c = 1}^{n} c \cdot [lcm(i, j) = c] = \textcolor{gray}{\text{/ По замечанию выше /}} = \sum_{i = 1}^{n} \sum_{j = 1}^{n} \sum_{d = 1}^{n} \frac{i \cdot j}{d} \cdot [gcd(i, j) = d] =
$$&lt;/p&gt;
&lt;p&gt;$$
= \textcolor{gray}{\text{/ $i&#39; = \frac{i}{d}$ и $j&#39; = \frac{j}{d}$ /}} = \sum_{d = 1}^{n} \sum_{i&#39; = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{j&#39; = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \frac{i&#39; \cdot d \cdot j&#39; \cdot d}{d} \cdot [gcd(i&#39;, j&#39;) = 1] =
\sum_{d = 1}^{n} \sum_{i&#39; = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{j&#39; = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} i&#39; \cdot d \cdot j&#39; \cdot \chi_1(gcd(i&#39;, j&#39;)) =
$$&lt;/p&gt;
&lt;p&gt;$$
= \textcolor{gray}{\text{/ по формуле для $\chi_1$, доказанной в примерах в начале статьи /}} =
\sum_{d = 1}^{n} \sum_{i&#39; = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{j&#39; = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} i&#39; \cdot d \cdot j&#39; \sum_{k | gcd(i&#39;, j&#39;)} \mu(k) = $$&lt;/p&gt;
&lt;p&gt;$$ = \sum_{d = 1}^{n} \sum_{i&#39; = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{j&#39; = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} i&#39; \cdot d \cdot j&#39; \sum_{k = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} [k | i&#39;] \cdot [k | j&#39;] \cdot \mu(k) =
$$&lt;/p&gt;
&lt;p&gt;$$
= \sum_{d = 1}^{n} d \sum_{k = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \mu(k) \cdot \left ( \sum_{i&#39; = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} i&#39; \cdot [k | i&#39;] \right ) \cdot \left ( \sum_{j&#39; = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} j&#39; \cdot [k | j&#39;] \right ) = \star
$$&lt;/p&gt;
&lt;p&gt;Оба выражения в скобках равны сумме чисел $\le \left\lfloor \frac{n}{d} \right\rfloor$, которые делятся на $k$. Это числа $k, 2k, \ldots, \left\lfloor \frac{\left\lfloor \frac{n}{d} \right\rfloor}{k} \right\rfloor \cdot k = \left\lfloor \frac{n}{dk} \right\rfloor \cdot k$.
Их сумма равна&lt;/p&gt;
&lt;p&gt;$$k \cdot \frac{\left ( \left\lfloor \frac{n}{dk} \right\rfloor \right ) \cdot \left ( \left\lfloor \frac{n}{dk} \right\rfloor + 1 \right )}{2}$$&lt;/p&gt;
&lt;p&gt;Обозначим второй множитель за $g(\left\lfloor \frac{n}{dk} \right\rfloor)$&lt;/p&gt;
&lt;p&gt;Подставим это в нашу формулу:&lt;/p&gt;
&lt;p&gt;$$
\star = \sum_{d = 1}^{n} d \sum_{k = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \mu(k) \cdot k^2 \cdot g^2\left(\left\lfloor \frac{n}{dk} \right\rfloor\right) = \textcolor{gray}{\text{/ обозначим $l = kd$ /}} =
$$&lt;/p&gt;
&lt;p&gt;$$
= \sum_{l = 1}^{n} l \cdot g^2\left(\left\lfloor \frac{n}{l} \right\rfloor\right) \sum_{k | l} k \cdot \mu(k) = \textcolor{gray}{\text{/ $h(l) := l \cdot \sum_{k | l} k \cdot \mu(k) $ /}} = \sum_{l = 1}^{n} g^2\left(\left\lfloor \frac{n}{l} \right\rfloor\right) \cdot h(l)
$$&lt;/p&gt;
&lt;p&gt;При этом $h$ можно выразить как $id \cdot (1 * (id \cdot \mu))$, так что $h$ мультипликативна, потому что и свертка, и произведение мультипликативных функций являются мультипликативными. Кроме того, $g(n, l)$ вычисляется по формуле, поэтому ее мы можем считать за $O(1)$. Так что такую сумму можно считать за $O(n)$, так как мультипликативную функцию $h$ можно насчитать линейным решетом ($h(p^k) = p^k \cdot (1 - p)$ вычисляется за $O(1)$).&lt;/p&gt;
&lt;p&gt;Однако мы хотим быстрее. В $g$ мы подставляем всего $\sqrt{n}$ различных значений, поэтому как раньше, нам надо научиться быстро считать $s_h$. Для этого нужно найти какую-то мультипликативную функцию $q$, чтобы $s_q$ и $s_{h * q}$ можно было считать за $O(1)$.&lt;/p&gt;
&lt;p&gt;Давайте докажем, что $h * id^2 = id$. В этом нам поможет следующий факт:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Лемма:&lt;/strong&gt;
Для любых арифметических функций $f, g$ верно:&lt;/p&gt;
&lt;p&gt;$$(id \cdot f) * (id \cdot g) = id \cdot (f * g)$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
Это доказывается простой подстановкой:&lt;/p&gt;
&lt;p&gt;$$\left((id \cdot f) * (id \cdot g)\right)(n) = \sum_{d | n} d \cdot f(d) \cdot \frac{n}{d} \cdot g\left(\frac{n}{d}\right) = n \cdot \sum_{d | n}  f(d) \cdot g\left(\frac{n}{d}\right) = n \cdot (f * g)$$&lt;/p&gt;
&lt;p&gt;Мы хотим доказать, что $h * id^2 = id$. Запишем цепочку равенств:&lt;/p&gt;
&lt;p&gt;$$h * id^2 = (id \cdot (1 * (id \cdot \mu))) * (id \cdot id) = \textcolor{gray}{\text{/ по лемме /}} = id \cdot ((1 * (id \cdot \mu)) * id) = $$&lt;/p&gt;
&lt;p&gt;$$ = \textcolor{gray}{\text{/ по ассоциативности свертки /}} = id \cdot (1 * ((id \cdot \mu) * (id \cdot 1))) = \textcolor{gray}{\text{/ по лемме /}} = id \cdot (1 * (id \cdot (\mu * 1))) = $$&lt;/p&gt;
&lt;p&gt;$$ = \textcolor{gray}{\text{/мы доказывали, что $\mu * 1 = \chi_1$/}} = id \cdot (1 * (id \cdot \chi_1)) = \textcolor{gray}{\text{/$\chi_1$ не равна нулю только в единице, а $id(1) = 1$/}} = $$&lt;/p&gt;
&lt;p&gt;$$= id \cdot (1 * \chi_1) = \textcolor{gray}{\text{/ по одному из уже доказанных свойств /}} = id \cdot 1 = id$$&lt;/p&gt;
&lt;p&gt;Что и требовалось доказать. При этом $s_{id}$ и $s_{id^2}$ можно легко вычислять за $O(1)$:&lt;/p&gt;
&lt;p&gt;$$s_{id}(n) = \frac{n \cdot (n + 1)}{2}$$&lt;/p&gt;
&lt;p&gt;$$s_{id^2}(n) = \frac{n \cdot (n + 1) \cdot (2 n + 1)}{6}$$&lt;/p&gt;
&lt;p&gt;Так что мы научились искать сумму НОКов всех пар чисел, не больших $n$, за $O(n^{\frac{2}{3}})$.&lt;/p&gt;
&lt;h2 id=&#34;задачи-для-практики&#34;&gt;Задачи для практики&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.codechef.com/NOV15/problems/SMPLSUM&#34;&gt;https://www.codechef.com/NOV15/problems/SMPLSUM&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://acm.hdu.edu.cn/showproblem.php?pid=1695&#34;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=1695&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://poj.org/problem?id=3904&#34;&gt;http://poj.org/problem?id=3904&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://acm.hdu.edu.cn/showproblem.php?pid=5608&#34;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=5608&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.spoj.com/problems/DIVCNT2/&#34;&gt;https://www.spoj.com/problems/DIVCNT2/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Преобразование Уолша — Адамара и xor-and-or-свертки</title>
      <link>https://peltorator.ru/posts/hadamard/</link>
      <pubDate>Wed, 15 Sep 2021 17:59:03 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/hadamard/</guid>
      
      <description>&lt;!--- TODO: облачить все xor or and в ``---&gt;
&lt;p&gt;Быстрое преобразование Фурье сворачивает два массива, отправляя $a[i], b[j] \to c[i + j]$,
что соответствует тому, что $x^i \cdot x^j = x^{i + j}$.&lt;/p&gt;
&lt;p&gt;Сейчас мы рассмотрим случаи, когда
$x^i \cdot x^j = x^{i \oplus j}$, $x^i \cdot x^j = x^{i | j}$ и $x^i \cdot x^j = x^{i \&amp;amp; j}$.&lt;/p&gt;
&lt;p&gt;Преобразование Фурье выглядело примерно таким образом: была матрица&lt;/p&gt;
&lt;p&gt;$$M =
\begin{pmatrix}
\omega_0^0 &amp;amp; \omega_0^1 &amp;amp; \omega_0^2 &amp;amp; \ldots &amp;amp; \omega_0^{n - 1}\\&lt;br&gt;
\omega_1^0 &amp;amp; \omega_1^1 &amp;amp; \omega_1^2 &amp;amp; \ldots &amp;amp; \omega_1^{n - 1}\\&lt;br&gt;
\vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots\\&lt;br&gt;
\omega_{n - 1}^0 &amp;amp; \omega_{n - 1}^1 &amp;amp; \omega_{n - 1}^2 &amp;amp; \ldots &amp;amp; \omega_{n - 1}^{n - 1}
\end{pmatrix}
$$&lt;/p&gt;
&lt;p&gt;Были векторы $A$ и $B$. Мы применяли матрицу $M$ к $A$ и $B$, после чего
перемножали $MA$ и $MB$ поэлементно, а затем применяли $M^{-1}$ к $MA \cdot MB$.&lt;/p&gt;
&lt;h2 id=&#34;xor-свертка&#34;&gt;xor-свертка&lt;/h2&gt;
&lt;p&gt;Здесь мы хотим сделать ровно то же самое, надо лишь поменять матрицу.&lt;/p&gt;
&lt;p&gt;Давайте зададим матрицы $H_{2^k}$ рекурсивно.
$H_1 =
\begin{pmatrix}
1
\end{pmatrix}
$ и
$H_{2^k} = \frac{1}{\sqrt{2}}
\begin{pmatrix}
H_{2^{k - 1}} &amp;amp; H_{2^{k - 1}}\\&lt;br&gt;
H_{2^{k - 1}} &amp;amp; -H_{2^{k - 1}}
\end{pmatrix}
$&lt;/p&gt;
&lt;p&gt;Корень из двух — это не очень удобное число, давайте попытаемся от него избавиться.
Определим матрицы без этого корня:
$G_1 =
\begin{pmatrix}
1
\end{pmatrix}
$ и
$G_{2^k} =
\begin{pmatrix}
G_{2^{k - 1}} &amp;amp; G_{2^{k - 1}}\\&lt;br&gt;
G_{2^{k - 1}} &amp;amp; -G_{2^{k - 1}}
\end{pmatrix}
$&lt;/p&gt;
&lt;p&gt;Тогда легко заметить, что $\sqrt{n} \cdot H_n = G_n$. Мы будем считать именно $G_n$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Обозначение:&lt;/strong&gt;
$E_n$ — это матрица тождественного преобразования размера $n \times n$, то есть матрица,
у которой на главной диагонали стоят единицы, а в остальных ячейках нули.&lt;/p&gt;
&lt;p&gt;Из-за такого рекурсивного задания сразу видно, как написать быстрое преобразование Уолша-Адамара,
то есть как посчитать $G_{2^k} \cdot A$.
На нижнем уровне рекурсии не нужно менять ничего, потому что $G_1 = E_1$,
а на других уровнях надо сначала запуститься от двух половин, а потом сделать замену
$x, y \to x + y, x - y$. Напишем код:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hadamard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;hadamard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;hadamard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)];&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Лемма:&lt;/strong&gt; &lt;br&gt;
Удивительным образом получается, что $H_{2^k}^{-1} = H_{2^k}$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
Докажем это по индукции.
Для $H_1$ это очевидно, потому что $H_1 = E_1$.
Докажем для $H_{2^k}$, если уже известно для $H_{2^{k - 1}}$.&lt;/p&gt;
&lt;p&gt;$$H_{2^k} \cdot H_{2^k} =
\frac{1}{\sqrt{2}}
\begin{pmatrix}
H_{2^{k - 1}} &amp;amp; H_{2^{k - 1}}\\&lt;br&gt;
H_{2^{k - 1}} &amp;amp; -H_{2^{k - 1}}
\end{pmatrix}
\cdot
\frac{1}{\sqrt{2}}
\begin{pmatrix}
H_{2^{k - 1}} &amp;amp; H_{2^{k - 1}}\\&lt;br&gt;
H_{2^{k - 1}} &amp;amp; -H_{2^{k - 1}}
\end{pmatrix}
=$$&lt;/p&gt;
&lt;p&gt;$$ = \frac{1}{2}
\begin{pmatrix}
2H_{2^{k - 1}}^2 &amp;amp; 0\\&lt;br&gt;
0 &amp;amp; 2H_{2^{k - 1}}^2
\end{pmatrix} = \frac{1}{2}
\begin{pmatrix}
2E_{2^{k - 1}} &amp;amp; 0\\&lt;br&gt;
0 &amp;amp; 2E_{2^{k - 1}}
\end{pmatrix}
$$&lt;/p&gt;
&lt;p&gt;Мы получили, что $H_n \cdot H_n = E_n$.
Но мы знаем, что $H_n = \frac{G_n}{\sqrt{n}}$,
поэтому $G_n \cdot G_n = n \cdot E_n$.
Так что вместо того, чтобы домножать на $H$, можно домножать на $G$,
но в конце просто поделить на $n$ после обратного преобразования. Таким образом мы научились делать xor-умножение многочленов
без использования вещественных или комплексных чисел:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// we assume that a.size() == b.size() == 2^k
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xormult&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;hadamard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;hadamard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;hadamard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// inverse convolution is the same as direct
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Если вы внимательно следили за происходящим, то могли заметить, что я вас немного обманул.
Я доказал кучу всего, но никак не объяснил, почему все это даст нам xor-свертку.&lt;/p&gt;
&lt;p&gt;Обозначим xor-свертку за $\$$, то есть&lt;/p&gt;
&lt;p&gt;$$(a_0, a_1, \ldots, a_n) \$ (b_0, b_1, \ldots, b_n) =
(\sum \limits_{k = 0}^{n} a_k \cdot b_{0 \oplus k}, \sum \limits_{k = 0}^{n} a_k \cdot b_{1 \oplus k},
\ldots, \sum \limits_{k = 0}^{n} a_k \cdot b_{n \oplus k})$$&lt;/p&gt;
&lt;p&gt;Тогда нам необходимо доказать, что $(Ga) \cdot (Gb) = G (a \$ b)$.
Для $G_1$ это очевидно, потому что свертка — это просто умножение чисел.
Для $G_2$ необходимо написать условия:&lt;/p&gt;
&lt;p&gt;$$\begin{pmatrix}
a_0\\&lt;br&gt;
a_1
\end{pmatrix}
\$
\begin{pmatrix}
b_0\\&lt;br&gt;
b_1
\end{pmatrix} =
\begin{pmatrix}
a_0 \cdot b_0 + a_1 \cdot b_1\\&lt;br&gt;
a_0 \cdot b_1 + a_1 \cdot b_0
\end{pmatrix}
$$&lt;/p&gt;
&lt;p&gt;$$G_2a =
\begin{pmatrix}
a_0 + a_1\\&lt;br&gt;
a_0 - a_1
\end{pmatrix}
$$&lt;/p&gt;
&lt;p&gt;$$G_2b =
\begin{pmatrix}
b_0 + b_1\\&lt;br&gt;
b_0 - b_1
\end{pmatrix}
$$&lt;/p&gt;
&lt;p&gt;$$(G_2a) \cdot (G_2b) =
\begin{pmatrix}
(a_0 + a_1) \cdot (b_0 + b_1)\\&lt;br&gt;
(a_0 - a_1) \cdot (b_0 - b_1)
\end{pmatrix}
= G (a \$ b)$$&lt;/p&gt;
&lt;p&gt;Для бóльших размерностей все доказывается по индукции.
Таким образом можно было бы изначально искать матрицу $G$,
предположив, что $G_2 =
\begin{pmatrix}
c_0 &amp;amp; c_1 \\&lt;br&gt;
c_2 &amp;amp; c_3
\end{pmatrix}
$, решить систему уравнений.&lt;/p&gt;
&lt;h2 id=&#34;and-свертка&#34;&gt;and-свертка&lt;/h2&gt;
&lt;p&gt;and-свертка делается аналогично, надо только поменять матрицу.
$T_1 = \begin{pmatrix}
1\\&lt;br&gt;
\end{pmatrix}
$,
$
T_{2^k} =  \begin{pmatrix}
T_{2^{k - 1}} &amp;amp; T_{2^{k - 1}}\\&lt;br&gt;
0 &amp;amp; T_{2^{k - 1}}
\end{pmatrix}
$.&lt;/p&gt;
&lt;p&gt;К сожалению, в отличие от xor-свертки, здесь обратная матрица не совпадает с прямой,
но зато нет корней из двойки, поэтому не придется в конце делить на $n$.&lt;/p&gt;
&lt;p&gt;Обратные матрицы:
$T_1^{-1} = \begin{pmatrix}
1\\&lt;br&gt;
\end{pmatrix}
$,
$
T_{2^k}^{-1} =  \begin{pmatrix}
T_{2^{k - 1}}^{-1} &amp;amp; -T_{2^{k - 1}}^{-1}\\&lt;br&gt;
0 &amp;amp; T_{2^{k - 1}}^{-1}
\end{pmatrix}
$.&lt;/p&gt;
&lt;p&gt;Из-за рекуррентного задания матриц, мы опять же легко можем написать алгоритм:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;andFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;andFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;andFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;revAndFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;revAndFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;revAndFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;andmult&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;andFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;andFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;revAndFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Проверка правильности выбранной матрицы и ее обратной остается читателю в качестве упражнения.&lt;/p&gt;
&lt;h2 id=&#34;or-свертка&#34;&gt;or-свертка&lt;/h2&gt;
&lt;p&gt;Все аналогично.&lt;/p&gt;
&lt;p&gt;$Q_1 = \begin{pmatrix}
1\\&lt;br&gt;
\end{pmatrix}
$,
$
Q_{2^k} =  \begin{pmatrix}
Q_{2^{k - 1}} &amp;amp; 0\\&lt;br&gt;
Q_{2^{K - 1}} &amp;amp; Q_{2^{k - 1}}
\end{pmatrix}
$.&lt;/p&gt;
&lt;p&gt;Обратные матрицы:&lt;/p&gt;
&lt;p&gt;$Q_1^{-1} = \begin{pmatrix}
1\\&lt;br&gt;
\end{pmatrix}
$,
$
Q_{2^k}^{-1} =  \begin{pmatrix}
Q_{2^{k - 1}}^{-1} &amp;amp; 0\\&lt;br&gt;
-Q_{2^{K - 1}}^{-1} &amp;amp; Q_{2^{k - 1}}^{-1}
\end{pmatrix}
$.&lt;/p&gt;
&lt;p&gt;Из-за рекуррентного задания матриц, мы опять же легко можем написать алгоритм:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;orFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;orFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;orFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;revOrFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;revOrFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;revOrFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ormult&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;orFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;orFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;revOrFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Проверка правильности выбранной матрицы и ее обратной остается читателю в качестве упражнения.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Заметим, что $a | b = \overline{\overline{a} \&amp;amp; \overline{b}}$, где $\overline{x}$ — замена всех единичных битов числа
на нулевые, а нулевых на единичные. Поэтому or-свертку можно написать через $and$-свертку (и наоборот).&lt;/p&gt;
&lt;h2 id=&#34;оптимизации&#34;&gt;Оптимизации&lt;/h2&gt;
&lt;p&gt;Убрать рекурсию здесь проще, чем в FFT. Рекурсия головная, поэтому раскрывается очевидным образом.
Также прямые и обратные отображения очень похожи, так что их можно объединить в одну функцию.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hadamard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;andFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;orFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;альтернативный-взгляд-на-and-or-свертки&#34;&gt;Альтернативный взгляд на and-or-свертки&lt;/h2&gt;
&lt;p&gt;Представленные выше алгебраические рассуждения на самом деле необходимы только для xor-свертки. Для and- и or-сверток можно обойтись без этого. Давайте докажем иначе, что or-свертка будет выглядеть так.&lt;/p&gt;
&lt;p&gt;Для and-свертки это будет аналогично из-за замечания выше об их эквивалентности, так как операции and и or отличаются заменой нулей на единицы, а единиц на нули.&lt;/p&gt;
&lt;p&gt;Для альтернативного доказательства работы алгоритма or-свертки давайте введем понятие массива сумм по подмножествам (эта техника также известна как SOS-DP (sum over subsets)).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Определение:&lt;/strong&gt;
Пусть дан массив $A$. Давайте назовем массивом сумм по подмножествам массива $A$ такой массив $B$, что&lt;/p&gt;
&lt;p&gt;$$ B_i = \sum_{j : j \subset i} A_j$$&lt;/p&gt;
&lt;p&gt;При этом условие $j \subset i$ в данном случае воспринимается как содержание подмножеств единичных битов. То есть если бы мы воспринимали числа как маски. На языке битовых операций это условие можно записать как &lt;code&gt;i | j = i&lt;/code&gt;, то есть $j$ — это число $i$, в котором занулили некоторые единичные биты.&lt;/p&gt;
&lt;p&gt;Это называется массивом сумм по подмножествам именно потому, что если все индексы лежат в промежутке $[0, 2^k)$, то их стоит воспринимать как маски подмножеств множества ${, 0, 1, 2, \ldots, k - 1 ,}$.&lt;/p&gt;
&lt;p&gt;Давайте покажем, что or-свертка как раз таки насчитывает массив сумм по подмножествам.&lt;/p&gt;
&lt;p&gt;Давайте считать динамику по битам. &lt;code&gt;dp[mask][ind]&lt;/code&gt; — это сумма по тем подмножествам маски $mask$, в которых изменялись только первые $ind$ битов. Если $ind = 0$, то мы не меняли никаких битов, и это просто $A_{mask}$. Далее при переходе от $ind - 1$ к $ind$ нужно, возможно, поменять текущий бит, либо не менять его. То есть если бит $ind$ в $mask$ равен нулю, то мы ничего поменять не можем:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[mask][ind] = dp[mask][ind - 1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;А если он равен единице, то мы его можем занулить:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[mask][ind] = dp[mask][ind - 1] + dp[mask ^ (1 &amp;lt;&amp;lt; ind)][ind - 1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Теперь если мы уберем вторую координату динамики и будем насчитывать ее in-place, то как раз таки получим or-свертку. Алгоритм перебирает бит, после чего рассматривает все пары чисел с битом и без и прибавляет меньшее к большему. Соответственно, обратная or-свертка — это обратное преобразование: по массиву сумм по подмножествам получаем изначальный массив.&lt;/p&gt;
&lt;p&gt;Тогда остается заметить, что с точки зрения массивов сумм по подмножествам or-свертка — это просто поэлементное умножение, потому что если &lt;code&gt;or&lt;/code&gt; двух масок — это подмаска $mask$, то это равносильно просто тому, что обе эти маски — это подмаски $mask$.
Что и требовалось доказать.&lt;/p&gt;
&lt;p&gt;Из такого объяснения вытекает немного другой способ написания той же or-свертки, который может показаться вам более простым:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;orFold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;задачи-для-практики&#34;&gt;Задачи для практики&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://csacademy.com/contest/archive/task/random_nim_generator/&#34;&gt;https://csacademy.com/contest/archive/task/random_nim_generator/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://csacademy.com/contest/archive/task/and-closure/&#34;&gt;https://csacademy.com/contest/archive/task/and-closure/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://csacademy.com/contest/archive/task/token-grid/&#34;&gt;https://csacademy.com/contest/archive/task/token-grid/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.codechef.com/NOV19A/problems/MDSWIN&#34;&gt;https://www.codechef.com/NOV19A/problems/MDSWIN&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Дерево Ли Чао</title>
      <link>https://peltorator.ru/posts/li-chao/</link>
      <pubDate>Wed, 15 Sep 2021 17:39:24 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/li-chao/</guid>
      
      <description>&lt;h2 id=&#34;мотивация&#34;&gt;Мотивация&lt;/h2&gt;
&lt;p&gt;Convex Hull Trick (CHT) позволяет отвечать на запросы поиска минимума (или максимума) набора линейных функций. Однако его проблемой является то, что добавляемые прямые должны быть монотонно упорядочены по углу наклона. Не всегда в задачах это выполнено. Конечно, CHT можно реализовать на двоичном дереве (&lt;code&gt;std::set&lt;/code&gt;, к примеру) вместо стека, и в таком случае можно вставлять в произвольное место, удаляя устаревших соседей по обе стороны, однако это далеко не самый приятный алгоритм. Также, в силу того, что в CHT поддерживается стек, алгоритм амортизированный, так что какая-то одна операция добавления новой прямой может выкинуть из стека почти все старые прямые и будет работать за линейное время. Тогда если нам нужен персистентный Convex Hull Trick, мы этого сделать не сможем (есть способ сделать Convex Hull Trick неамортизированным и персистентным при помощи бинарных подъемов по стеку, либо спуска по декартову дереву в случае реализации с двоичным деревом поиска, прочитать можно &lt;a href=&#34;https://peltorator.ru/try_web/post/persistent_cht/&#34;&gt;здесь&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Чтобы побороть описанные выше две проблемы, нам может как раз помочь дерево Ли Чао. Это очень простая в реализации структура данных, которой не нужно, чтобы прямые были упорядочены по углу наклона. Кроме того, эта структура основана на обычном дереве отрезков, поэтому все операции будут работать за неамортизированное время, и это дерево можно делать персистентным, как и любое другое дерево отрезков.&lt;/p&gt;
&lt;p&gt;Также, этой структуре не нужно уметь пересекать прямые, а только находить значение в точке, и ее можно использовать для произвольных функций, таких что любые две из них пересекаются не более, чем в одной точке. Помимо этого мы научимся производить массовые операции, так как мы имеем дело с деревом отрезков.&lt;/p&gt;
&lt;h2 id=&#34;идея&#34;&gt;Идея&lt;/h2&gt;
&lt;p&gt;Будем решать задачу, в которой есть изначально пустое множество линейных функций $L$ и поступают запросы двух видов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Добавить линейную функцию $f$ в множество $L$.&lt;/li&gt;
&lt;li&gt;Для данного $x$ найти минимум $f(x)$ по всем функциям $f$ из $L$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Давайте построим дерево отрезков на $x$ координатах. Обозначим максимальное значение $x$ по модулю, которое нас интересует, за $C$. Тогда время обработки одного запроса к структуре будет равно $O(\log C)$. Так как $C$ может быть очень большим числом, часто бывает ситуация, в которой дерево отрезков будет неявным. Если точки $x$ бывают вещественные, можно сделать спуск в дереве до нужной точности. Тогда если все считается с точностью до $\varepsilon$, то асимптотика будет $O(\log (C \cdot \varepsilon^{-1}))$ на запрос.&lt;/p&gt;
&lt;p&gt;Будем в каждой вершине дерева отрезков хранить одну линейную функцию (изначально в каждой вершине хранится фиктивная функция $f(x) = +\infty$), а минимум в точке будет вычисляться как минимум по всем прямым, хранящимся в предках листа, отвечающего за эту точку.&lt;/p&gt;
&lt;p&gt;Осталось понять, как обрабатывать запрос добавления новой прямой. Мы хотим добавить эту прямую в некоторую вершину дерева и переместить другие значения в дереве так, чтобы условие на то, что оптимальная прямая для каждой точки лежит на пути от этой точки до корня, не испортилось. Мы бы хотели положить новую прямую в корень, чтобы она лежала на пути до корня от любого листа, однако в корне, вероятно, уже лежит какая-то прямая, а мы не можем хранить сразу две прямые в вершине. Поэтому нам придется как-то решать этот конфликт.&lt;/p&gt;
&lt;p&gt;Пускай текущая вершина отвечает за полуинтервал $[L, R)$, и у нас есть две конфликтующие функции $f$ и $g$. Если одна из них меньше другой на всем полуинтервале, то нет смысла хранить бóльшую функцию, поэтому мы можем оставить в текущей вершине меньшую и завершиться. Это можно проверить, сравнив относительный порядок значений функций $f$ и $g$ в точках $L$ и $R$. Если в точке $L$ одна была больше другой, а в точке $R$ порядок поменялся, то между этими точками точно произошло пересечение.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Ровно в этот момент мы пользуемся тем, что любые две функции должны пересекаться не более, чем в одной точке, потому что если функции пересекаются в двух точках, то они могли не изменить свой относительный порядок даже если пересекались на этом полуинтервале.&lt;/p&gt;
&lt;p&gt;Пусть $M$ — середина полуинтервала $[L, R)$, тогда посмотрим, в какой половине пересекаются функции. Если они пересекаются в левой половине ($[L, M)$), то в правой половине ($[M, R)$) одна из функций меньше другой во всех точках. Пусть функция $f$ меньше $g$ на правой половине. Тогда функция $g$ точно не будет минимумом для точек из правой половины. Оставим функцию $f$ в текущей вершине и протолкнем функцию $g$ дальше в левого сына. Там опять может возникнуть конфликт, который мы будем решать аналогичным образом. В случае, если функции $f$ и $g$ пересекаются в правой половине, рассуждение симметрично: одна из функций точно не будет наименьшей для точек в левой половине, поэтому мы можем оставить меньшую функцию в текущей вершине и рекурсивно попытаться протолкнуть оставшуюся прямую в правое поддерево.&lt;/p&gt;
&lt;script type=&#34;text/tikz&#34;&gt;
\begin{tikzpicture}[line cap=round,line join=round,x=1cm,y=1cm]
%\clip(-11.10540769350248,-8.233879440487197) rectangle (11.520907363506577,9.983315286970425);
\draw [line width=2pt] (-7.5,2.5)-- (-7.5,-2.5);
\draw [line width=2pt] (-7.5,2.5)-- (0,2.5);
\draw [line width=2pt] (0,2.5)-- (0,-2.5);
\draw [line width=2pt] (0,-2.5)-- (-7.5,-2.5);
\draw [line width=2pt] (0,2.5)-- (7.5,2.5);
\draw [line width=2pt] (7.5,2.5)-- (7.5,-2.5);
\draw [line width=2pt] (7.5,-2.5)-- (0,-2.5);
\draw [line width=2pt, color=blue] (-7.5,-1.875)-- (7.5,1.25);
\draw [line width=2pt, color=green] (-7.5,0)-- (7.5,-1.875);
\begin{scriptsize}
\draw [fill=green] (-7.5,0) circle (2pt);
\draw [fill=blue] (-7.5,-1.875) circle (2pt);
\draw [fill=blue] (7.5,1.25) circle (2pt);
\draw [fill=green] (7.5,-1.875) circle (2pt);
\draw [fill=red] (-1.875,-0.703125) circle (2pt);
\draw [fill=blue] (0,-0.3125) circle (2pt);
\draw [fill=green] (0,-0.9375) circle (2pt);
\end{scriptsize}
\end{tikzpicture}
&lt;/script&gt;
&lt;p&gt;Можно заметить, что на самом деле прямая, которая остается в текущей вершине — это всегда прямая с меньшим значением в точке $M$. И точку $R$ можно даже не подставлять в уравнения прямых. Просто если относительный порядок на прямых в точке $L$ такой же, как в $M$, то в правое поддерево проталкивается прямая с бóльшим значением в точке $M$, а если относительный порядок разный, то эта прямая проталкивается в левое поддерево.&lt;/p&gt;
&lt;p&gt;Можно смотреть на это иначе: в вершине дерева отрезков находится та прямая из множества, которая имеет минимальное значение в точке $M$ из всех прямых, а оставшиеся прямые разделены по двум частям в зависимости от того, в какой из двух половин они могут быть меньше той прямой, которая хранится в текущей вершине.&lt;/p&gt;
&lt;p&gt;Таким образом, мы будем постепенно спускаться по дереву, каждый раз запускаясь в то поддерево, в котором пересекаются конфликтующие прямые (если они не пересекаются вовсе, то мы все равно запустимся в какое-то поддерево, и в этом нет ничего страшного). Когда мы дойдем до листа, мы просто выберем меньшую функцию в этой точке и завершимся. Очевидно, что такой линейный спуск по дереву отрезков будет работать за $O(\log C)$.&lt;/p&gt;
&lt;p&gt;С кодом можно ознакомиться по &lt;a href=&#34;https://pastebin.com/eKpCKJQh&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Обратите внимание на то, что мы действительно нигде не пользовались тем, что мы работаем именно с линейными функциями, и мы их нигде не пересекали. Все, что нам было нужно, — считать значения функций в концах и середине отрезка текущей вершины, чтобы узнавать их относительный порядок. Таким образом, можно использовать эту структуру, к примеру, для набора кубических функций вида $k x^3 + b$, потому что любые две такие функции пересекаются не более, чем в одной точке.&lt;/p&gt;
&lt;h2 id=&#34;удаление-прямых&#34;&gt;Удаление прямых&lt;/h2&gt;
&lt;p&gt;Чтобы поддерживать не только добавление прямых в множество, но и удаление, можно воспользоваться идеей из задачи dynamic connectivity offline (подробнее можно прочитать &lt;a href=&#34;https://cp-algorithms.com/data_structures/deleting_in_log_n.html&#34;&gt;здесь&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Если необходимо поддерживать структуру в online режиме, то подойдет корневая декомпозиция. Можно хранить прямые в множествах, каждое из которых имеет размер не больше $K$. Чтобы найти минимум, нужно перебрать все множества и запросить минимум в каждом из них. А для удаления прямой нужно перестроить с нуля всю структуру множества, из которого эта прямая удаляется. При оптимально подобранной константе $K$ такое решение будет работать за $O \left(n \sqrt{n \log n}\right)$&lt;/p&gt;
&lt;h2 id=&#34;кусочно-линейные-функции&#34;&gt;Кусочно-линейные функции&lt;/h2&gt;
&lt;p&gt;На самом деле явно видно, что наша структура не использует дерево отрезков по полной. Мы всегда и в запросе update, и в запросе get запускаемся только в одно из поддеревьев. Давайте поймем, что дерево отрезков позволяет нам расширить спектр операций, которые может поддерживать наша структура.&lt;/p&gt;
&lt;p&gt;Действительно, обычный запрос update в дереве отрезков применяет какую-то операцию к отрезку точек, однако мы добавляем новую прямую, которая действует сразу на все точки. Давайте научимся применять добавляемую прямую только к отрезку точек, то есть добавлять в множество не прямую, а какой-то отрезок:&lt;/p&gt;
&lt;script type=&#34;text/tikz&#34;&gt;
\begin{tikzpicture}[line cap=round,line join=round,x=1cm,y=1cm]
\clip(-7.041276332384763,-4.770513279438415) rectangle (8.67163652095256,7.088852505304018);
\draw [line width=2pt,color=red] (3.2230854678409644,0.8080541817460658)-- (5.559887212211516,-0.8962297972308442);
\draw [line width=2pt,color=red] (-6.3701006406276175,2.354208719374603)-- (-4.9820755443473645,2.6407687392517984);
\draw [line width=2pt,color=lightgray] (-4.9820755443473645,2.6407687392517984)-- (2.3270186335334593,4.149743021136775);
\draw [line width=2pt,color=red] (2.3270186335334593,4.149743021136775)-- (3.223085467840964,4.334737464348635);
\draw [line width=2pt,color=lightgray] (3.223085467840964,4.334737464348635)-- (5.559887212211515,4.817173953508976);
\draw [line width=2pt,color=red] (5.559887212211515,4.817173953508976)-- (7.246601253260937,5.165398787790124);
\draw [line width=2pt,color=red] (-4.9820755443473645,2.0379498366778566)-- (-2.1884554138592613,0.8216798478939982);
\draw [line width=2pt,color=lightgray] (-2.1884554138592613,0.8216798478939982)-- (-0.8625157399204945,0.2443999898526673);
\draw [line width=2pt,color=red] (-0.8625157399204945,0.2443999898526673)-- (0.1834862063664869,-0.2110022180545608);
\draw [line width=2pt,color=red] (-2.1884554138592613,-0.632680728316889)-- (-0.8625157399204945,0.2443999898526673);
\draw [line width=2pt,color=lightgray] (-0.8625157399204945,0.2443999898526673)-- (0.1834862063664869,0.9363078920658016);
\draw [line width=2pt,color=red] (0.1834862063664869,0.9363078920658016)-- (2.3270186335334593,2.354208719374603);
\begin{scriptsize}
\draw [fill=blue] (-4.9820755443473645,2.0379498366778566) circle (2.5pt);
\draw [fill=blue] (0.1834862063664869,-0.2110022180545608) circle (2.5pt);
\draw [fill=blue] (-2.1884554138592613,-0.632680728316889) circle (2.5pt);
\draw [fill=blue] (2.3270186335334593,2.354208719374603) circle (2.5pt);
\draw [fill=blue] (3.2230854678409644,0.8080541817460658) circle (2.5pt);
\draw [fill=blue] (5.559887212211516,-0.8962297972308442) circle (2.5pt);
\draw [fill=blue] (-6.3701006406276175,2.354208719374603) circle (2.5pt);
\draw [fill=blue] (7.246601253260937,5.165398787790124) circle (2.5pt);
\draw [fill=lightgray] (-4.9820755443473645,2.6407687392517984) circle (2pt);
\draw [fill=lightgray] (-2.1884554138592613,0.8216798478939982) circle (2pt);
\draw [fill=lightgray] (-0.8625157399204945,0.2443999898526673) circle (2pt);
\draw [fill=lightgray] (0.1834862063664869,0.9363078920658016) circle (2pt);
\draw [fill=lightgray] (2.3270186335334593,4.149743021136775) circle (2pt);
\draw [fill=lightgray] (3.223085467840964,4.334737464348635) circle (2pt);
\draw [fill=lightgray] (5.559887212211515,4.817173953508976) circle (2pt);
\end{scriptsize}
\end{tikzpicture}
&lt;/script&gt;
&lt;p&gt;Действительно, обычное дерево отрезков разбивает отрезок запроса на логарифм подотрезков. Тогда давайте запустим обычный запрос изменения к дереву отрезков, а в тот момент, когда отрезок текущей вершины лежит строго внутри отрезка запроса, мы запустим из этой вершины наше старое добавление прямой в множество, которое мы раньше запускали из корня. Таким образом, мы для каждой из логарифма вершин, в которых останавливается обычный запрос изменения для дерева отрезков, запустим нашу процедуру, работающую $O(\log C)$, и итоговая асимптотика будет $O(\log^2 C)$.&lt;/p&gt;
&lt;p&gt;Так мы, к примеру, научились находить минимум набора кусочно-линейных функций, потому что любую кусочно-линейную функцию можно разбить на линейные отрезки и добавить их в наше множество по отдельности.&lt;/p&gt;
&lt;p&gt;С кодом можно ознакомиться по &lt;a href=&#34;https://pastebin.com/64r3dazB&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;ленивые-обновления&#34;&gt;Ленивые обновления&lt;/h2&gt;
&lt;p&gt;Можно пойти еще дальше и добавить новые операции к поддерживаемой структуре. Для начала давайте переформулируем решаемую задачу на языке массивов.&lt;/p&gt;
&lt;p&gt;Пусть у нас есть массив $A$ ($A_i$ — это минимум значений наших линейных функций в точке $i$). Изначально все его элементы равны $+\infty$. Кроме того есть запросы трех видов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Вставить (Немного странное слово, скорее это &amp;laquo;добавить прямую на полуинтервале&amp;raquo;, но мы не будем использовать это слово из-за его схожести со словом &amp;laquo;прибавить&amp;raquo;) линейную функцию на полуинтервале, то есть для данных $l$, $r$, $a$, $b$ присвоить $A_i = \min(A_i, a \cdot i + b)$ для всех $i$ на полуинтервале от $l$ до $r$.&lt;/li&gt;
&lt;li&gt;Прибавить линейную функцию на полуинтервале, то есть для данных $l$, $r$, $a$, $b$ прибавить $a \cdot i + b$ к $A_i$ для всех $i$ на полуинтервале от $l$ до $r$.&lt;/li&gt;
&lt;li&gt;Поиск оптимальной прямой в точке, то есть для данного $i$ вывести $A_i$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Комбинация первого и третьего запроса — это ровно та задача, которую мы решали раньше. Однако теперь мы можем еще менять старые прямые с помощью второй операции. При этом обратите внимание, что после второй операции &amp;laquo;прямые&amp;raquo; перестают быть &amp;laquo;прямыми&amp;raquo;, потому что мы прибавляем линейную функцию к другой линейной функции, но только на отрезке, а не на всей области определения.
Что же нам делать, ведь для прямых, хранящихся в некоторых вершинах дерева отрезков для некоторых точек на этом отрезке эта прямая изменится, а для других — нет.&lt;/p&gt;
&lt;p&gt;Чтобы решить эту проблему, давайте введем операцию очищения вершины. Если в данный момент в какой-то вершине дерева хранится какая-то прямая, но она нам мешает, мы можем запустить операцию вставки этой прямой для левого и правого поддерева текущей вершины, после чего данную прямую можно будет удалить из текущей вершины. Такой процесс займет $O(\log C)$ времени.&lt;/p&gt;
&lt;p&gt;Кроме того, будем в каждой вершине дерева хранить ленивое обновление: какую линейную функцию нужно добавить ко всем прямым на этом отрезке. Тогда операция первого типа будет работать так же, как и раньше, только перед рекурсивным запуском нужно протолкнуть ленивое обновление в детей. А операция прибавления прямой на отрезке сначала очищает все вершины, которые посетила бы стандартная операция обновления в дереве отрезков (чтобы у нас не было проблем с тем, что прямая перестает быть прямой из-за того, что к одним точкам мы прибавили значение, а к другим — нет), а затем просто оставляет ленивое обновление в логарифме вершин, на которые разбивается отрезок запроса. Такая операция работает за $O(\log^2 C)$, потому что производит очистку логарифма вершин дерева, и каждая очистка занимает $O(\log C)$ времени.&lt;/p&gt;
&lt;p&gt;Операция третьего типа просто проталкивает ленивые обновления на пути и работает как и раньше за $O(\log^2 C)$.&lt;/p&gt;
&lt;p&gt;Такое модифицированное дерево Ли Чао является очень функциональным инструментом для работы с линейными функциями, и многие идейные задачи можно решить просто явным применением этой структуры. Операции можно модифицировать в зависимости от задачи. К примеру, если прибавлять на отрезке не линейную функцию, а константу, можно поддерживать не только минимум значений прямых в точке, но и на целом отрезке.&lt;/p&gt;
&lt;p&gt;С кодом можно ознакомиться по &lt;a href=&#34;https://pastebin.com/fYNWDXMj&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;задачи-для-практики&#34;&gt;Задачи для практики&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Типичная &lt;a href=&#34;https://csacademy.com/contest/archive/task/squared-ends&#34;&gt;задача&lt;/a&gt; на convex hull trick.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Еще одна типичная &lt;a href=&#34;https://atcoder.jp/contests/dp/tasks/dp_z&#34;&gt;задача&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Далее представлены задачи, в которых можно применить продвинутые вариации дерева Ли Чао.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://tlx.toki.id/problems/troc-13/F&#34;&gt;https://tlx.toki.id/problems/troc-13/F&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://training.olinfo.it/#/task/oii_candele/statement&#34;&gt;https://training.olinfo.it/#/task/oii_candele/statement&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://oj.uz/problem/view/NOI20_progression&#34;&gt;https://oj.uz/problem/view/NOI20_progression&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc177/tasks/abc177_f&#34;&gt;https://atcoder.jp/contests/abc177/tasks/abc177_f&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/contest/713/problem/C&#34;&gt;https://codeforces.com/contest/713/problem/C&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Алгоритм Фараха-Колтона и Бендера</title>
      <link>https://peltorator.ru/posts/farach_colton_bender/</link>
      <pubDate>Wed, 15 Sep 2021 17:32:38 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/farach_colton_bender/</guid>
      
      <description>&lt;p&gt;Задача RMQ (Range Minimum Query) состоит в том, что на вход дан массив длины $n$ и $q$ запросов (отрезков этого массива), и необходимо для каждого запроса найти минимум на соответствующем отрезке массива. Есть много подходов к решению этой задачи. Есть тупое решение, которое работает за $O(n \cdot q)$, есть решение деревом отрезков, работающее за $O(n + q \log n)$, есть решение при помощи разреженных таблиц, работающее за $O(n \log n + q)$, и так далее. В этой статье мы рассмотрим подход, который нужен для этой конкретной задачи (дерево отрезков, к примеру, применимо для практически любых операций) и при этом работает за линейное время, а также альтернативный подход, который одновременно легче в реализации и быстрее на практике.&lt;/p&gt;
&lt;p&gt;Стоит обратить внимание на то, что данная задача может ставиться в двух формулировках: offline и online. Offline означает, что все запросы даны заранее, и можно находить на них ответы в произвольном порядке. Однако в online версии задачи следующий запрос дается только после ответа на предыдущий. Мы рассмотрим обе версии задачи.&lt;/p&gt;
&lt;p&gt;Кроме того, эту задачу можно делить на static и dynamic версии. В static версии массив фиксирован, а в dynamic версии могут приходить запросы изменения массива. Мы будем рассматривать именно static версию задачи.&lt;/p&gt;
&lt;h2 id=&#34;rmq-offline-вариация-алгоритма-тарьяна-за-oalphan-на-запрос&#34;&gt;RMQ offline. Вариация алгоритма Тарьяна за $O(\alpha(n))$ на запрос.&lt;/h2&gt;
&lt;p&gt;Ознакомиться с алгоритмом можно в &lt;a href=&#34;https://peltorator.ru/try_web/post/rmq_offline/&#34;&gt;соответствующей статье&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;С первого взгляда это может показаться не очень ясным, но данный алгоритм имеет очень интересную связь с оригинальным алгоритмом Тарьяна для поиска LCA в дереве. Более глубокая связь между этими двумя алгоритмами станет понятна, когда мы разберем алгоритм Фараха-Колтона и Бендера (ФКБ), а пока можете воспринимать данный алгоритм как самостоятельный.&lt;/p&gt;
&lt;h2 id=&#34;rmq-online-улучшаем-разреженные-таблицы&#34;&gt;RMQ online. Улучшаем разреженные таблицы.&lt;/h2&gt;
&lt;p&gt;Разреженные таблицы хорошо подходят для решения задачи RMQ, потому что отвечают на запрос за константное время. Однако проблема в том, что на их построение уходит $O(n \log n)$ времени и памяти. В дальнейшем мы будем пытаться бороться с этим.&lt;/p&gt;
&lt;p&gt;Давайте применим идею, схожую с идеей корневой декомпозиции. Разобьем массив на блоки. Однако длина блока будет не $\sqrt{n}$, а порядка $\log n$. Тогда количество блоков будет равно $\frac{n}{\log n}$. Давайте на каждом блоке за линейное время найдем минимум и на получившемся сжатом массиве построим разреженную таблицу. Ее построение займет $O\left(\frac{n}{\log n} \log \left( \frac{n}{\log n} \right)\right) = O\left( \frac{n}{\log n} \log n \right) = O(n)$ времени. Теперь мы умеем отвечать на запросы поиска минимума в том случае, если концы отрезка совпадают с концами блоков. Но что делать, если это не так?&lt;/p&gt;
&lt;p&gt;Так же, как и в случае корневой декомпозиции, можно заметить, что любой отрезок запроса разбивается на несколько целых блоков, а также по краям слева и справа будут нецелые блоки. Для целых блоков мы можем найти минимум, используя нашу разреженную таблицу, остается найти минимум на маленьких кусочках слева и справа. Можно просто пройтись по ним и насчитать минимум. Так как длина блока — $O(\log n)$, то асимптотика ответа на запрос будет $O(\log n)$, но можно сделать и лучше.&lt;/p&gt;
&lt;p&gt;Давайте заметим, что нам надо уметь искать минимумы на префиксах и суффиксах блоков. Все эти значения можно предпосчитать заранее за $O(n)$ (для каждого элемента массива сохранить минимум до конца и до начала его блока), тогда на запросы мы будем отвечать за $O(1)$, ведь минимум на отрезке — это минимум из трех величин: минимум на суффиксе левого неполного блока, минимум в разреженной таблице по целым блокам и минимум на префиксе правого неполного блока.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Упражнение:&lt;/strong&gt;
Почему же на этом статья не заканчивается, а только начинается?
Стоит задуматься над этим вопросом, чтобы проверить свое понимание происходящего.&lt;/p&gt;
&lt;p&gt;На самом деле, к сожалению, этого не достаточно. И проблема находится там, где ее не ждали: в маленьких отрезках. Действительно, если длина отрезка запроса не меньше логарифма, то он обязательно состоит из нескольких (возможно, нуля) целых блоков, одного префикса и одного суффикса. Но для маленьких отрезочков это может быть неверно в том случае, если отрезок целиком лежит внутри блока. Тогда он не разбивается на префикс и суффикс, да и внутренних целых блоков у него тоже нет.&lt;/p&gt;
&lt;p&gt;Стоит помнить о том, что все последующие манипуляции, которые мы будем производить, нужны именно для того, чтобы побороть маленькие отрезки. Уже сейчас мы можем просто пройтись по этим отрезкам за линию и найти минимум, тогда для больших отрезков мы будем отвечать на запрос за $O(1)$, а для маленьких за $O(\log n)$, потому что их длина не больше логарифма.&lt;/p&gt;
&lt;p&gt;Можно пойти с другой стороны и заметить, что маленьких отрезков не больше $n \log n$ штук (для каждой левой границы существует $\le \log n$ маленьких отрезков), поэтому для них всех можно предпосчитать ответы заранее за $O(n \log n)$ и отвечать на запросы за $O(1)$, однако мы опять упираемся в проблему: либо в построении вылезает логарифм, либо при ответе на запрос. Мы же хотим избавиться от логарифмов полностью.&lt;/p&gt;
&lt;h2 id=&#34;rmqpm-1-online-маленьких-отрезков-становится-мало&#34;&gt;RMQ$\pm 1$ online. Маленьких отрезков становится мало.&lt;/h2&gt;
&lt;p&gt;Давайте для начала решим упрощенную версию задачи RMQ, после чего сведем общий случай к простому.&lt;/p&gt;
&lt;p&gt;Простая версия (RMQ$\pm 1$) отличается от обычной задачи RMQ тем, что в данном нам массиве соседние элементы обязательно отличаются друг от друга на $\pm 1$. Как же это нам поможет искать минимум на маленьких подотрезках?&lt;/p&gt;
&lt;p&gt;Давайте заметим, что позиция минимума на отрезке определяется только разностями соседних элементов и не зависит от самих значений этих элементов. К примеру, можно считать, что первый элемент отрезка равен нулю (как будто мы вычли из всех элементов на отрезке первый), и в таком массиве минимум будет стоять на той же самой позиции, что и в изначальном. Поменяется лишь его значение. Но если мы найдем позицию минимума, найти его значение не составит труда: нужно лишь обратиться к соответствующему индексу изначального массива.&lt;/p&gt;
&lt;p&gt;Теперь заметим, что если мы превратим все блоки в последовательности разностей соседних элементов, то эти последовательности будут состоять из чисел $1$ и $-1$, тогда если длина блока равна $k$, то существует всего $2^{k - 1}$ различных последовательностей разностей соседних элементов. После чего мы можем заранее предпосчитать для каждой такой последовательности минимум на каждом подотрезке. На это уйдет $O(2^{k - 1} \cdot k^2)$ времени. И затем просто для каждого блока в массиве определить, к какому типу он относится, и пользоваться предпосчитанными значениями позиций минимумов для всех маленьких подотрезков для ответа на запросы в будущем.&lt;/p&gt;
&lt;p&gt;Остается лишь выбрать число $k$ так, чтобы $2^{k - 1} \cdot k^2$ было не больше $n$, и при этом разреженная таблица на блоках длины $k$ строилась все еще за $O(n)$. Давайте возьмем $k = \frac{\log n}{2}$. В таком случае&lt;/p&gt;
&lt;p&gt;$$2^{k - 1} \cdot k^2 \le 2^k \cdot k^2 = 2^{\frac{\log n}{2}} \cdot \log^2 n = n^{\frac{1}{2}} \cdot \log^2 n = \sqrt{n} \log^2 n$$&lt;/p&gt;
&lt;p&gt;Это, безусловно, асимптотически меньше, чем $n$.&lt;/p&gt;
&lt;p&gt;С точки зрения реализации можно представлять любой блок длины $k - 1$ из $\pm 1$ как битовую маску длины $k - 1$ ($+1$ — единичный бит, $-1$ — нулевой бит), тогда после начального предпосчета можно будет для подотрезков изначального массива находить такую же маску и легко определять, к какому типу относится текущий блок. Предпосчет же будет просто храниться в трехмерном массиве размера $2^{k - 1} \times (k - 1) \times (k - 1)$. Кроме того, нам больше не надо хранить отдельно минимумы на префиксах и суффиксах блоков, потому что теперь у нас есть минимумы на вообще всех подотрезках внутри блоков. Также можно в предпосчете хранить все таки не позицию, а значение минимума на соответствующем подотрезке при условии, что первый элемент равен нулю, если вам нужно только значение минимума, а не его позицию. Тогда при ответе на запрос надо будет просто прибавить к ответу элемент на левой границе отрезка.&lt;/p&gt;
&lt;p&gt;Реализация доступна по &lt;a href=&#34;https://pastebin.com/jsu6Z6uR&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Наиболее эффективная реализация доступна по &lt;a href=&#34;https://pastebin.com/FMfejPSk&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;!---TODO: возможно, надо поменять местами размерности массива precalc---&gt;
&lt;h2 id=&#34;сведение-lca-к-rmqpm-1&#34;&gt;Сведение LCA к RMQ$\pm 1$.&lt;/h2&gt;
&lt;p&gt;RMQ$\pm 1$ — весьма специфичная задача, однако, вероятно, вы уже с ней встречались. Один из алгоритмов поиска LCA в дереве сводит LCA к RMQ при помощи выписывания эйлерова обхода дерева. После этого обычно используется разреженная таблица для поиска минимума на отрезке. Однако можно заметить, что в эйлеровом обходе соседние вершины соединены ребром, поэтому разность их глубин в точности равна $\pm 1$, так что на самом деле LCA сводится к задаче RMQ$\pm 1$, поэтому мы научились решать задачу LCA online за $O(n + q)$.&lt;/p&gt;
&lt;p&gt;Реализация доступна по &lt;a href=&#34;https://pastebin.com/v3Q5YZBV&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;!--- TODO: оптимальная по времени реализация ---&gt;
&lt;h2 id=&#34;сведение-rmq-к-lca&#34;&gt;Сведение RMQ к LCA.&lt;/h2&gt;
&lt;p&gt;А теперь наступает неожиданный поворот. Мы сведем общий случай задачи RMQ к задаче LCA. А задачу LCA мы уже умеем сводить к задаче RMQ$\pm 1$, которую мы умеем решать за $O(n + q)$. То есть такой странной последовательностью сведений мы научимся решать общий случай задачи RMQ за $O(n + q)$.&lt;/p&gt;
&lt;p&gt;Само сведение тоже может показаться весьма странным и удивительным. Пускай у нас есть массив $A$. Давайте построим декартово дерево, в котором ключами будут числа от $0$ до $n - 1$, а приоритетами будут элементы массива $A$ (в корне находится минимальный элемент). То есть построим декартово дерево на парах $(i, A_i)$. В общем случае построить декартово дерево за $O(n)$ невозможно, потому что это бы решало задачу сортировки массива за $O(n)$, но в нашем случае ключи — это числа от $0$ до $n - 1$, так что они уже отсортированы. В случае отсортированных ключей декартово дерево можно без труда построить за $O(n)$. Алгоритм мы обсудим позже.&lt;/p&gt;
&lt;p&gt;Теперь остается только заметить, что минимум на отрезке от $l$ до $r$ как раз таки соответствует LCA вершин с ключами $l$ и $r$ в нашем декартовом дереве. Действительно, LCA находится между левым и правым поддеревом по $x$ координате, значит, ключ LCA лежит между $l$ и $r$. С другой стороны, потенциал LCA является минимальным в его поддереве, а это поддерево содержит в себе весь подотрезок от $l$ до $r$, потому что оно содержит его границы. Так что это число лежит на нужном отрезке, а также является минимумом на нем. Что и требовалось доказать.&lt;/p&gt;
&lt;p&gt;Осталось только научиться строить декартово дерево за $O(n)$ при условии, что ключи отсортированы. Давайте последовательно добавлять элементы в дерево по возрастанию ключей. Новый ключ будет обязательно самой правой вершиной дерева. Осталось только понять, куда его подвесить, и как перестроить дерево. Давайте посмотрим на предыдущую вершину, которую мы добавили. Если потенциал новой вершины меньше или равен, чем потенциал предыдущей, то ее нужно просто подвесить к предыдущей вершине справа (так как у нее точно нет еще правого сына). Если же потенциал новой вершины меньше потенциала предыдущей вершины, нужно идти от нее наверх в сторону корня, пока мы не встретим первую вершину, у которой потенциал будет уже больше или равен потенциала новой вершины. Пускай мы добавляем в дерево вершину $v$, у вершины $u$ потенциал меньше, чем у $v$, а у отца $p$ вершины $u$ потенциал уже не меньше потенциала $v$. Тогда теперь правым сыном вершины $p$ будет являться вершина $v$, а вершину $u$ надо подвесить левым сыном вершины $v$, то есть вершина $v$ влезла внутрь ребра $p \to u$. Если же такой вершины $p$ не существует, то есть у всех вершин потенциал меньше, чем у $v$, то $v$ просто станет новым корнем, а старый корень мы подвесим к ней как левого сына.&lt;/p&gt;
&lt;p&gt;Весь этот процесс можно представлять как стек. Давайте хранить правую ветку декартова дерева в стеке. Этот стек очень похож на стек минимумов. Тогда когда пришла новая вершина, мы удаляем элементы из стека, пока их потенциалы меньше потенциала новой вершины, а потом добавляем новую вершину в стек, производя константное количество изменений в дереве. Так как каждая вершина добавится в стек (а значит, и удалится) ровно один раз, асимптотика алгоритма — $O(n)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Теперь если вы вернетесь к решению, использующему вариацию алгоритма Тарьяна, вы сможете увидеть, что тот стек, который мы использовали, как раз таки и является стеком построения декартова дерева. Однако из-за устройства алгоритма Тарьяна, мы можем явно не строить никакого дерева и получить более простой алгоритм.&lt;/p&gt;
&lt;p&gt;Реализация доступна по &lt;a href=&#34;https://pastebin.com/Q17qR0Ja&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Наиболее эффективная реализация доступна по &lt;a href=&#34;https://pastebin.com/T6H9x36M&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;упрощенная-битовая-вариация-алгоритма-фкб-для-практики&#34;&gt;Упрощенная битовая вариация алгоритма ФКБ для практики&lt;/h2&gt;
&lt;p&gt;Мы добились теоретической линейности решения RMQ, однако, этот алгоритм весьма сложен в реализации из-за трех разных фаз, а также константа в асимптотике достаточно большая, так что данный алгоритм редко можно применить на практике. При решении оффлайн версии задачи стоит посмотреть в сторону вариации алгоритма Тарьяна. Чаще всего ее будет достаточно.&lt;/p&gt;
&lt;p&gt;Однако если задачу все таки необходимо решать в онлайне, есть упрощенная версия алгоритма ФКБ без сведений к LCA и обратно к RMQ$\pm 1$. В остальном этот алгоритм похож на ФКБ. Мы все так же будем делить массив на блоки и строить разреженную таблицу на блоках. Остается научиться находить минимум на отрезках, лежащих внутри одного блока, альтернативным способом. Давайте добавим к нашему решению идею из offline решения. Пройдемся по массиву со стеком минимумов. Теперь нам остается решить две проблемы:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Нужно сделать этот стек в некотором смысле персистентным, то есть чтобы мы могли обращаться к стеку минимумов на тот момент, когда мы находились в конкретном элементе.&lt;/li&gt;
&lt;li&gt;Нужно уметь за $O(1)$ находить ближайший справа элемент стека минимумов к левой границе отрезка запроса.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Но тут нам на помощь приходит тот факт, что нам надо искать минимумы только на отрезках длины $\le \frac{\log n}{2}$. Это число не больше $32$ при $n \le 2^{64} \sim 10^{19}$. Безусловно, в реальной задаче $n$ не может быть настолько большим. Тогда давайте хранить стек минимумов в весьма необычном формате. Давайте сохраним массив длины $32$, в котором для каждого из последних $32$ индексов массива будем хранить, лежит ли он в стеке минимумов или нет. Так как длина этого массива равна $32$, можно не хранить массив, а сохранить это просто как битовую маску в одном числе типа &lt;code&gt;int&lt;/code&gt;. При переходе к следующей позиции нужно умножить эту маску на два, удалить те биты, которые пропали из стека минимумов, а также добавить новый элемент. Так что мы можем сохранить такой миниатюрный стек для каждой позиции массива, на это уйдет $O(n)$ времени и памяти.&lt;/p&gt;
&lt;p&gt;Теперь нам остается решить вторую проблему. Как за $O(1)$ по такой битовой маске находить минимум на отрезке длины $\le 32$? Это можно сделать при помощи битовых операций. Если длина отрезка равна &lt;code&gt;len&lt;/code&gt;, то применив к маске операцию побитового &amp;laquo;и&amp;raquo; с числом &lt;code&gt;(1 &amp;lt;&amp;lt; len) - 1&lt;/code&gt;, мы оставим только элементы стека  минимумов, лежащие на отрезке запроса, после чего нужно найти самый первый из них. Это совпадает со старшим битом получившейся маски. Для нахождения старшего бита числа можно либо изначально предпосчитать динамику (насчитаем для всех чисел от $1$ до $2^{16}$ старшие биты, после чего число длины $32$ разбивается на два числа длины $16$), либо воспользоваться встроенной в C++ функцией &lt;code&gt;__builtin_clz&lt;/code&gt; (Count Leading Zeros), которая возвращает за $O(1)$ (с достаточно быстрой константой) количество лидирующих нулей в числе. Тогда чтобы получить индекс старшего бита числа, нужно просто вычесть значение этой функции из числа $32$.&lt;/p&gt;
&lt;p&gt;Асимптотика получившегося алгоритма — это вроде бы $O((n + q) \left \lceil \frac{\log n}{32} \right\rceil)$, но в действительности это $O(n + q)$, ведь при анализе времени работы алгоритмов мы всегда подразумеваем, что $n \le 2^w$, где $w$ — длина машинного слова ($32$ или $64$), потому что если это не так, то мы не сможем хранить индексы входного массива как числа. Но если $n \le 2^w$, то $\frac{\log n}{w} \le 1$, поэтому данный алгоритм работает за $O(n + q)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Обратите внимание на то, что теперь длины блоков — $32$ вместо $\frac{\log n}{2}$, поэтому блоков стало меньше, и на построение разреженной таблицы уходит еще меньше времени. Кроме того, число $32$ является степенью двойки, поэтому деление на длину блока будет происходить быстрее.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Этот алгоритм можно оптимизировать по памяти. Нам необходимо хранить начальный массив длины $n$, массив миниатюрных стеков минимумов размера $n$, разреженную таблицу размера $\frac{n}{32} \log{\frac{n}{32}}$, а также обычный стек минимумов в процессе построения миниатюрных стеков. Изначальный массив и массив миниатюрных стеков нам необходимы, а вот от лишнего стека минимумов, использующегося в процессе построения, можно избавиться, ведь нам надо хранить лишь последние $32$ элемента. Это можно делать различными способами, но самый простой, пожалуй,~&amp;ndash; это заметить, что нам на самом деле достаточно лишь миниатюрного стека. Чтобы обратиться к вершине стека, нужно найти в маске самый младший бит. Это делается аналогично нахождению старшего бита при помощи функции &lt;code&gt;__builtin_ctz&lt;/code&gt; (Count Trailing Zeros).&lt;/p&gt;
&lt;p&gt;Реализация доступна по &lt;a href=&#34;https://pastebin.com/4wS8Zjj1&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Наиболее эффективная реализация доступна по &lt;a href=&#34;https://pastebin.com/gXs9yNKr&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Этот алгоритм примерно в 2 раза быстрее алгоритма ФКБ, а также, что самое главное, использует как минимум в $5$ раз меньше памяти (есть реализации алгоритма ФКБ, которые работают не сильно медленнее приведенного алгоритма и тратят не сильно больше памяти, однако их реализации еще сложнее, чем оригинальный ФКБ).&lt;/p&gt;
&lt;p&gt;Однако эффективная реализация дерева отрезков снизу (Смотрите &lt;a href=&#34;https://peltorator.ru/try_web/post/down_segment_tree&#34;&gt;здесь&lt;/a&gt;) хоть и использует $O(\log n)$ времени на запрос, но на практике работает за такое же время (на удивление даже если менять ограничения, разность во времени работы получается крайне маленькой), а также тратит немного меньше памяти (примерно на четверть). Кроме того, его еще легче реализовать, а также оно может работать не только со static версией задачи, но и с динамической (к примеру, можно делать присвоение в точке).&lt;/p&gt;
&lt;p&gt;Эффективная реализация дерева отрезков снизу доступна по &lt;a href=&#34;https://pastebin.com/n1NzdcLQ&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;!---% TODO: оптимальная по времени реализация---&gt;
&lt;h2 id=&#34;задачи-для-практики&#34;&gt;Задачи для практики&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://informatics.msk.ru/mod/statements/view.php?id=597&amp;amp;chapterid=752#1&#34;&gt;Задача&lt;/a&gt; на поиск максимума на отрезке.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Также можете прорешать специально подготовленный &lt;a href=&#34;https://codeforces.com/group/1rv4rhCsHp/contest/325878&#34;&gt;контест&lt;/a&gt; на codeforces на эту тему. Если у вас нет доступа к соревнованию, нужно сначала вступить в &lt;a href=&#34;https://codeforces.com/group/1rv4rhCsHp/contests&#34;&gt;группу&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Segment Tree Beats</title>
      <link>https://peltorator.ru/posts/segment_tree_beats/</link>
      <pubDate>Wed, 15 Sep 2021 16:03:38 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/segment_tree_beats/</guid>
      
      <description>&lt;p&gt;Segment Tree Beats (STB) — это структура данных (Хотя назвать это структурой данных можно весьма условно. Это скорее набор идей, которые наслаиваются на дерево отрезков.), которая была разработана Ruyi jiry_2 Ji в 2016 году. Это очень мощный инструмент, идея которого состоит в том, что мы ослабляем условия выхода из рекурсии в дереве отрезков, в результате чего кажется, что алгоритм начинает работать за $O(n^2)$, но при помощи амортизационного анализа можно доказать, что на самом деле время работы сильно меньше ($O(n \log n)$, $O(n \log^2 n)$ и т.д.). Также эта структура данных позволяет работать с &amp;laquo;исторической информацией&amp;raquo; массива. Частным случаем Segment Tree Beats является структура Ji Driver Segment Tree, которая позволяет поддерживать операции вида &amp;laquo;заменить все числа на отрезке массива $A$ на $\max(A_i, x)$&amp;raquo;, а также узнавать сумму на отрезке.&lt;/p&gt;
&lt;p&gt;На английском языке на эту тему есть по большому счету только &lt;a href=&#34;https://codeforces.com/blog/entry/57319&#34;&gt;одна статья&lt;/a&gt;. На русском же языке, насколько мне известно, материалов на эту тему нет в принципе. Статья, которую вы сейчас читаете, не только полностью покрывает англоязычный текст, но и затрагивает большое количество тем, которые в ней не упоминались, поэтому, пожалуй, является самым полным материалом про Segment Tree Beats не на китайском языке на данный момент. Я попытался собрать все возможные идеи, которые есть на эту тему, а также дополнить несколькими своими.&lt;/p&gt;
&lt;p&gt;На данный момент в русском языке нет какой-либо используемой альтернативы английскому названию, но если вы предпочитаете локализацию, то есть вариант &lt;a href=&#34;https://codeforces.com/blog/entry/90460?locale=ru#comment-789207&#34;&gt;&amp;laquo;Анимешное Дерево Отрезков&amp;raquo;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В этой статье мы часто будем говорить про асимптотику. Всегда подразумевается, что $n$ — это размер массива, а $q$ — суммарное количество запросов.&lt;/p&gt;
&lt;h2 id=&#34;общая-идея&#34;&gt;Общая идея&lt;/h2&gt;
&lt;p&gt;Давайте посмотрим, как выглядит стандартная функция изменения в дереве отрезков с массовым обновлением и проталкиванием:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// node is outside of the segment
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ql&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// node is inside the segment
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;updateNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;setPush&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// node intersects the segment
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;pushDown&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;pullUp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Пускай мы находимся в вершине &lt;code&gt;node&lt;/code&gt;, которая отвечает за полуинтервал $[l, r)$ массива, и нас попросили обновить значения массива на полуинтервале $[ql, qr)$ значением &lt;code&gt;newVal&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Первое условие (&lt;code&gt;breakCondition&lt;/code&gt;) проверяет, что если отрезок, за который отвечает вершина &lt;code&gt;node&lt;/code&gt;, не пересекается с отрезком, на котором мы делаем обновление, то в текущем поддереве ничего менять не надо, и можно просто вернуться назад.&lt;/p&gt;
&lt;p&gt;Второе условие (&lt;code&gt;tagCondition&lt;/code&gt;) проверяет, что если отрезок, за который отвечает вершина &lt;code&gt;node&lt;/code&gt;, лежит полностью внутри отрезка, который мы обновляем, то мы обновим значение прямо здесь, а также сохраним &lt;code&gt;push&lt;/code&gt;, который в будущем будем проталкивать в детей. После чего мы опять же завершаемся и возвращаемся назад.&lt;/p&gt;
&lt;p&gt;Если же ни первое, ни второе условие не выполнились, то это значит, что отрезки запроса и текущей вершины пересекаются, но при этом текущая вершина не лежит полностью внутри запроса. В таком случае мы рекурсивно запускаемся из детей, не забыв предварительно протолкнуть информацию о старых обновлениях, а после завершения работы в детях восстанавливаем значение в текущей вершине через значения детей.&lt;/p&gt;
&lt;p&gt;Этот код будет работать за $O(\log n)$, потому что на каждом уровне дерева отрезков не больше, чем две вершины могут пересекаться с отрезком запроса, но при этом не лежать в нем полностью, поэтому только из этих двух вершин мы рекурсивно запустимся на следующий уровень, а значит, на каждом уровне дерева мы посетим не более четырех вершин.&lt;/p&gt;
&lt;p&gt;Segment Tree Beats основан на следующей идее: пускай запросы изменения таковы, что мы не всегда можем пересчитать значение на отрезке при условии выполнения &lt;code&gt;tagCondition&lt;/code&gt;. Тогда давайте усилим условие &lt;code&gt;breakCondition&lt;/code&gt; и ослабим условие &lt;code&gt;tagCondition&lt;/code&gt;, чтобы теперь мы могли уже пересчитать значение в вершине, не запускаясь рекурсивно, но при этом асимптотика не стала квадратичной.&lt;/p&gt;
&lt;p&gt;То есть, теперь функция изменения будет выглядеть следующим образом:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// node is outside of the segment
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ql&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// node is inside the segment
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;updateNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;setPush&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// node intersects the segment
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;pushDown&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;pullUp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Иными словами, все, что нам нужно сделать — это придумать наиболее сильное условие &lt;code&gt;breakCondition&lt;/code&gt;, при котором в текущем поддереве запрос изменения точно ничего не изменит, а также наиболее сильное условие &lt;code&gt;tagCondition&lt;/code&gt;, при котором можно будет обновлять значение в текущей вершине, не запускаясь рекурсивно из детей.&lt;/p&gt;
&lt;p&gt;При этом заметьте, что &lt;code&gt;breakCondition&lt;/code&gt; и &lt;code&gt;tagCondition&lt;/code&gt; из обычного дерева отрезков никуда не деваются. Скорее всего, если отрезки запроса и текущей вершины не пересекаются, то в этой вершине точно ничего не надо менять. С другой стороны, если текущая вершина не лежит полностью внутри отрезка запроса, то вряд ли можно пересчитать значение в ней, не запустившись рекурсивно в детей, так что эти условия будут выглядеть примерно следующим образом:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;breakCondition = qr &amp;lt;= l || r &amp;lt;= ql || ???&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tagCondition = ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr &amp;amp;&amp;amp; ???&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;В этой статье мы будем пытаться придумать, чем нужно заменить каждый из &lt;code&gt;???&lt;/code&gt; в разных задачах.&lt;/p&gt;
&lt;p&gt;Задачи в основном будут описываться запросами, которые в них нужно выполнять. К примеру, запрос &lt;code&gt;+=&lt;/code&gt; означает, что необходимо уметь прибавлять какое-то значение на отрезке. Запрос &lt;code&gt;=&lt;/code&gt; означает, что необходимо уметь присваивать какое-то значение на отрезке. Эти запросы являются весьма стандартными для дерева отрезков. Однако кроме них будут рассмотрены и более сложные: &lt;code&gt;max=&lt;/code&gt;, &lt;code&gt;min=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt; и так далее. Они означают, что в результате запроса нужно заменить все элементы на отрезке на результат выполнения соответствующей функции от текущего значения и &lt;code&gt;newVal&lt;/code&gt;. К примеру, операция &lt;code&gt;max=&lt;/code&gt; заменят все элементы на отрезке массива $A$ по правилу $A_i \to \max(A_i, newVal)$.&lt;/p&gt;
&lt;p&gt;Кроме того, не менее важно, какие операции типа &lt;code&gt;get&lt;/code&gt; есть в задаче. К примеру, мы будем рассматривать следующие операции: $\sum$ — сумма на отрезке, $\max$ — максимум на отрезке, $\min$ — минимум на отрезке, $gcd$ — НОД на отрезке и т.д.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt; &lt;br&gt;
Обратите внимание, что запрос типа &lt;code&gt;get&lt;/code&gt;, то есть запрос получения какой-либо функции на отрезке, не меняется, потому что мы все еще поддерживаем корректную информацию о подотрезке вершины, когда мы в нее спустились от корня.&lt;/p&gt;
&lt;h2 id=&#34;--в-точке-sum&#34;&gt;&lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt; в точке, $\sum$&lt;/h2&gt;
&lt;h3 id=&#34;формулировка&#34;&gt;Формулировка&lt;/h3&gt;
&lt;p&gt;В этой задаче у нас есть массив неотрицательных целых чисел $A$ ($0 \le A_i &amp;lt; C$), а также имеются запросы трех типов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Даны $ql, qr, x$ ($1 \le x &amp;lt; C$). Нужно заменить все элементы массива $a$ на полуинтервале $[ql, qr)$ на $A_i \bmod x$.&lt;/li&gt;
&lt;li&gt;Даны $qi, y$ ($0 \le y &amp;lt; C$). Нужно заменить элемент массива $A$ на позиции $qi$ на $y$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть сумму элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Эту задачу можно найти &lt;a href=&#34;https://codeforces.com/contest/438/problem/D&#34;&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Также можно без проблем поддерживать и другие &lt;code&gt;get&lt;/code&gt;-запросы, такие как $\max$ или $\min$.&lt;/p&gt;
&lt;h3 id=&#34;решение&#34;&gt;Решение&lt;/h3&gt;
&lt;p&gt;Вторую и третью операции мы будем выполнять как обычно. Осталось понять, в какой момент мы можем остановиться в первом запросе, чтобы обновить значение в текущей вершине, а также в будущем иметь возможность эффективно проталкивать это изменение в детей.&lt;/p&gt;
&lt;p&gt;Давайте подумаем, каким должно быть &lt;code&gt;breakCondition&lt;/code&gt;? При каком условии ни одно число в данном поддереве не поменяется? В том случае, если все числа на подотрезке текущей вершины меньше, чем $x$. Иными словами, если максимум на этом отрезке меньше $x$. Поэтому &lt;code&gt;breakCondition&lt;/code&gt; в данном случае будет выглядеть следующим образом: &lt;code&gt;qr &amp;lt;= l || r &amp;lt;= ql || maxValue[node] &amp;lt; x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Теперь надо придумать такое условие &lt;code&gt;tagCondition&lt;/code&gt;, при котором нам не придется идти в детей. Здесь уже может быть несколько вариантов. К примеру, если целые части от деления всех чисел на отрезке на $x$ совпадают. Однако нам хватит более простого условия: если все числа на отрезке равны, то есть, иными словами, максимум на отрезке равен минимуму. В этом случае все числа на отрезке равны &lt;code&gt;maxValue[node]&lt;/code&gt;, поэтому операция &lt;code&gt;%=&lt;/code&gt; на этом отрезке — это то же самое, что присвоить на этом отрезке всем элементам &lt;code&gt;maxValue[node]&lt;/code&gt;$\bmod x$. Это мы можем сделать так же, как и с запросом второго типа, не заходя в детей.&lt;/p&gt;
&lt;h3 id=&#34;доказательство&#34;&gt;Доказательство&lt;/h3&gt;
&lt;p&gt;Осталось понять, почему при таком ослаблении &lt;code&gt;tagCondition&lt;/code&gt; асимптотика остается приемлимой. На самом деле асимптотика этого решения — $O((n + q) \log n \log C)$.&lt;/p&gt;
&lt;p&gt;Введем потенциал вершины дерева отрезков $\varphi(node)$, равный $\sum_{l \le i &amp;lt; r} \log (A_i + 1)$, где $l, r$ — границы полуинтервала исходного массива, за который отвечает данная вершина. Прибавление единицы, конечно, ни на что особо влиять не будет, но оно необходимо, потому что $A_i$ могут быть равны нулю.
Теперь введем потенциал $\Phi$, который будет равен сумме потенциалов всех вершин дерева. В любой момент времени потенциал можно оценить следующим образом: $0 \le \Phi \le O(n \log n \log C)$, потому что каждый элемент массива лежит в поддереве у $\log n$ вершин дерева отрезков и дает вклад $O(\log C)$.&lt;/p&gt;
&lt;p&gt;И пускай суммарно за все время этот потенциал увеличился на $\Phi_+$. Давайте разобьем вершины, которые посетит запрос изменения на три вида:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;обычные&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;дополнительные&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;тупиковые&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Обычные вершины — это те вершины, которые посетило бы стандартное дерево отрезков, тупиковые вершины — это те необычные вершины, в которых выполнилось одно из условий &lt;code&gt;breakCondition&lt;/code&gt; или &lt;code&gt;tagCondition&lt;/code&gt;, а дополнительные вершины — это все остальные вершины, которые посетил запрос, то есть те не обычные вершины, из которых мы вызвались рекурсивно.
Тогда заметим, что некоторые верхние вершины дерева будут обычными, потом под обычными будет какое-то количество дополнительных, и из дополнительных иногда будут торчать тупиковые. Из тупиковых уже рекурсивных вызовов нет.
При этом заметим, что отец любой тупиковой вершины — это либо обычная вершина, либо дополнительная. Кроме того, у каждой вершины максимум $2$ сына, так что тупиковых вершин максимум в два раза больше, чем обычных и дополнительных, поэтому их посещение не влияет на асимптотику, и можно следить только за дополнительными вершинами. Это можно было понять немного иначе: если мы делаем рекурсивный вызов и сразу завершаемся, то в каком-то смысле можно считать, что этот рекурсивный вызов не был сделан вовсе.&lt;/p&gt;
&lt;p&gt;Теперь, когда мы оставили только обычные и дополнительные вершины, докажем, что при посещении дополнительной вершины потенциал в этой вершине (а следовательно и суммарный потенциал $\Phi$) уменьшается хотя бы на $1$, тогда суммарное количество посещенных дополнительных вершин можно оценить как $O(n \log n \log C) + \Phi_+$, а обычных вершин мы на каждом запросе посещаем $O(\log n)$ штук. При этом в каждой вершине дерева мы делаем константное количество операций, так что асимптотика алгоритма будет равна $O(n \log n \log C + \Phi_+ + q \log n)$. Остается только показать, что $\Phi_+ \le O(q \log n \log C)$, а также то, что потенциал уменьшается при посещении дополнительной вершины.&lt;/p&gt;
&lt;p&gt;Данное рассуждение может показаться сложным и запутанным, но на самом деле в будущем все рассуждения об амортизированном времени работы будут очень похожи на это. Мы вводим какой-то потенциал. Понимаем, что он всегда находится в пределах от $0$ до $\max\Phi$, смотрим, на сколько он может увеличиваться, а также, на сколько он уменьшается при посещении дополнительных вершин. Из этого делается вывод о времени работы алгоритма.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Это не совсем обычный способ измерения амортизированного времени работы. Обычно вводят $a_i = t_i - \Delta \Phi_i$, после чего получается, что время работы можно оценить как $\Delta \Phi + \sum a_i$. Однако в данном контексте такие рассуждения, пожалуй, менее удобны для понимания. Мы воспринимаем потенциал как кучку камней, которая может иметь ограниченный размер, за все время в нее положат какое-то конкретное ограниченное количество камней, а за каждую необычную операцию мы будем забирать из этой кучки камень.&lt;/p&gt;
&lt;p&gt;Итак, давайте поймем, чему равен $\Phi_+$. Операция первого типа может только уменьшать числа в массиве, а операция третьего типа вовсе не меняет элементов массива. Поэтому увеличения потенциала могут происходить только во время операций второго типа. Мы изменили один элемент массива. Он был $\ge 0$, а стал $&amp;lt; C$, поэтому потенциал мог увеличиться максимум на $\log ((C - 1) + 1) - \log(0 + 1) = \log C$ для каждой вершины, в поддереве которой есть этот элемент, а таких вершин $O(\log n)$. Всего запросов было $q$, поэтому суммарно потенциал увеличится максимум на $O(q \log n \log C)$. Что и требовалась показать.&lt;/p&gt;
&lt;p&gt;Теперь покажем, почему при посещении дополнительной вершины ее потенциал уменьшается как минимум на $1$. Если мы посещаем дополнительную вершину, это значит, что ко всем элементам на ее подотрезке нужно применить операцию &lt;code&gt;%=&lt;/code&gt;, и при этом на этом отрезке есть хотя бы одно число, которое не меньше $x$. Воспользуемся следующим известным фактом:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема:&lt;/strong&gt;
Если $k \ge x$, то $k \bmod x \le \frac{k - 1}{2}$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
Во-первых, заметим, что условие $l \le \frac{k - 1}{2}$ для целых $l$ и $k$ равносильно тому, что $l &amp;lt; \frac{k}{2}$.&lt;/p&gt;
&lt;p&gt;Во-вторых, разберем два случая:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$k \ge 2 x$. В этом случае $k \bmod x &amp;lt; x \le \frac{k}{2}$. Первое равенство верно просто потому, что остаток от деления всегда меньше модуля, а второе верно из-за того, что $k \ge 2 x$.&lt;/li&gt;
&lt;li&gt;$k &amp;lt; 2x$. В этом случае $k \bmod x = k - x &amp;lt; \frac{k}{2}$ в силу того, что $k &amp;lt; 2x$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;То есть, если мы посетили дополнительную вершину, то какое-то число на этом отрезке уменьшится больше, чем в два раза. Тогда раньше это число давало вклад $\log (k + 1)$ в потенциал, а теперь $\le \log ( \frac{k - 1}{2} + 1) = \log (\frac{k + 1}{2}) = \log (k + 1) - 1$. Таким образом, мы доказали, что потенциал этой вершины уменьшился хотя бы на один. Что и требовалось.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
В одной из последующих секций мы докажем, что абсолютно такое же решение будет работать за такую же асимптотику даже если присвоение происходит на отрезке.&lt;/p&gt;
&lt;h2 id=&#34;min-sum-max-ji-driver-segment-tree&#34;&gt;&lt;code&gt;min=&lt;/code&gt;, $\sum$, $\max$ (Ji Driver Segment Tree)&lt;/h2&gt;
&lt;h3 id=&#34;формулировка-1&#34;&gt;Формулировка&lt;/h3&gt;
&lt;p&gt;В этой задаче у нас есть массив неотрицательных целых чисел $A$, а также имеются запросы трех типов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Даны $ql, qr, x$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\min(A_i, x)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть сумму элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть максимум в массиве $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Эта задача доступна &lt;a href=&#34;https://vjudge.net/problem/HDU-5306&#34;&gt;здесь&lt;/a&gt; или &lt;a href=&#34;http://acm.hdu.edu.cn/showproblem.php?pid=5306&#34;&gt;здесь&lt;/a&gt;. Это китайские сайты, поэтому там не так просто зарегистрироваться.&lt;/p&gt;
&lt;p&gt;Также есть усложненная версия этой задачи &lt;a href=&#34;https://codeforces.com/problemset/problem/855/F&#34;&gt;&amp;laquo;Нагайна&amp;raquo;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;решение-1&#34;&gt;Решение&lt;/h3&gt;
&lt;p&gt;Это самая стандартная задача на Segment Tree Beats. Собственно, статья на английском появилась после того, как участники из Китая массово решали задачу &amp;laquo;Нагайна&amp;raquo; при помощи Ji Driver Segment Tree, хотя изначально эта задача была на корневую декомпозицию.&lt;/p&gt;
&lt;p&gt;В этой задаче мы будем хранить в каждой вершине следующие значения: &lt;code&gt;sum&lt;/code&gt; — сумма на отрезке; &lt;code&gt;max&lt;/code&gt; — максимум на отрезке; &lt;code&gt;cntMax&lt;/code&gt; — количество элементов на этом отрезке, которые равны максимуму; &lt;code&gt;secondMax&lt;/code&gt; — наибольший элемент на отрезке, который строго меньше, чем &lt;code&gt;max&lt;/code&gt;. Обратите внимание на то, что это строгий второй максимум, то есть если на отрезке есть числа $0, 1, 2, 3, 3$, то &lt;code&gt;secondMax&lt;/code&gt; $ = 2$.&lt;/p&gt;
&lt;p&gt;Каким должно быть &lt;code&gt;breakCondition&lt;/code&gt;? В каком случае операция &lt;code&gt;min=&lt;/code&gt; не поменяет ничего на текущем отрезке? В том случае, если все элементы на этом отрезке уже не больше, чем $x$, и ничего менять не надо. То есть, другими словами, если максимум не больше $x$:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;breakCondition = qr &amp;lt;= l || r &amp;lt;= ql || max &amp;lt;= x&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;А каким же должно быть &lt;code&gt;tagCondition&lt;/code&gt;? В каком случае мы можем быстро обновить значения в текущей вершине? В том случае, если меняются только максимумы, то есть &lt;code&gt;secondMax &amp;lt; x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tagCondition = ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr &amp;amp;&amp;amp; secondMax &amp;lt; x&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;В таком случае мы знаем, что &lt;code&gt;cntMax&lt;/code&gt; максимумов заменятся на &lt;code&gt;x&lt;/code&gt;, и в этом случае легко можно пересчитать все значения в вершине, и вниз мы будем проталкивать как раз эту информацию: с каким числом нужно произвести операцию &lt;code&gt;min=&lt;/code&gt;. Если нужно протолкнуть две операции &lt;code&gt;min=&lt;/code&gt;, то достаточно проталкивать всего одну такую операцию с меньшим из параметров.&lt;/p&gt;
&lt;p&gt;На самом деле можно заметить, что проталкиваемое значение можно не хранить вовсе, потому что оно всегда совпадает с &lt;code&gt;max&lt;/code&gt; в этой вершине (либо проталкивать ничего не надо, но если мы протолкнем максимум, ничего не изменится). То есть мы в каком-то смысле проталкиваем в детей наш максимум на отрезке. Так писать код становится сильно приятнее.&lt;/p&gt;
&lt;h3 id=&#34;доказательство-1&#34;&gt;Доказательство&lt;/h3&gt;
&lt;p&gt;Докажем, что это решение работает за $O((n + q) \log n)$.&lt;/p&gt;
&lt;p&gt;Опять же воспользуемся методом потенциалов. Определим потенциал вершины $\varphi(node)$ как количество различных чисел на отрезке, за который отвечает эта вершина. Общий потенциал $\Phi$ определяется опять же как сумма потенциалов по всем вершинам дерева.&lt;/p&gt;
&lt;p&gt;Количество различных чисел на отрезке не больше, чем длина этого отрезка, так что сумма потенциалов на одном уровне дерева отрезков не больше $n$. Таким образом, в любой момент времени потенциал ограничен следующим образом: $0 \le \Phi \le O(n \log n)$.&lt;/p&gt;
&lt;p&gt;Чему равно $\Phi_+$? Во время &lt;code&gt;get&lt;/code&gt;-запросов элементы массива не меняются, поэтому в них потенциал не увеличивается. В запросах первого типа потенциал может измениться только для обычных и дополнительных вершин, потому что для непосещенных вершин значения на отрезке не поменяются, а для тупиковых никакие значения не склеятся. При этом для дополнительных вершин количество различных чисел только уменьшается за счет того, что числа склеиваются, но увеличиться точно не может. Поэтому потенциал увеличивается только для обычных вершин, при этом единственное новое значение, которое может появиться, — это &lt;code&gt;x&lt;/code&gt;, потому что каждое число либо не меняется, либо заменяется на &lt;code&gt;x&lt;/code&gt;. Таким образом, потенциал мог увеличиться только у $O(\log n)$ обычных вершин, и для каждой такой вершины он увеличился максимум на $1$. Поэтому за все время $\Phi_+ \le O(q \log n)$.&lt;/p&gt;
&lt;p&gt;Теперь поймем, что посещение дополнительных вершин уменьшает потенциал этой вершины хотя бы на $1$. Это следует из того, что для дополнительных вершин $x \le $ &lt;code&gt;secondMax&lt;/code&gt;, поэтому после выполнения этого запроса и &lt;code&gt;max&lt;/code&gt;, и &lt;code&gt;secondMax&lt;/code&gt; заменятся на $x$, то есть два максимума как бы склеятся между собой, так что количество различных чисел в этой вершине точно уменьшится хотя бы на $1$.&lt;/p&gt;
&lt;p&gt;Таким образом, асимптотика алгоритма получается равной $O(n \log n + q \log n + q \log n) = O((n + q) \log n)$ (первое слагаемое от глобального изменения потенциала от начала до конца, второе слагаемое от $\Phi_+$, а третье слагаемое от посещения обычных вершин). Что и требовалось доказать.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
По аналогии с этой задачей можно поддерживать также операцию &lt;code&gt;max=&lt;/code&gt; и даже их совмещение. Достаточно хранить 2 максимума, 2 минимума и их количества. Оценка времени работы от этого не изменится.&lt;/p&gt;
&lt;p&gt;Кроме того, можно добавить операцию присвоения на отрезке, потому что она так же, как и &lt;code&gt;min=&lt;/code&gt; не сильно увеличивает потенциал.&lt;/p&gt;
&lt;h2 id=&#34;min-max---sum-max-min&#34;&gt;&lt;code&gt;min=&lt;/code&gt;, &lt;code&gt;max=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, $\sum$, $\max$, $\min$&lt;/h2&gt;
&lt;h3 id=&#34;формулировка-2&#34;&gt;Формулировка&lt;/h3&gt;
&lt;p&gt;В этой задаче у нас есть массив неотрицательных целых чисел $A$, а также имеются запросы шести типов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Даны $ql, qr, x$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\min(A_i, x)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr, y$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\max(A_i, y)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr, z$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $z$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr, t$. Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $t$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть сумму элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть максимум элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть минимум элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;/ol&gt;
&lt;!--- TODO: find this problem on some judge ---&gt;
&lt;h3 id=&#34;решение-2&#34;&gt;Решение&lt;/h3&gt;
&lt;p&gt;Решение никак не меняется. Оно такое же, как и раньше (только надо добавить стандартную операцию &lt;code&gt;+=&lt;/code&gt;), однако теперь старое доказательство перестает работать. Нам надо будет придумать новое.&lt;/p&gt;
&lt;h3 id=&#34;доказательство-2&#34;&gt;Доказательство&lt;/h3&gt;
&lt;p&gt;Почему же старое доказательство не работает?&lt;/p&gt;
&lt;p&gt;По факту, новая операция здесь всего одна: &lt;code&gt;+=&lt;/code&gt;, потому что по замечанию выше остальные запросы просто встраиваются в Ji Driver Segment Tree. Однако с операцией &lt;code&gt;+=&lt;/code&gt; потенциал из прошлой задачи не пройдет. Давайте посмотрим на пример массива:&lt;/p&gt;
&lt;p&gt;$$1, 2, 3, 4, \ldots, \frac{n}{2} - 1, \frac{n}{2}, 1, 2, 3, 4, \ldots, \frac{n}{2} - 1, \frac{n}{2}$$&lt;/p&gt;
&lt;p&gt;Корень дерева отвечает за весь массив, поэтому его потенциал равен $\frac{n}{2}$. Однако если мы прибавим $\frac{n}{2}$ ко второй половине массива, то массив станет выглядеть так:&lt;/p&gt;
&lt;p&gt;$$1, 2, 3, 4, \ldots, n - 1, n$$&lt;/p&gt;
&lt;p&gt;И в этом случае потенциал корня стал равен $n$, а потенциалы других вершин не изменились. То есть, мы за одну операцию увеличили потенциал на $\frac{n}{2}$. Это слишком много. Нам нужен другой потенциал.&lt;/p&gt;
&lt;p&gt;Доказывать мы, однако, будем уже не $O((n + q) \log n)$, а $O(n \log n + q \log^2 n)$. Кроме того, вроде бы теста, на котором это работало бы за $\log^2 n$ на запрос неизвестно, так что, возможно, это настоящий $\log n$, но этим мы, конечно, пользоваться не будем.&lt;/p&gt;
&lt;p&gt;В этот раз потенциалом дерева $\Phi_1$ будет количество его вершин, для которых максимумы в левом и правом поддеревьях не совпадают. Скажем, что такие вершины являются помеченными. Аналогично, $\Phi_2$ — это количество вершин, для которых минимумы в левом и правом поддеревьях не совпадают.
Тогда очевидно, что в любой момент времени $0 \le \Phi_1, \Phi_2 \le O(n)$. В каких случаях потенциал $\Phi_1$ мог увеличиваться? Если для какой-то вершины раньше максимумы в детях совпадали, а потом стали различаться. Это могло произойти только в том случае, если к максимуму в одном поддереве применили операцию, а к другому — нет. То есть текущая вершина пересекается с запросом, но не лежит в нем полностью. Это обязательно обычная вершина, таких вершин $O(\log n)$ штук, так что за один запрос $\Phi_1$ могло увеличиться максимум на $O(\log n)$. Аналогично для $\Phi_2$.
Так что $\Phi_{1_+}, \Phi_{2_+} \le O(q \log n)$.&lt;/p&gt;
&lt;p&gt;Теперь поймем, как уменьшаются потенциалы при операциях &lt;code&gt;min=&lt;/code&gt; и &lt;code&gt;max=&lt;/code&gt;. Докажем, что если мы посетили $m$ дополнительных вершин в операции &lt;code&gt;min=&lt;/code&gt;, то $\Phi_1$ уменьшится хотя бы на $\frac{m}{\log n}$ (иными словами, если потенциал уменьшится на $k$, то мы посетим не больше $k \log n$ дополнительных вершин). Аналогично, для операции &lt;code&gt;max=&lt;/code&gt;, уменьшаться будет $\Phi_2$. Тогда итоговая асимптотика будет равна $O(n \log n + q \log^2 n)$.&lt;/p&gt;
&lt;p&gt;Почему потенциал $\Phi_1$ будет уменьшаться? Давайте докажем следующее утверждение:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема:&lt;/strong&gt;
В поддереве любой дополнительной вершины $v$ есть помеченная вершина $u$, которая после применения операции перестанет быть помеченной.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
Если вершина $v$ дополнительная, то для этой вершины &lt;code&gt;max[v]&lt;/code&gt; $&amp;gt; x$ и &lt;code&gt;secondMax[v]&lt;/code&gt; $\ge x$, потому что не выполнились &lt;code&gt;breakCondition&lt;/code&gt; и &lt;code&gt;tagCondition&lt;/code&gt;. Тогда докажем, что в поддереве вершины $v$ есть такая вершина $u$, что для нее максимум в одном из детей равен &lt;code&gt;max[v]&lt;/code&gt;, а в другом &lt;code&gt;secondMax[v]&lt;/code&gt;. И тогда сейчас эти числа различаются, а после применения операции оба будут равны $x$, поэтому из вершины $u$ пропадет пометка.&lt;/p&gt;
&lt;p&gt;Почему же такая вершина $u$ существует? Посмотрим на самую глубокую вершину $t$ в поддереве $v$, для которой &lt;code&gt;max[t] = max[v]&lt;/code&gt; и &lt;code&gt;secondMax[t] = secondMax[v]&lt;/code&gt;. Такая вершина точно есть, потому что как минимум подходит сама вершина $v$. Для вершины $t$ это условие выполнено, а для ее детей — нет, потому что вершина $t$ — это самая глубокая такая вершина. Тогда заметим, что вершина $t$ как раз таки подходит на роль вершины $u$. Если максимум в поддереве $t$ равен &lt;code&gt;max[v]&lt;/code&gt;, то и у одного из сыновей максимум равен тому же самому числу. При этом второй максимум в этом сыне не равен &lt;code&gt;secondMax[v]&lt;/code&gt;, так как тогда этот сын был бы более глубокой подходящей вершиной. То есть в этом сыне нет значений, равных &lt;code&gt;secondMax[v]&lt;/code&gt;. Тогда все эти значения находятся в другом сыне. При этом в другом сыне не может быть значений, равных &lt;code&gt;max[v]&lt;/code&gt;, потому что тогда этот другой сын был бы более глубокой вершиной, чем $t$, которая нам подходит. Так что максимум в другом сыне — это &lt;code&gt;secondMax[v]&lt;/code&gt;. Поэтому как раз таки вершина $t$ подходит на роль вершины $u$, и в ней была метка, а после применения операции эта метка пропадет.&lt;/p&gt;
&lt;p&gt;Пускай после применения операции пропало $k$ меток. Тогда все посещенные дополнительные вершины — это предки этих $k$ вершин, потому что по теореме у любой дополнительной вершины есть потомок, в котором пропала метка. У каждой из этих $k$ вершин есть $\log n$ предков, так что суммарно у них не более $k \log n$ предков, значит, мы посетим не больше, чем столько вершин. Что и требовалось доказать.&lt;/p&gt;
&lt;h2 id=&#34;min--gcd&#34;&gt;&lt;code&gt;min=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, $gcd$&lt;/h2&gt;
&lt;h3 id=&#34;формулировка-3&#34;&gt;Формулировка&lt;/h3&gt;
&lt;p&gt;В этой задаче у нас есть массив неотрицательных целых чисел $A$ ($0 \le A_i &amp;lt; C$), а также имеются запросы трех типов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Даны $ql, qr, x$ ($0 \le x$). Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\min(A_i, x)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr, y$ ($0 \le y &amp;lt; C$). Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $x$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть наибольший общий делитель ($gcd$, НОД) элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;решение--доказательство-упрощенной-версии-задачи&#34;&gt;Решение + доказательство упрощенной версии задачи&lt;/h3&gt;
&lt;p&gt;Давайте сначала поймем, как решать эту задачу, если запросов первого типа нет. В отличие от других задач, это уже не так очевидно. Если ко всем числам на отрезке прибавили $x$, то не совсем понятно, как изменился НОД чисел на этом отрезке.&lt;/p&gt;
&lt;p&gt;Как известно, $gcd(a, b) = gcd(a - b, b)$ (это факт, на котором основан алгоритм Евклида). То есть мы можем заменить одно из чисел на их разность. Но давайте вместо того, чтобы заменять, просто его добавим. Хуже не будет:&lt;/p&gt;
&lt;p&gt;$$gcd(a, b) = gcd(a, b, a - b)$$&lt;/p&gt;
&lt;p&gt;Этот факт можно обобщить для большего количества членов:&lt;/p&gt;
&lt;p&gt;$$gcd(a, b, c) = gcd(a, b, c, a - b, b - c, c - a)$$&lt;/p&gt;
&lt;p&gt;И так далее. То есть НОД чисел $a_1, a_2, \ldots, a_k$ равен НОДу этих чисел и всех их возможных $\frac{k \cdot (k - 1)}{2}$ попарных разностей.&lt;/p&gt;
&lt;p&gt;С другой стороны, давайте заметим, что из этих членов можно оставить только несколько. Нужно оставить всего  $k$ из них так, чтобы их линейными комбинациями можно было получить $a_1, a_2, \ldots, a_k$. И если эти числа можно получить линейными комбинациями, то НОД такого подмножества будет равен $gcd(a_1, a_2, \ldots, a_k)$.&lt;/p&gt;
&lt;p&gt;Давайте представим все числа в виде графа. Ребро между двумя вершинами будет соответствовать их разности. Тогда на самом деле нам достаточно взять какое-то остовное дерево этого графа, а также одно любое из чисел $a_1, a_2, \ldots, a_k$. Почему? Пускай мы взяли число $a_i$, а также какое-то остовное дерево. Как получить линейную комбинацию, равную $a_j$?
Так как мы взяли остовное дерево, то между $a_i$ и $a_j$ в этом дереве есть путь (все, что нам надо от дерева — это связность) $b_1, b_2, \ldots, b_l$, где $b_1 = a_i$ и $b_l = a_j$. Тогда в нашем множестве есть числа $b_1 = a_i$, $b_2 - b_1$, $b_3 - b_2$, $\ldots$, $b_l - b_{l - 1}$. Их сумма как раз равна $b_l = a_j$. Что и требовалось доказать. Кроме того, если бы в нашем множестве не было числа $a_i$, а были бы только разности из какого-то остовного дерева, то исходные числа мы бы получить не смогли таким образом, но разность любых двух — без проблем. Нужно опять же просуммировать все разности на каком-то пути.&lt;/p&gt;
&lt;p&gt;Для чего мы это доказывали? Давайте хранить на отрезке отдельно какое-то любое число с этого отрезка (&lt;code&gt;anyValue&lt;/code&gt;), а также НОД всех попарных разностей (&lt;code&gt;diffGCD&lt;/code&gt;), который, как мы уже выяснили, равен НОДу какого-то остовного дерева. И тогда НОД на отрезке будет вычисляться просто как $gcd($&lt;code&gt;anyValue&lt;/code&gt;$,$&lt;code&gt;diffGCD&lt;/code&gt;$)$. Однако заметим, что если мы поддерживаем такие значения в вершине, то прибавление числа — это уже не проблема. Если ко всем числам на отрезке прибавили константу $y$, то их попарные разности не поменялись, а значит, не поменялось и &lt;code&gt;diffGCD&lt;/code&gt;. А к &lt;code&gt;anyValue&lt;/code&gt;, так же, как и ко всем остальным значениям на отрезке, просто прибавится эта самая константа $y$.&lt;/p&gt;
&lt;p&gt;Осталось только понять, как пересчитывать значения &lt;code&gt;anyValue&lt;/code&gt; и &lt;code&gt;diffGCD&lt;/code&gt; в вершине через значения в детях.
&lt;code&gt;anyValue&lt;/code&gt; пересчитать очень легко. Можно просто взять любое из &lt;code&gt;anyValue&lt;/code&gt; для левого и правого поддеревьев.
А как пересчитать &lt;code&gt;diffGCD&lt;/code&gt;? В &lt;code&gt;diffGCD&lt;/code&gt; левого поддерева хранится НОД какого-то остовного дерева левого подотрезка, а в &lt;code&gt;diffGCD&lt;/code&gt; правого поддерева хранится НОД какого-то остовного дерева правого подотрезка. Поэтому все, что нам нужно, — это соединить эти два остовных дерева, то есть добавить какое-то ребро. Но у нас как раз хранятся &lt;code&gt;anyValue&lt;/code&gt; для обоих поддеревьев. Возьмем их разность.
То есть&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;diffGCD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gcd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;diffGCD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;leftChild&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;diffGCD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rightChild&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
                 &lt;span class=&#34;n&#34;&gt;anyValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;leftChild&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;anyValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rightChild&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;И тогда такое решение работает за $O(n \log C + q (\log n +  \log C))$. Во втором слагаемом логарифмы складываются, а не перемножаются по той же причине, по которой так происходит в дереве отрезков с поиском $gcd$ на отрезке и присваиванием на отрезке. Потому что последовательное вычисление НОД у $k$ чисел, не больших $C$ по модулю, работает за $O(k + \log C)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Упражнение:&lt;/strong&gt;
Докажите, что последовательное вычисление НОД $k$ чисел, не больших $C$ по модулю, работает за $O(k + \log C)$.&lt;/p&gt;
&lt;h3 id=&#34;решение--доказательство-полной-версии-задачи&#34;&gt;Решение + доказательство полной версии задачи&lt;/h3&gt;
&lt;p&gt;Итак, мы научились поддерживать операции &lt;code&gt;+=&lt;/code&gt; и $gcd$ на отрезке. Давайте добавим к этому еще &lt;code&gt;min=&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Давайте немного изменим концепцию. Будем поддерживать на отрезке не НОД всех попарных разностей, а НОД всех попарных разностей чисел, не равных максимуму на отрезке. А максимумы (как и в Ji Driver Segment Tree) мы будем обрабатывать отдельно. Тогда при условии &lt;code&gt;tagCondition&lt;/code&gt; (которое, как и &lt;code&gt;breakCondition&lt;/code&gt;, абсолютно такое же, как и в Ji Driver Segment Tree) мы сможем легко пересчитать значения. Нам нужно будет изменить только максимум, а &lt;code&gt;diffGCD&lt;/code&gt; никак не поменяется, потому что мы изменяем значения только максимумов, а они не входят в &lt;code&gt;diffGCD&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Как же нам тогда находить НОД на отрезке, зная эти значения? Все числа, не равные максимуму, уже объединены в остовное дерево внутри &lt;code&gt;diffGCD&lt;/code&gt;. Остается только присоединить максимумы (или один из них, потому что они все равно равны друг другу). В этом нам как раз может помочь &lt;code&gt;secondMax&lt;/code&gt;. Поэтому НОД на отрезке можно вычислить по такой формуле:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gcd(diffGCD, max - secondMax, max)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;В оригинальной статье асимптотика этого алгоритма указана как $O(q \log^3 n)$. Там подразумевается, что $C = q = n$, так что в реальности такая оценка будет выглядеть как $O(n \log n \log C + q \log^2 n \log C)$.&lt;/p&gt;
&lt;p&gt;Однако давайте улучшим эту оценку. Давайте докажем, что асимптотика на самом деле $O(n (\log n + \log C) + q \log n (\log n + \log C))$.&lt;/p&gt;
&lt;p&gt;Почему мы не можем сказать так же, как и в облегченной версии задачи, что логарифмы складываются, а не перемножаются? Дело в том, что НОД $k$ чисел, не больших $C$ по модулю, вычисляется за $O(k + \log C)$ только в том случае, если мы вычисляем НОД последовательно. То есть сначала берем НОД двух чисел, потом берем НОД этого НОДа и следующего числа, и так далее.
Именно так работает обычное дерево отрезков: в нем мы спускаемся вниз по левой и правой границам отрезка, то есть по бамбукам, в которых будет последовательно вычисляться НОД.
Однако в Segment Tree Beats мы посещаем большое количество дополнительных вершин, которые вовсе не образуют бамбуки, так что логарифмы будут перемножаться. Но давайте копнем глубже.&lt;/p&gt;
&lt;p&gt;Давайте вспомним, как мы оценивали асимптотику в задаче &lt;code&gt;min=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;. Мы ввели потенциал, равный количеству помеченных вершин в дереве, то есть тех вершин, у которых максимум в левом поддереве не совпадает с максимумом в правом поддереве.
Мы доказали, что суммарно за все время он может увеличиться максимум на $O(n + q \log n)$, а также на каждые $O(\log n)$ посещенных дополнительных вершин этот потенциал уменьшается на $1$, поэтому асимптотика будет $O(n \log n + q \log^2 n)$. Там мы показали, что в поддереве любой дополнительной вершины есть метка, которая удалится, поэтому если удалилось $k$ меток, то было посещено не более $k \log n$ вершин. Однако нас интересуют не все вершины, а те, в которых происходит разветвление. Ведь в бамбуке, как мы уже поняли, НОД вычисляется быстро. Но ведь все дополнительные вершины как раз таки лежат на $k$ путях до корня от удаленных меток. И на каждом таком пути НОД будет вычисляться за $O(\log n + \log C)$, а так как всего за все время было удалено максимум $O(n + q \log n)$ меток, то асимптотика алгоритма будет равна $O(n (\log n + \log C) + q \log n (\log n + \log C))$. Что и требовалось доказать.&lt;/p&gt;
&lt;h2 id=&#34;--на-отрезке-sum&#34;&gt;&lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt; на отрезке, $\sum$&lt;/h2&gt;
&lt;h3 id=&#34;формулировка-4&#34;&gt;Формулировка&lt;/h3&gt;
&lt;p&gt;Простую версию этой задачи мы уже рассматривали ранее. В этой задаче у нас есть массив неотрицательных целых чисел $A$ ($0 \le A_i &amp;lt; C$), а также имеются запросы трех типов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Даны $ql, qr, x$ ($1 \le x &amp;lt; C$). Нужно заменить все элементы массива $a$ на полуинтервале $[ql, qr)$ на $A_i \bmod x$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr, y$ ($0 \le y &amp;lt; C$). Нужно заменить элемент массива $A$ на &lt;strong&gt;отрезке&lt;/strong&gt; от $ql$ до $qr$ на $y$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть сумму элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;решение-3&#34;&gt;Решение&lt;/h3&gt;
&lt;p&gt;Решение ничем не отличается от решения простой версии задачи, описанного ранее в задаче, где мы делали &lt;code&gt;%=&lt;/code&gt; и &lt;code&gt;=&lt;/code&gt; в точке.&lt;/p&gt;
&lt;h3 id=&#34;доказательство-3&#34;&gt;Доказательство&lt;/h3&gt;
&lt;p&gt;&lt;span style=&#34;color:gray&#34;&gt;Спасибо Антону Степанову за доказательство&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Однако теперь старый потенциал, равный сумме логарифмов элементов на отрезке, больше не работает, потому что при присвоении на отрезке он может очень сильно увеличиваться. Придумаем новый потенциал и докажем, что время работы останется все тем же самым: $O((n + q) \log n \log C)$.&lt;/p&gt;
&lt;p&gt;Для начала скажем, что вершины, на отрезке которых все числа равны, являются помеченными, а потенциал этих вершин равен нулю. В любом случае, такая вершина не может быть дополнительной, так как в ней выполнится &lt;code&gt;tagCondition&lt;/code&gt;, потому что $max = min$.&lt;/p&gt;
&lt;p&gt;Отрезок, за который отвечает любая вершина разбивается на подотрезки с одинаковыми значениями. У любой непомеченной вершины таких отрезков не меньше двух. Если раньше мы считали в потенциале сумму логарифмов всех элементов на отрезке, то теперь подотрезок одинаковых значений в потенциале будет считаться за одно значение, то есть потенциал вершины — это сумма логарифмов элементов из подотрезков равных значений, на которые разбивается отрезок текущей вершины. Разумеется, чтобы у нас не было логарифма нуля, мы будем брать логарифмы элементов, увеличенных на $1$.&lt;/p&gt;
&lt;p&gt;Как уже было сказано ранее, потенциалы помеченных вершин при этом считаются равными нулю.
Потенциал всего дерева как всегда равен сумме потенциалов всех вершин.&lt;/p&gt;
&lt;p&gt;Наш новый потенциал не больше старого, так что очевидно, что изначально $\Phi \le n \log n \log C$.&lt;/p&gt;
&lt;p&gt;При посещении тупиковых вершин либо потенциал не меняется, если выполнилось &lt;code&gt;breakCondition&lt;/code&gt;, либо потенциал как был нулем, так и останется, если выполнилось &lt;code&gt;tagCondition&lt;/code&gt;, потому что такие вершины помечены.&lt;/p&gt;
&lt;p&gt;При посещении дополнительных вершин в запросе первого типа не появляется никаких новых отрезков значений. Только старые значения уменьшаются и, возможно, некоторые отрезки склеиваются, так что потенциал может только уменьшаться.&lt;/p&gt;
&lt;p&gt;Вершины, которые отвечают за отрезки, лежащие полностью внутри отрезка изменения запроса второго типа, становятся помеченными, поэтому потенциал в них становится равен нулю.&lt;/p&gt;
&lt;p&gt;При посещении же обычных вершин потенциалы могут увеличиваться, но не очень сильно, при запросах обоих типов. Могло появиться не более трех новых отрезков элементов, каждый из которых даст вклад $O(\log C)$ в потенциал. А если учесть, что обычных вершин в каждом запросе $O(\log n)$, можно понять, что потенциал за все время увеличится максимум на $O(q \log n \log C)$.&lt;/p&gt;
&lt;p&gt;Остается лишь показать, что при посещении дополнительной вершины потенциал уменьшается хотя бы на $1$. Действительно, не выполнилось ни &lt;code&gt;breakCondition&lt;/code&gt;, ни &lt;code&gt;tagCondition&lt;/code&gt;, так что вершина не помечена и $max \ge x$, поэтому на отрезке $max$ значение уменьшится хотя бы в два раза после взятие по модулю, поэтому потенциал текущей вершины уменьшится хотя бы на $1$. Что и требовалось доказать.&lt;/p&gt;
&lt;p&gt;Таким образом, асимптотика получившегося алгоритма — $O((n + q) \log n \log C)$.&lt;/p&gt;
&lt;h2 id=&#34;sqrt--sum-max-min&#34;&gt;$\sqrt{}=$, &lt;code&gt;+=&lt;/code&gt;, $\sum$, $\max$, $\min$&lt;/h2&gt;
&lt;h3 id=&#34;формулировка-5&#34;&gt;Формулировка&lt;/h3&gt;
&lt;p&gt;В этой задаче у нас есть массив неотрицательных целых чисел $A$ ($0 \le A_i &amp;lt; C$), а также имеются запросы пяти типов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Даны $ql, qr$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\left\lfloor \sqrt{A_i} \right\rfloor$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr, x$ ($0 \le x &amp;lt; C$). Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $x$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть сумму элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть максимум элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть минимум элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Эта задача доступна &lt;a href=&#34;https://vjudge.net/problem/HDU-5828&#34;&gt;здесь&lt;/a&gt; или &lt;a href=&#34;http://acm.hdu.edu.cn/showproblem.php?pid=5828&#34;&gt;здесь&lt;/a&gt;. Это китайские сайты, поэтому там не так просто зарегистрироваться.
На этих сайтах нет двух последних операций, но они поддерживаются абсолютно очевидно и все равно необходимы во время решения, так что это ничего не меняет.&lt;/p&gt;
&lt;h3 id=&#34;решение-4&#34;&gt;Решение&lt;/h3&gt;
&lt;p&gt;Мы будем поддерживать в каждой вершине сумму, максимум и минимум. Все запросы кроме первого типа выполняются так же, как и в обычном дереве отрезков.&lt;/p&gt;
&lt;p&gt;Кроме того, для первой операции нам понадобится еще уметь присваивать на отрезке, поэтому в каждой вершине хранится $2$ &lt;code&gt;push&lt;/code&gt;-а: что надо присвоить на отрезке и что надо прибавить на отрезке. При этом только один из них может быть в вершине, потому что комбинация присвоения и прибавления — это то же самое, что просто присвоение.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;breakCondition&lt;/code&gt; в этом случае является стандартным:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;breakCondition = qr &amp;lt;= l || r &amp;lt;= ql&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;А каким же должно быть &lt;code&gt;tagCondition&lt;/code&gt;? Первая идея, которая приходит в голову — это&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tagCondition = ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr &amp;amp;&amp;amp; &lt;/code&gt; $\left\lfloor \sqrt{\max} \right\rfloor = \left\lfloor \sqrt{\min} \right\rfloor$,&lt;/p&gt;
&lt;p&gt;потому что в этом случае корни из всех чисел на отрезке равны, и нужно просто произвести присвоение этому корню на этом отрезке. &lt;strong&gt;Однако это тот случай, когда очевидный вариант не работает!&lt;/strong&gt; Представим себе ситуацию, в которой изначально массив имеет вид $1, 2, 1, 2, 1, 2, \ldots, 1, 2$. После чего к нему $\frac{q}{2}$ раз применяют две операции: $+=2$ на всем массиве и $\sqrt{}=$ на всем массиве.
После первой операции массив превращается в $3, 4, 3, 4, 3, 4, \ldots, 3, 4$. А после второй он возвращается в исходное состояние.
Однако заметим, что целая часть от корня из $3$ — это $1$, а целая часть от корня из $4$ — это $2$, поэтому ни в одной вершине кроме листьев &lt;code&gt;tagCondition&lt;/code&gt; не выполнится, так что каждая операция $\sqrt{}=$ будет выполняться за $O(n)$, и итоговая асимптотика будет $O(q \cdot n)$. Поэтому это &lt;code&gt;tagCondition&lt;/code&gt; нам не подходит.&lt;/p&gt;
&lt;p&gt;На самом деле, правильный &lt;code&gt;tagCondition&lt;/code&gt; выглядит следующим образом:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tagCondition = ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr &amp;amp;&amp;amp; max[v] - min[v] &amp;lt;= 1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Казалось бы, условие стало только слабее. Раньше мы проверяли, что корни совпадают, а теперь мы проверяем, что либо максимум равен минимуму, либо они отличаются на $1$. Но здесь кроется принципиальная разница. Единственный плохой случай — это когда $\max$ — это квадрат, а минимум на $1$ меньше. Тогда при взятии корня разница между ними останется равной $1$, и операцией &lt;code&gt;+=&lt;/code&gt; можно будет вернуть массив в исходное положение.&lt;/p&gt;
&lt;p&gt;Как же нам обновить значение в вершине, когда выполнилось &lt;code&gt;tagCondition&lt;/code&gt;? Максимум и минимум, очевидно, заменяются на свои корни.
А как поменяется сумма? Если целые части корней из минимума и максимума равны, то после применения операции на отрезке все числа будут равны, поэтому нужно просто присвоить $\left\lfloor \sqrt{\max} \right\rfloor$ на отрезке. Это частный случай неправильного &lt;code&gt;tagCondition&lt;/code&gt;, который мы обсуждали ранее.&lt;/p&gt;
&lt;p&gt;Остается один случай: если целые части корней из минимума и максимума не совпадают. При этом максимум и минимум отличаются в точности на $1$. Тогда и корни тоже будут отличаться в точности на $1$. Максимум был равен $k^2$, а минимум $k^2 - 1$. При этом $k^2$ заменился на $k$, а $k^2 - 1$ заменился на $k - 1$. Поэтому нужно просто ко всем числам на отрезке прибавить $k - k^2$.&lt;/p&gt;
&lt;h3 id=&#34;доказательство-4&#34;&gt;Доказательство&lt;/h3&gt;
&lt;p&gt;Давайте докажем, что с таким &lt;code&gt;tagCondition&lt;/code&gt; асимптотика будет $O(n \log C + q \log n \log C)$.&lt;/p&gt;
&lt;p&gt;Давайте введем потенциал вершины $\varphi(v) = \log($&lt;code&gt;max[v]-min[v]&lt;/code&gt;$+ 1)$. Прибавление единицы опять же нужно только для того, чтобы не брать логарифм нуля в случае, когда максимум равен минимуму.
Общим потенциалом $\Phi$ будет сумма потенциалов всех вершин дерева.&lt;/p&gt;
&lt;p&gt;Заметим, что потенциал любой вершины неотрицателен и не превышает $\log C$, так что в любой момент времени верно $0 \le \Phi \le O(n \log C)$.&lt;/p&gt;
&lt;p&gt;При этом как может увеличиваться этот потенциал? В запросах типа &lt;code&gt;get&lt;/code&gt; элементы массива не меняются, так что потенциал тоже не меняется. Для запросов второго типа потенциал вершины мог поменяться только в том случае, если данная вершина пересекается с отрезком запроса, но не лежит в нем полностью, потому что если она лежит в нем полностью, то и к минимуму, и к максимуму прибавится $x$, так что разность не поменяется. А вершин, которые пересекаются с отрезком запроса, но не лежат в нем полностью, $O(\log n)$ штук, так что потенциал может увеличиться максимум на $O(q \log n \log C)$ за все время.&lt;/p&gt;
&lt;p&gt;Аналогично, операция $\sqrt{}=$ не может увеличить потенциал, если вершина полностью лежит в отрезке запроса, потому что разность корней не больше разности исходных чисел (это легко проверить, но дальше мы докажем даже более сильное условие). А вершин, которые пересекаются с запросом, но не лежат в нем полностью, опять же $O(\log n)$ штук, так что опять же увеличение за все время — это $O(q \log n \log C)$.&lt;/p&gt;
&lt;p&gt;Осталось понять, что при посещении дополнительной вершины потенциал уменьшается хотя бы на $\log (1.5)$ (не пугайтесь этого числа, на самом деле неважно, чему оно равно, главное, что это положительная константа), тогда итоговая асимптотика будет равна $O(n \log C + q \log n \log C)$. В этом нам поможет следующий факт:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема:&lt;/strong&gt;
Если $a$ и $b$ — неотрицательные целые числа, и $a \ge b + 2$, то $a - b \ge 1.5 \cdot \left( \left\lfloor \sqrt{a} \right\rfloor - \left\lfloor \sqrt{b} \right\rfloor \right) + 0.5$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
Обозначим  $\left\lfloor \sqrt{b} \right\rfloor = m$ и $\left\lfloor \sqrt{a} \right\rfloor = n + m$. При этом $n \ge 0$, потому что $a &amp;gt; b$.
Тогда $b = m^2 + l$, где $0 \le l \le 2 \cdot m$ и $a = (n + m)^2 + k$, где $0 \le k \le 2 \cdot (n + m)$. Разберем два случая:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$n \le 1$. То есть $\left\lfloor \sqrt{a} \right\rfloor - \left\lfloor \sqrt{b} \right\rfloor \le 1$, так что неравенство, которое нам надо доказать, превращается в $a - b \ge 1.5 \cdot 1 + 0.5 = 2$. Это верно из-за условия на то, что $a \ge b + 2$.&lt;/li&gt;
&lt;li&gt;$n \ge 2$. В этом случае мы знаем, что $a \ge (n + m)^2$ и $b \le m^2 + 2m$, поэтому $a - b \ge (n + m)^2 - (m^2 + 2m) = n^2 + 2nm - 2m = n^2 + 2m \cdot (n - 1) \ge n^2$. Последнее неравенство верно, потому что все множители во втором слагаемом неотрицательны. Нам нужно доказать, что это не меньше, чем $1.5 \cdot n + 0.5$. Это легко проверить, потому что $n^2 \ge 2n = 1.5n + 0.5n \ge 1.5n + 0.5$. Первое неравенство верно из-за того, что $n \ge 2$, а второе из-за того, что $n \ge 1$. Что и требовалось доказать.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Давайте немного преобразуем получившееся неравенство. Прибавим к обеим частям $1$:&lt;/p&gt;
&lt;p&gt;$$a - b + 1 \ge 1.5  \left( \left\lfloor \sqrt{a} \right\rfloor - \left\lfloor \sqrt{b} \right\rfloor + 1\right)$$&lt;/p&gt;
&lt;p&gt;И возьмем логарифмы от обеих частей:&lt;/p&gt;
&lt;p&gt;$$\log(a - b + 1) \ge \log \left(1.5  \left( \left\lfloor \sqrt{a} \right\rfloor - \left\lfloor \sqrt{b} \right\rfloor + 1\right)\right) = \log (1.5) + \log \left( \left\lfloor \sqrt{a} \right\rfloor - \left\lfloor \sqrt{b} \right\rfloor + 1\right)$$&lt;/p&gt;
&lt;p&gt;То есть мы доказали, что потенциал уменьшился хотя бы на $\log (1.5)$, и асимптотика решения доказана.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Обратите внимание, что операция присвоения на отрезке будет менять потенциалы так же несильно, как и операция прибавления на отрезке, так что ее мы тоже можем поддерживать. Кроме того, мы и так присваиваем на отрезке в одном из случаев, когда берем корень, поэтому особо ничего нового к решению добавлять не придется.&lt;/p&gt;
&lt;h2 id=&#34;--sum-max-min&#34;&gt;&lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, $\sum$, $\max$, $\min$&lt;/h2&gt;
&lt;h3 id=&#34;формулировка-6&#34;&gt;Формулировка&lt;/h3&gt;
&lt;p&gt;В этой задаче у нас есть массив неотрицательных целых чисел $A$ ($0 \le A_i &amp;lt; C$), а также имеются запросы пяти типов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Даны $ql, qr, x$ ($x \ge 0$). Нужно поделить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $x$ нацело.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr, y$ ($1 \le y &amp;lt; C$). Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $y$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть сумму элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть максимум элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть минимум элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;решение-5&#34;&gt;Решение&lt;/h3&gt;
&lt;p&gt;Как бы это ни было удивительно, но решение абсолютно идентично решению предыдущей задачи.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;breakCondition = qr &amp;lt;= l || r &amp;lt;= ql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tagCondition = ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr &amp;amp;&amp;amp; max[v] - min[v] &amp;lt;= 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Есть только одно новое условие: если мы пытаемся поделить на отрезке на единицу, то мы просто проигнорируем этот запрос, потому что деление на $1$ не меняет элементов.&lt;/p&gt;
&lt;p&gt;И в случае, если &lt;code&gt;tagCondition&lt;/code&gt; выполнилось, мы делаем точно такие же изменения, как и для корня. Если $\left\lfloor \frac{\max}{x} \right\rfloor = \left\lfloor \frac{\min}{x} \right\rfloor$, то нужно всем числам на отрезке присвоить $\left\lfloor \frac{\max}{x} \right\rfloor$, а если $\left\lfloor \frac{\max}{x} \right\rfloor \neq \left\lfloor \frac{\min}{x} \right\rfloor$, то тогда $\max = kx$ для некоторого $k$ и $\min = kx - 1$. При этом $\left\lfloor \frac{\max}{x} \right\rfloor = k$ и $\left\lfloor \frac{\min}{x} \right\rfloor = k - 1$, так что надо просто ко всем числам на отрезке прибавить $k - kx$.&lt;/p&gt;
&lt;h3 id=&#34;доказательство-5&#34;&gt;Доказательство&lt;/h3&gt;
&lt;p&gt;Почему же такое решение будет работать?&lt;/p&gt;
&lt;p&gt;Проведем абсолютно такое же доказательство с таким же потенциалом. Для всех операций кроме первой ничего не поменялось. Для первой операции опять же потенциал вершины не мог увеличиться, если вершина полностью лежит в отрезке запроса, потому что после деления разность максимума и минимума не могла увеличиться (это несложно проверить, но далее мы докажем более сильное условие).&lt;/p&gt;
&lt;p&gt;Так что все, что нам надо доказать, — это то, что при посещении дополнительной вершины потенциал уменьшится хотя бы на $\log (\frac{4}{3})$ (как и раньше, просто положительная константа), и тогда асимптотика будет равна $O(n \log C + q \log n \log C)$. В этот момент нам как раз пригодится то, что мы игнорируем запросы, в которых $x = 1$, потому что в этом случае никакие потенциалы не меняются, и мы бы просто делали лишние действия.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема:&lt;/strong&gt;
Если $a$, $b$ и $x$ — неотрицательные целые числа, при этом $a \ge b + 2$ и $x \ge 2$, то $a - b \ge \frac{4}{3} \cdot \left( \left\lfloor \frac{a}{x} \right\rfloor - \left\lfloor \frac{b}{x} \right\rfloor \right) + \frac{1}{3}$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
Обозначим  $\left\lfloor \frac{b}{x} \right\rfloor = m$ и $\left\lfloor \frac{a}{x} \right\rfloor = n + m$. При этом $n \ge 0$, потому что $a &amp;gt; b$.
Тогда $b = mx + l$, где $0 \le l &amp;lt; x$ и $a = (n + m) \cdot x + k$, где $0 \le k &amp;lt; x$. Разберем два случая:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$n \le 1$. То есть $\left\lfloor \frac{a}{x} \right\rfloor - \left\lfloor \frac{b}{x} \right\rfloor \le 1$, так что неравенство, которое нам надо доказать, превращается в $a - b \ge \frac{4}{3} \cdot 1 + \frac{1}{3} = \frac{5}{3}$. Это верно из-за условия на то, что $a \ge b + 2$.&lt;/li&gt;
&lt;li&gt;$n \ge 2$. В этом случае мы знаем, что $a \ge (n + m) \cdot x$ и $b \le mx + x - 1$, поэтому $a - b \ge (n + m) \cdot x - (mx + x - 1) = nx - x + 1$. И мы хотим доказать, что это не меньше, чем $\frac{4}{3} n + \frac{1}{3}$. Перенесем все из правой части в левую, а $x$ перенесем в правую:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$n \cdot \left(x - \frac{4}{3}\right) + \frac{2}{3} \ge x$$&lt;/p&gt;
&lt;p&gt;$n \ge 2$, поэтому заменим в левой части:&lt;/p&gt;
&lt;p&gt;$$2 \cdot \left(x - \frac{4}{3}\right) + \frac{2}{3} \ge x$$&lt;/p&gt;
&lt;p&gt;Если раскрыть левую часть, получится:&lt;/p&gt;
&lt;p&gt;$$2x - 2 \ge x$$&lt;/p&gt;
&lt;p&gt;Это верно в силу того, что $x \ge 2$. Что и требовалось доказать.&lt;/p&gt;
&lt;p&gt;Давайте немного преобразуем получившееся неравенство. Прибавим к обеим частям $1$:&lt;/p&gt;
&lt;p&gt;$$a - b + 1 \ge \frac{4}{3} \left( \left\lfloor \frac{a}{x} \right\rfloor - \left\lfloor \frac{b}{x} \right\rfloor + 1\right)$$&lt;/p&gt;
&lt;p&gt;И возьмем логарифмы от обеих частей:&lt;/p&gt;
&lt;p&gt;$\log(a - b + 1) \ge \log \left(\frac{4}{3}  \left( \left\lfloor \frac{a}{x} \right\rfloor - \left\lfloor \frac{b}{x} \right\rfloor + 1\right)\right) = \log (\frac{4}{3}) + \log \left( \left\lfloor \frac{a}{x} \right\rfloor - \left\lfloor \frac{b}{x} \right\rfloor + 1\right)$.&lt;/p&gt;
&lt;p&gt;То есть мы доказали, что потенциал уменьшился хотя бы на $\log (\frac{4}{3})$, и асимптотика решения доказана.&lt;/p&gt;
&lt;h2 id=&#34;--max&#34;&gt;&lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, $\max$&lt;/h2&gt;
&lt;h3 id=&#34;формулировка-7&#34;&gt;Формулировка&lt;/h3&gt;
&lt;p&gt;В этой задаче у нас есть массив целых чисел $A$ ($0 \le A_i &amp;lt; C$), а также имеются запросы трех типов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Даны $ql, qr, x$ ($0 \le x &amp;lt; C$). Нужно заменить все элементы массива $a$ на полуинтервале $[ql, qr)$ на $A_i \&amp;amp; x$ (побитовое &amp;laquo;и&amp;raquo;).&lt;/li&gt;
&lt;li&gt;Даны $ql, qr, x$ ($0 \le y &amp;lt; C$). Нужно заменить все элементы массива $a$ на полуинтервале $[ql, qr)$ на $A_i | x$ (побитовое &amp;laquo;или&amp;raquo;).&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть максимум элементов массива $A$ на полуинтервале $[ql, qr)$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;В данном случае стоит считать, что $C = 2^k$ для некоторого натурального $k$, то есть мы работаем с $k$-битными числами.&lt;/p&gt;
&lt;p&gt;Эта задача доступна &lt;a href=&#34;https://csacademy.com/contest/round-70/task/and-or-max/&#34;&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;решение-6&#34;&gt;Решение&lt;/h3&gt;
&lt;p&gt;Давайте заметим, что $\&amp;amp;$ — это то же самое, что побитовый минимум, а $|$ — побитовый максимум, так что эта задача — это в каком-то смысле вариация Ji Driver Segment Tree для битовых операций.&lt;/p&gt;
&lt;p&gt;Давайте хранить в каждой вершине дерева максимум на соответствующем подотрезке, побитовое &amp;laquo;или&amp;raquo;, побитовое &amp;laquo;и&amp;raquo;, а также ленивые обновления типа &lt;code&gt;pushAnd&lt;/code&gt; и &lt;code&gt;pushOr&lt;/code&gt;, которые означают, что ко всем числам на отрезке нужно применить операцию &amp;laquo;и&amp;raquo;, а также &amp;laquo;или&amp;raquo;. Можно заметить, что даже если к нам приходят много операций первых двух типов, мы все равно можем скомбинировать их в два таких значения, которые нужно проталкивать.&lt;/p&gt;
&lt;p&gt;Теперь осталось понять, как это все считать, и какие будут &lt;code&gt;breakCondition&lt;/code&gt; и &lt;code&gt;tagCondition&lt;/code&gt;. В данном случае нестандартным будет только &lt;code&gt;tagCondition&lt;/code&gt;. Почему нам вообще не подходит обычное дерево отрезков? Потому что если ко всем числам на отрезке применить запрос одного из первых двух типов, то их относительных порядок может сильно поменяться, а значит, поменяется и максимум. Но в каком случае относительный порядок не поменяется? Посмотрим для примера на первую операцию. Какими свойствами должны обладать числа $a_1 \le a_2 \le \ldots \le a_k$, чтобы при этом выполнялось $a_1 \&amp;amp; x \le a_2 \&amp;amp; x \le \ldots \le a_k \&amp;amp; x$? Те биты, которые в $x$ установлены в единицу, не поменяются в числах. Поменяются только те биты, которые у $a_i$ установлены в $1$, а у $x$ — в $0$. И если у какого-то $a_i$ была установлена $1$, а у другого $0$, то их относительный порядок мог поменяться. Но если на всех позициях, в которых у числа $x$ стоит ноль, у всех $a_i$ стоят одинаковые биты, то относительный порядок никак не изменится. Аналогичное утверждение можно сформулировать для операции &amp;laquo;или&amp;raquo;: если на всех позициях, в которых у числа $y$ стоит единица, у всех $a_i$ выставлены одинаковые биты, то их относительный порядок не изменится.&lt;/p&gt;
&lt;p&gt;А проверить, что на этих позициях у всех чисел стоят одинаковые биты, очень легко. Достаточно посмотреть на побитовое &amp;laquo;и&amp;raquo; и побитовое &amp;laquo;или&amp;raquo; всех чисел на отрезке. Тогда если какой-то бит у них совпадает, это как раз равносильно тому, что у всех чисел на отрезке этот бит совпадает. Так что &lt;code&gt;tagCondition&lt;/code&gt; для первой и второй операции соответственно будут выглядеть следующим образом:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tagCondition_and = ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr &amp;amp;&amp;amp; ((and[v] ^ or[v]) &amp;amp; ~x) == 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tagCondition_or = ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr &amp;amp;&amp;amp; ((and[v] ^ or[v]) &amp;amp; y) == 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Упражнение:&lt;/strong&gt;
Хорошим упражнением будет понять, почему эта битовая магия соответствует именно тем условиям, которые мы описали ранее.&lt;/p&gt;
&lt;h3 id=&#34;доказательство-6&#34;&gt;Доказательство&lt;/h3&gt;
&lt;p&gt;Почему же такое решение будет работать быстро?&lt;/p&gt;
&lt;p&gt;Давайте введем потенциал $\varphi(v)$ вершины $v$ дерева отрезков, который будет равен количеству битов, в которых не все числа на соответствующем отрезке совпадают, то есть, иными словами, &lt;code&gt;__builtin_popcount(and[v] ^ or[v])&lt;/code&gt;. Потенциал всего дерева $\Phi$, как обычно, будет равен сумме потенциалов всех вершин.&lt;/p&gt;
&lt;p&gt;Заметим, что $0 \le \varphi(v) \le \log C$, потому что у нас есть всего $\log C$ битов, так что отличающихся не больше. Поэтому в любой момент времени $0 \le \Phi \le n \log C$.&lt;/p&gt;
&lt;p&gt;В каких случаях потенциал может увеличиваться? Операция третьего типа не меняет элементов массива, так что потенциал тоже не меняется. Если у всех чисел на каком-то отрезке какой-то бит был равен, и мы применили ко всем этим числам операцию одного из первых двух типов, то этот бит не мог перестать быть равен. Так что увеличения потенциала могли происходить только в вершинах, подотрезок которых пересекается, но не лежит полностью в отрезке запроса, то есть в обычных вершинах. При этом для каждой такой вершины потенциал мог увеличиться максимум на $\log C$, а для каждого запроса таких вершин $O(\log n)$, так что можно сказать, что $\Phi_+ \le O(q \log n \log C)$.&lt;/p&gt;
&lt;p&gt;Теперь поймем, почему при посещении дополнительных вершин потенциал уменьшается. Если мы посетили какую-то дополнительную вершину, то существует такой бит, что на данный момент не у всех чисел он одинаковый, и при этом у $x$ он выставлен в $0$ (либо у $y$ в $1$ для запросов второго типа), то есть после применения текущего запроса у всех чисел этот бит будет равен нулю (или единице для запросов второго типа). Так что потенциал текущей вершины уменьшится как минимум на $1$. Что и требовалось доказать.&lt;/p&gt;
&lt;p&gt;Поэтому асимптотика получившегося алгоритма — $O(n \log C + q \log n \log C)$.&lt;/p&gt;
&lt;h2 id=&#34;min--max-over-sum-для-нескольких-массивов-параллельно&#34;&gt;&lt;code&gt;min=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, $\max$ over $\sum$ для нескольких массивов параллельно&lt;/h2&gt;
&lt;h3 id=&#34;формулировка-8&#34;&gt;Формулировка&lt;/h3&gt;
&lt;p&gt;В этой задаче у нас есть сразу &lt;strong&gt;два массива&lt;/strong&gt; целых чисел $A$ и $B$, а также имеются запросы пяти типов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Даны $ql, qr, x$. Нужно заменить все элементы массива $a$ на полуинтервале $[ql, qr)$ на $\min(A_i, x)$.&lt;/li&gt;
&lt;li&gt;Аналогичный запрос для массива $B$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr, y$. Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $y$.&lt;/li&gt;
&lt;li&gt;Аналогичный запрос для массива $B$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть $\max_{ql \le i &amp;lt; qr} A_i + B_i$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Последний запрос как раз называется $\max$ over $\sum$, то есть максимум от поэлементной суммы двух массивов.&lt;/p&gt;
&lt;p&gt;Также в конце решения мы покажем, как это обобщается на случай бóльшего количества массивов.&lt;/p&gt;
&lt;h3 id=&#34;решение--доказательство&#34;&gt;Решение + доказательство&lt;/h3&gt;
&lt;p&gt;Если бы у нас не было операции &lt;code&gt;min=&lt;/code&gt;, то эта задача была бы весьма простой. Мы бы пользовались обычным деревом отрезков, и если мы на отрезке прибавляем число в одном из массивов, то к максимуму поэлементной суммы массивов тоже прибавится это самое число. Иными словами, можно считать, что у нас есть всего один массив $C$, определенный по правилу $C_i = A_i + B_i$, и операции производятся с ним.&lt;/p&gt;
&lt;p&gt;Однако, если у нас есть операция &lt;code&gt;min=&lt;/code&gt;, то нам важны значения каждого из массивов по отдельности.&lt;/p&gt;
&lt;p&gt;Мы воспользуемся стандартной техникой из Ji Driver Segment Tree, то есть будем хранить максимум, их количество и второй максимум. Тогда при условии &lt;code&gt;tagCondition&lt;/code&gt; мы меняем в массиве какой-то разрозненный набор позиций, на которых стоят максимумы. Как в таком случае пересчитать максимум поэлементной суммы массивов? Давайте разделим позиции на подотрезке, которому соответсвует текущая вершина, на 4 типа:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;В обоих массивах на этой позиции стоят максимумы на отрезке&lt;/li&gt;
&lt;li&gt;В первом массиве на этой позиции стоит максимум на отрезке, а во втором — нет&lt;/li&gt;
&lt;li&gt;Во втором массиве на этой позиции стоит максимум на отрезке, а в первом — нет&lt;/li&gt;
&lt;li&gt;В обоих массивах на этой позиции стоят не максимумы на отрезке&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;И после такого разделения выясняется, что хранить максимум сумм для каждого из четырех типов по отдельности оказывается очень просто. Если выполнилось &lt;code&gt;tagCondition&lt;/code&gt;, то нужно поменять значения, соответствующие тем типам, в которых в этом массиве стоит максимум. При этом значение максимума изменилось с &lt;code&gt;max&lt;/code&gt; на $x$, поэтому из соответствующих значений как раз надо отнять &lt;code&gt;max&lt;/code&gt;$-x$.
Ответом на запрос тогда будет просто максимум из четырех отдельных максимумов для каждого из типов.&lt;/p&gt;
&lt;p&gt;Осталось научиться пересчитывать значения в вершине через значения в детях. Но это тоже делается очень просто. Мы сначала пересчитываем максимумы в обоих массивах в текущей вершине, после чего для каждого типа каждого из детей понимаем, стоят ли там максимумы или нет. Если там был не максимум для сына, то это будет не максимум и для отца; а если это был максимум для сына, то он мог как остаться максимумом, так и перестать им быть.&lt;/p&gt;
&lt;p&gt;Решение ничем не отличается от задачи &lt;code&gt;max=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, мы просто поддерживаем в вершине четыре дополнительных значения. Поэтому асимптотика получается $O(n \log n + q \log^2 n)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Если подумать, можно заметить, что эта идея легко обобщается на большее количество массивов. Если у нас $k$ массивов, то мы будем поддерживать $2^k$ дополнительных величин в каждой вершине, потому что в каждом массиве на каждой позиции может стоять либо максимум, либо не максимум (2 варианта), и можно брать всевозможные комбинации максимумов и не максимумов для разных массивов. Получается всего $2^k$ различных комбинаций. И асимптотика тогда возрастет до $O((n \log n + q \log^2 n) \cdot 2^k)$.&lt;/p&gt;
&lt;h2 id=&#34;историческая-информация-количество-изменений-элемента&#34;&gt;Историческая информация: количество изменений элемента&lt;/h2&gt;
&lt;h3 id=&#34;формулировка-9&#34;&gt;Формулировка&lt;/h3&gt;
&lt;p&gt;В этой задаче у нас есть массив целых чисел $A$, а также имеются запросы четырех типов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Даны $ql, qr, x$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\min(A_i, x)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr, y$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\max(A_i, y)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr, z$. Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $z$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть сумму элементов массива $S$ на полуинтервале $[ql, qr)$, где $S_i$ — это количество раз, когда $i$-й элемент массива $A$ менялся.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;решение--доказательство-1&#34;&gt;Решение + доказательство&lt;/h3&gt;
&lt;p&gt;Эта задача — первый базовый пример того, что такое &amp;laquo;историческая информация&amp;raquo;. Обычно мы делаем запросы к элементам массива на данный момент, и мы не заботимся о том, как текущий массив был получен. Историческая информация же хранит в себе знания о том, как наш массив менялся с течением времени, а не только его финальный вид.&lt;/p&gt;
&lt;p&gt;Однако нет ничего сложного в том, чтобы поддерживать эту информацию. Если бы у нас была только операция &lt;code&gt;+=&lt;/code&gt;, то каждый раз, когда массив $A$ меняют на полуинтервале $[ql, qr)$, к массиву $S$ надо было бы на этом полуинтервале просто прибавить $1$, потому что при каждой операции меняются абсолютно все элементы на подотрезке. Однако когда появляется операция &lt;code&gt;min=&lt;/code&gt;, это уже неверно. Но все еще мы можем понять, сколько элементов поменялось. Мы останавливаем рекурсию в тот момент, когда выполнилось &lt;code&gt;tagCondition&lt;/code&gt;. Это значит, что меняются только максимумы. Поэтому изменится ровно &lt;code&gt;cntMax&lt;/code&gt; элементов. На асимптотику алгоритма это никак влиять не будет, она все еще будет равна $O(n \log n + q \log^2 n)$. Стоит помнить о том, что если мы храним отложенную информацию о двух операциях &lt;code&gt;min=&lt;/code&gt;, то элементы ниже поменялись дважды.&lt;/p&gt;
&lt;p&gt;Далее мы рассмотрим более сложные версии исторической информации.&lt;/p&gt;
&lt;h2 id=&#34;историческая-информация-исторический-максимум&#34;&gt;Историческая информация: исторический максимум&lt;/h2&gt;
&lt;h3 id=&#34;формулировка-10&#34;&gt;Формулировка&lt;/h3&gt;
&lt;p&gt;В этой задаче у нас есть массив целых чисел $A$, а также имеются запросы трех типов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Даны $ql, qr, x$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\min(A_i, x)$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr, y$. Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $y$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть сумму элементов массива $M$ на полуинтервале $[ql, qr)$, где $M_i$ — это исторический максимум $A_i$, то есть самое большое значение, которое хранилось в $A_i$ за все время.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Эта задача доступна &lt;a href=&#34;https://uoj.ac/problem/169&#34;&gt;здесь&lt;/a&gt; в немного ином виде. Там вместо максимумов минимумы, и третий запрос берет не сумму элементов массива $M$, а максимум.&lt;/p&gt;
&lt;p&gt;Также похожая задача есть &lt;a href=&#34;https://www.luogu.com.cn/problem/P4314&#34;&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;решение--доказательство-2&#34;&gt;Решение + доказательство&lt;/h3&gt;
&lt;p&gt;Первые две операции мы поддерживаем как обычно. И асимптотика получившегося алгоритма будет опять же $O(n \log n + q \log^2 n)$. Остается понять, как поддерживать сумму на отрезке массива $M$.&lt;/p&gt;
&lt;p&gt;Давайте введем дополнительный массив $D$, элементы которого будут определяться по формуле $D_i = M_i - A_i$. А массив $M$ мы на самом деле не будем нигде поддерживать. Действительно, заметим, что&lt;/p&gt;
&lt;p&gt;$$
\sum_{ql \le i &amp;lt; qr} M_i = \sum_{ql \le i &amp;lt; qr} \left( \left(M_i - A_i \right) + A_i \right) =
\sum_{ql \le i &amp;lt; qr} \left( D_i + A_i \right) = \sum_{ql \le i &amp;lt; qr} D_i + \sum_{ql \le i &amp;lt; qr} A_i
$$&lt;/p&gt;
&lt;p&gt;Поэтому нам нужно уметь отдельно поддерживать сумму на отрезках массивов $A$ и $D$, и с их помощью мы сможем находить сумму на отрезке массива $M$. В этом и заключается основная идея исторического максимума. Но почему пересчитывать массив $D$ проще, чем массив $M$?&lt;/p&gt;
&lt;p&gt;Давайте сначала рассмотрим, что произойдет с массивом $D$ после операции второго типа. К элементам массива $A$ прибавится $x$, поэтому из $D$ нужно вычесть $x$. Однако если $A_i$ стало новым историческим максимумом, то $M_i$ тоже изменится, и станет равно $A_i$. Это происходит ровно в тот момент, когда $M_i - A_i$ становится отрицательным, и в этот момент нужно заменить $D_i$ на ноль. То есть на самом деле $D_i$ заменяется на $\max(D_i - x, 0)$. А эту операцию можно разделить на две: сначала вычесть на отрезке, а потом применить &lt;code&gt;max=&lt;/code&gt; на отрезке с нулем. Это все мы умеем делать.&lt;/p&gt;
&lt;p&gt;Теперь разберемся, что происходит с массивом $D$ при операции &lt;code&gt;min=&lt;/code&gt;. В этой операции элементы могут только убывать, поэтому $M_i$ точно не поменяются. А $A_i$ поменяются весьма понятным образом. Когда мы пришли в вершину, в которой выполнилось &lt;code&gt;tagCondition&lt;/code&gt;, $D_i$ поменяется точно так же, как и $A_i$, а далее это изменение надо будет просто протолкнуть в детей.&lt;/p&gt;
&lt;h2 id=&#34;историческая-информация-историческая-сумма&#34;&gt;Историческая информация: историческая сумма&lt;/h2&gt;
&lt;h3 id=&#34;формулировка-11&#34;&gt;Формулировка&lt;/h3&gt;
&lt;p&gt;В этой задаче у нас есть массив целых чисел $A$, а также имеются запросы двух типов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Даны $ql, qr, x$. Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $x$.&lt;/li&gt;
&lt;li&gt;Даны $ql, qr$. Необходимо вернуть сумму элементов массива $S$ на полуинтервале $[ql, qr)$, где $S_i$ — сумма элементов, стоящих на позиции $i$ в массиве $A$ за все время. То есть после каждой операции к $S_i$ прибавляется $A_i$ для всех позиций $i$.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;решение--доказательство-3&#34;&gt;Решение + доказательство&lt;/h3&gt;
&lt;p&gt;Эта задача похожа на предыдущую, но на этот раз вместо исторического максимума мы поддерживаем историческую сумму. В этой задаче нам хватит на самом деле даже обычного дерева отрезков.&lt;/p&gt;
&lt;p&gt;Введем дополнительный массив $D$, элементы которого будут определяться по формуле $D_i = S_i - ind \cdot A_i$, где $ind$ — это количество операций, которые уже были произведены с массивом на данный момент (после каждой операции $ind$ увеличивается на $1$).&lt;/p&gt;
&lt;p&gt;Опять же, сам массив $S$ мы нигде поддерживать не будем, потому что&lt;/p&gt;
&lt;p&gt;$$
\sum_{ql \le i &amp;lt; r} S_i = \sum_{ql \le i &amp;lt; r} \left(D_i + ind \cdot A_i\right) = \sum_{ql \le i &amp;lt; r} D_i + ind \cdot \sum_{ql \le i &amp;lt; r} A_i
$$&lt;/p&gt;
&lt;p&gt;Так что поддерживая сумму на отрезке в массивах $D$ и $A$, мы сможем вычислять сумму на отрезке в массиве $S$.
Посмотрим, как меняются элементы массива $D$ при операции первого типа.
Пускай до этой операции у нас были массивы $S$, $A$ и $D$, а после применения операции они превратились в массивы $S&#39;$, $A&#39;$ и $D&#39;$.
Мы хотим научиться вычислять $D&#39;$. Мы знаем, что $D_i = S_i - ind \cdot A_i$ и $D&#39;_i = S&#39;_i - (ind + 1) \cdot A&#39;_i$, потому что после применения операции $ind$ увеличился на $1$. Давайте раскроем последнюю формулу:&lt;/p&gt;
&lt;p&gt;$$D&#39;_i = S&#39;_i - (ind + 1) \cdot A&#39;_i = (S_i + A&#39;_i) - (ind + 1) \cdot A&#39;_i=$$&lt;/p&gt;
&lt;p&gt;$$= S_i - ind \cdot A&#39;_i = S_i - ind \cdot (A_i + x) = S_i - ind \cdot A_i - ind \cdot x = D_i - ind \cdot x$$&lt;/p&gt;
&lt;p&gt;Так что у массиву $D$ тоже просто прибавляется константа ($-ind \cdot x$) на отрезке. Для элементов, которые не меняются, к $S_i$ прибавится $A_i$ и $ind$ увеличится на $1$, поэтому $D_i$ никак не поменяются.&lt;/p&gt;
&lt;h2 id=&#34;задачи-для-практики&#34;&gt;Задачи для практики&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/contest/438/problem/D&#34;&gt;Первая задача&lt;/a&gt; из этой главы. &lt;code&gt;%=&lt;/code&gt; на отрезке, присвоение в точке и поиск суммы на отрезке.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ji Driver Segment Tree ($\min=$ на отрезке и поиск суммы на отрезке) можно решить &lt;a href=&#34;https://vjudge.net/problem/HDU-5306&#34;&gt;здесь&lt;/a&gt; и &lt;a href=&#34;http://acm.hdu.edu.cn/showproblem.php?pid=5306&#34;&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Кроме того есть не совсем очевидное применение Ji Driver Segment Tree в задаче &lt;a href=&#34;https://codeforces.com/problemset/problem/855/F&#34;&gt;&amp;laquo;Нагайна&amp;raquo;&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Задачу с операцией $\sqrt{}=$ на отрезке можно решить &lt;a href=&#34;https://vjudge.net/problem/HDU-5828&#34;&gt;здесь&lt;/a&gt; или &lt;a href=&#34;http://acm.hdu.edu.cn/showproblem.php?pid=5828&#34;&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Задачу с операцией $/=$ на отрезке можно решить &lt;a href=&#34;https://www.hackerrank.com/challenges/box-operations/problem&#34;&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Задача с операциями $\&amp;amp;=$ и $|=$ на отрезке и поиском максимума на отрезке доступна &lt;a href=&#34;https://csacademy.com/contest/round-70/task/and-or-max/&#34;&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Задача на сумму исторических максимумов доступна &lt;a href=&#34;https://uoj.ac/problem/169&#34;&gt;здесь&lt;/a&gt;. Также есть похожая задача &lt;a href=&#34;https://www.luogu.com.cn/problem/P4314&#34;&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Кроме того можете прорешать специально подготовленный &lt;a href=&#34;https://codeforces.com/group/1rv4rhCsHp/contest/327313&#34;&gt;контест&lt;/a&gt; на codeforces.  Если у вас нет доступа к соревнованию, нужно сначала вступить в &lt;a href=&#34;https://codeforces.com/group/1rv4rhCsHp/contests&#34;&gt;группу&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Дерево отрезков снизу</title>
      <link>https://peltorator.ru/posts/down_segment_tree/</link>
      <pubDate>Wed, 15 Sep 2021 15:53:15 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/down_segment_tree/</guid>
      
      <description>&lt;p&gt;Дерево отрезков — крайне функциональная структура данных, с помощью которой можно решить огромное количество задач. Однако оно достаточно медленное: производятся рекурсивные вызовы и тому подобное. Иногда это приводит к тому, что решение может не проходить по времени. Кроме того, стандартное дерево отрезков — это не самый очевидный для написания алгоритм.&lt;/p&gt;
&lt;p&gt;Чтобы решить эти проблемы часто прибегают к использованию дерева Фенвика. Оно очень простое в реализации, очень быстро работает, а также его легко обобщать для бóльших размерностей. Однако оно ограничено тем, что в своей базовой вариации оно подходит только для обратимых операций, потому что считает функцию на отрезке через два префикса. То есть, к примеру, минимум на отрезке стандартным деревом Фенвика посчитать не получится. Кроме того, стандартное дерево Фенвика поддерживает изменение только в точке, но не на отрезке. В таких ситуациях вам может захотеться прибегнуть к использованию дерева отрезков снизу. Это нерекурсивная структура данных, которая одновременно работает так же быстро, как и дерево Фенвика, и при этом так же (или почти) функциональна как обычное дерево отрезков.&lt;/p&gt;
&lt;h2 id=&#34;изменение-в-точке-сумма-на-отрезке&#34;&gt;Изменение в точке, сумма на отрезке&lt;/h2&gt;
&lt;p&gt;Идея скрывается в названии. Если в обычном дереве отрезков мы начинаем с корня и идем вниз, разбивая отрезок запроса на логарифм подотрезков, то в дереве отрезков снизу мы начинаем с листьев и поднимаемся вверх.&lt;/p&gt;
&lt;p&gt;Для начала давайте дополним длину массива до ближайшей степени двойки, чтобы он полностью лежал на одном уровне дерева. От этого асимптотика никак не поменяется.&lt;/p&gt;
&lt;p&gt;Давайте сначала рассмотрим базовую задачу. Есть запросы двух видов: изменить значение в точке и найти сумму на отрезке.&lt;/p&gt;
&lt;p&gt;Изменение в точке реализуется очень просто. Мы изменяем значение в листе, соответствующем этой точке, а затем постепенно идем до корня, обновляя значения в вершинах на пути через значения в детях.&lt;/p&gt;
&lt;p&gt;Поиск суммы на отрезке тоже весьма прост. Вместо того, чтобы суммировать отрезок из $k$ значений на текущем уровне, мы можем перейти на предыдущий уровень, и там просуммировать лишь $\frac{k}{2}$ значений, ведь элементы более высокого уровня отвечают за сумму двух соседних элементов текущего уровня. Однако если левая граница отрезка является правым сыном, либо правая граница является левым сыном, то мы не можем перейти для них на предыдущий уровень, и их значения надо прибавить на текущем этапе. Так мы будем постепенно подниматься по дереву, делая на каждом уровне константное количество операций.&lt;/p&gt;
&lt;p&gt;Асимптотика изменения равна $O(\log n)$, потому что состоит просто из прохода от листа к корню, а асимптотика нахождения суммы на полуинтервале $[l, r)$ равна $O(\log (r - l))$, что в общем случае, конечно, равно $O(\log n)$.&lt;/p&gt;
&lt;p&gt;Построение дерева выглядит совсем просто. Мы записываем элементы изначального массива в листья подряд, а затем проходим по внутренним вершинам по убыванию, пересчитывая значение текущей вершины через детей.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// N = 2^k, N &amp;gt;= n
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;updatePoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;findSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [l, r)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Мы заменили все операции на битовые для ускорения. Отец вершины &lt;code&gt;v&lt;/code&gt; — это &lt;code&gt;v &amp;gt;&amp;gt; 1&lt;/code&gt;, а сыновья — &lt;code&gt;v &amp;lt;&amp;lt; 1&lt;/code&gt; и &lt;code&gt;(v &amp;lt;&amp;lt; 1) | 1&lt;/code&gt;. Вершина является правым сыном, если ее номер нечетный, а левым, если четный (обратите внимание, что и для левой, и для правой границы условия в &lt;code&gt;findSum&lt;/code&gt; одинаковые, потому что правая граница берется не включительно).&lt;/p&gt;
&lt;p&gt;Однако самое удивительное — это то, что на самом деле везде в этом коде вместо &lt;code&gt;N&lt;/code&gt; можно написать &lt;code&gt;n&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;assign&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;updatePoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;findSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [l, r)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Если вам нужно работать с некоммутативной операцией, то нужно комбинировать ответ правильно. Нужно отдельно хранить левый префикс ответа и правый суффикс, а в конце их объединять.&lt;/p&gt;
&lt;p&gt;Таким образом, наша структура будет занимать ровно $2n$ памяти в отличие от обычного дерева отрезков, которому в зависимости от реализации бывает нужно от $4n$ до $8n$ памяти.&lt;/p&gt;
&lt;p&gt;Конечно, для операции суммы можно использовать и дерево Фенвика, но так как у нас есть вся мощь дерева отрезков, мы можем считать практически любую другую функцию на отрезке. К примеру, минимум, с которым стандартное дерево Фенвика не справится.&lt;/p&gt;
&lt;h2 id=&#34;изменение-на-отрезке-значение-в-точке&#34;&gt;Изменение на отрезке, значение в точке&lt;/h2&gt;
&lt;p&gt;Как обычно, структуру, которая умеет изменять в точке и находить значение функции на отрезке, можно переделать в структуру, которая умеет изменять целый отрезок и находить значение в точке. Для этого нам надо просто поменять местами функцию изменения с функцией нахождения значения. Функция изменения теперь разобьет отрезок запроса на логарифм вершин дерева отрезков, в каждой из которых оно оставит изменение, которое нужно сделать со всем поддеревом. Функция нахождения значения в точке в свою очередь пройдется по пути до корня и посчитает ответ.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Обратите внимание, что в этом случае нам необходимо, чтобы операции изменения на отрезке были коммутативны, то есть порядок их применения был неважен. К примеру, для операции прибавления на отрезке это верно, а для операции присвоения на отрезке это неверно. Дело в том, что мы оставляем изменения в вершинах дерева, а когда пытаемся найти значение, идем по порядку по вершинам, но изменения в них могут быть перемешаны во времени. Конкретно для присвоения на отрезке можно кроме самого присвоения хранить еще и момент времени, когда оно было сделано, а потом выбрать максимум таких моментов, однако в общем случае, возможно, что все операции придется применить в правильном порядке, и тогда нам придется их отсортировать, поэтому запрос нахождения значения в точке будет работать за $O(\log n \cdot \log \log n)$. Для некоммутативных операций нам подойдет дерево отрезков с ленивыми обновлениями, которое мы обсудим позже.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;assign&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// tree[0..n-1] are zeros because there&amp;#39;s nothing to add on a segment
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;findValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;segmentUpdate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [l, r)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addVal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Обратите внимание, что в 11 строке мы не пересчитываем значение в вершине через детей, потому что теперь мы в вершине храним не сумму на отрезке, а значение, которое нужно прибавить ко всем числам на отрезке.&lt;/p&gt;
&lt;h2 id=&#34;двумерные-запросы&#34;&gt;Двумерные запросы&lt;/h2&gt;
&lt;p&gt;Когда дерево отрезков двумерное, оно становится совсем медленным, и нам нужно делать сложную схему из рекурсивного запуска запроса к одномерному дереву отрезков из двумерного. В случае нерекурсивной реализации дерева отрезков снизу все практически так же просто, как с деревом Фенвика. Необходимо лишь написать два вложенных цикла вместо одного:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;findSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [lx, rx) * [ly, ry)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;lx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;rx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;curly&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ly&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;curry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curly&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;curry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curly&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;curly&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curly&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;curry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;lx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;rx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Нужно сдвинуть границу в том случае, если она нечетна и по $x$ координате, и по $y$.&lt;/p&gt;
&lt;p&gt;С полной реализацией можно ознакомиться по &lt;a href=&#34;https://pastebin.com/yBiQB5yu&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;ленивые-обновления&#34;&gt;Ленивые обновления&lt;/h2&gt;
&lt;p&gt;Чаще всего так получается, что обычно хватает обновления в точке. Либо же если все таки нужно обновление на отрезке, то ограничения не такие жестокие, и можно использовать обычное дерево отрезков. Однако давайте все таки поймем, как с помощью дерева отрезков снизу можно поддерживать изменения на отрезке и запрос поиска на отрезке. В этом нам помогут (как и в обычном дереве отрезков) ленивые обновления.&lt;/p&gt;
&lt;p&gt;Мы будем поддерживать все то же самое, что и в обычном дереве отрезков, но нужно просто перевести это на язык дерева отрезков снизу.&lt;/p&gt;
&lt;p&gt;Когда мы делаем запрос поиска на отрезке, нам нужно протолкнуть отложенные изменения из всех предков вершин, которые мы посетим. Все эти вершины — это просто предки листьев, соответствующих концам отрезка запроса. Однако проталкивать изменения надо сверху вниз, чтобы они комбинировались друг с другом. Как же это сделать в дереве отрезков снизу? Мы знаем, что предок вершины $v$ — это $\left\lfloor \frac{v}{2} \right\rfloor$, тогда $k$-й предок — это $\left\lfloor \frac{v}{2^k} \right\rfloor$. Поэтому мы можем просто перебрать степень двойки по убыванию и проталкивать изменения сверху вниз.&lt;/p&gt;
&lt;p&gt;Запрос изменения на отрезке будет выглядеть так же, как запрос поиска суммы на отрезке, только в конце после того как мы изменили какие-то значения, нужно пересчитать значения предков измененных вершин. Но это как и в прошлом случае просто предки листьев, отвечающих за концы отрезка. Однако в этот раз перебирать их надо уже как обычно — снизу вверх.&lt;/p&gt;
&lt;p&gt;Также стоит обратить внимание на то, что для вершин с номерами $[n, 2n)$ не нужно хранить ленивые обновления, потому что они являются листьями, поэтому в случае жестких ограничений по памяти можно достичь использования $3n$ ячеек.&lt;/p&gt;
&lt;p&gt;Рассмотрим код на примере задачи прибавления на отрезке и поиска максимума на отрезке:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;INF&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1e18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;logn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;__builtin_clz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;assign&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;assign&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;updateVertex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;updateAncestors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;doPush&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;leaf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;curV&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;leaf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;updateVertex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curV&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;updateVertex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curV&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;updateSegment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [l, r) += val
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ql&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;updateVertex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;updateVertex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;updateAncestors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;updateAncestors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;findMax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [l, r)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;doPush&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;doPush&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;INF&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;В более сложных случаях (к примеру, поиска суммы на отрезке) для пересчета значения в функции &lt;code&gt;apply&lt;/code&gt; может понадобиться длина отрезка текущей вершины. Это тоже легко можно поддерживать. На $k$-м снизу уровне (нумерация с нуля) длина отрезка равна $2^k$. И в случае, когда мы идем снизу вверх, и в случае, когда мы идем сверху вниз легко поддерживать эту величину.&lt;/p&gt;
&lt;h2 id=&#34;задачи-для-практики&#34;&gt;Задачи для практики&lt;/h2&gt;
&lt;p&gt;Можно потренироваться в первую очередь на любых задачах на дерево отрезков, коих существует бесчисленное количество.&lt;/p&gt;
&lt;p&gt;К примеру, можно воспользоваться следующими задачами:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://informatics.msk.ru/mod/statements/view.php?id=597&amp;amp;chapterid=752#1&#34;&gt;Задача&lt;/a&gt; на поиск максимума на отрезке.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://cses.fi/problemset/task/1735&#34;&gt;Задача&lt;/a&gt; на прибавление на отрезке, присвоение на отрезке и поиск суммы на отрезке.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://cses.fi/problemset/task/1736&#34;&gt;Задача&lt;/a&gt; на прибавление арифметической прогрессии на отрезке.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Чуть более продвинутая &lt;a href=&#34;https://codeforces.com/contest/446/problem/C&#34;&gt;задача&lt;/a&gt; на дерево отрезков.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ОСТОРОЖНО! СПОЙЛЕРЫ К РОИ! &lt;a href=&#34;https://contest.yandex.ru/roiarchive/contest/4284/problems/7/&#34;&gt;Эту задачу&lt;/a&gt; можно очень просто сдать на высокий балл при помощи дерева отрезков снизу. Такое решение ваигрывает у разреженных таблиц не смотря на то, что они отвечают на запрос за $O(1)$.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Sparse Table</title>
      <link>https://peltorator.ru/posts/sparse_table/</link>
      <pubDate>Wed, 15 Sep 2021 11:33:48 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/sparse_table/</guid>
      
      <description>&lt;p&gt;Sparse Table или разреженная таблица — это простая структура данных, которая позволяет за $O(1)$ отвечать на запросы поиска минимума и максимума на отрезке в неизменяющемся массиве. Минусом является то, что на ее построение уходит $O(n \log n)$ времени и памяти.&lt;/p&gt;
&lt;h2 id=&#34;идея&#34;&gt;Идея&lt;/h2&gt;
&lt;p&gt;Давайте рассматривать эту структуру на примере задачи поиска минимума на отрезке (RMQ). Для операции максимума все будет аналогично.&lt;/p&gt;
&lt;p&gt;Идея этой структуры кроется в ее названии: разреженная таблица. Что же это за таблица, и почему она разреженная? Под таблицей здесь понимается таблица, в которой хранятся ответы на все возможные запросы поиска минимума на отрезке. То есть квадрат, в котором по вертикали отложены все возможные левые границы, а по горизонтали все возможные правые границы. Имея такую таблицу, можно без труда отвечать на запросы поиска минимума на отрезке просто обращаясь к соответствующим полям нашей таблицы. Однако чтобы построить такую таблицу, нужно потратить $O(n^2)$ времени и памяти, что абсолютно недопустимо.&lt;/p&gt;
&lt;p&gt;В этот момент мы решаем, что хранить всю таблицу мы не будем, а будем хранить разреженную таблицу. То есть сохраним значения не для всех возможных отрезков, а только для некоторых. Однако это должны быть такие отрезки, чтобы из ответов для них можно было сконструировать ответ для любого отрезка. В обычной таблице любой отрезок уже был предпосчитан. Такого мы себе позволить не можем, но давайте сделаем немного более слабое условие: должно выполняться условие, что любой отрезок массива можно накрыть двумя предпосчитанными отрезками. Тогда минимум на отрезке — это минимум из двух минимумов на этих подотрезках. При этом эти подотрезки могут пересекаться. В этот момент как раз таки мы и воспользуемся тем, что мы ищем именно минимум на отрезке, а не сумму. Если бы мы искали сумму, то нам было бы необходимо, чтобы подотрезки, на которые мы разбиваем наш отрезок, не пересекались, иначе пересечение мы учтем дважды.&lt;/p&gt;
&lt;p&gt;Для минимума это непринципиально: если мы возьмем дважды минимум с одним и тем же числом, то результат не поменяется. Такое свойство операций называется идемпотентностью. Другие идемпотентные операции на отрезке тоже можно считать при помощи разреженных таблиц: максимум (аналогично минимуму), НОД ($gcd(a, a) = a$, однако вычисление НОДа двух чисел занимает неконстантное время, поэтому НОД на отрезке мы будем искать все таки не за $O(1)$, а за время работы одного вызова функции $gcd$) и т.д.&lt;/p&gt;
&lt;p&gt;Какие же отрезки нужно предпосчитать, чтобы любой отрезок запроса разбивался на два предпосчитанных отрезка, но при этом нам не нужно было предпосчитывать очень много всего? Давайте предпосчитаем минимум для всех отрезков, длины которых равны степени двойки. Сколько всего таких отрезков? Для каждой длины существует не более $n$ отрезков такой длины (при фиксированной длине у всех таких отрезков разные левые границы). При этом разных степеней двойки, не больших $n$, есть $\left\lfloor \log n \right\rfloor$ штук: $1$, $2$, $4$, $\ldots$, $2^{\left\lfloor \log n \right\rfloor}$. Так что наша структура будет занимать $O(n \log n)$ памяти.&lt;/p&gt;
&lt;p&gt;О том, как эту структуру построить и хранить, мы поговорим позже, а пока поймем, почему теперь любой отрезок разбивается на два предпосчитанных подотрезка. Пускай длина отрезка равна $len$. Пусть $2^k$ — это максимальная степень двойки, не бóльшая $len$. Тогда давайте возьмем один подотрезок длины $2^k$, начинающийся в левой границе отрезка, а другой — заканчивающийся в правой границе. Очевидно, что они будут полностью лежать внутри отрезка, потому что  $2^k \le len$, осталось понять, почему они полностью покрывают отрезок, то есть пересекаются. Действительно, если они не пересекаются, то внутри отрезка длины $len$ можно поместить два непересекающихся отрезка длины $2^k$, тогда длина отрезка не меньше, чем $2^k + 2^k = 2^{k + 1}$, но ведь мы взяли число $2^k$ так, чтобы это была максимальная степень двойки, не бóльшая $len$. Противоречие.&lt;/p&gt;
&lt;h2 id=&#34;построение&#34;&gt;Построение&lt;/h2&gt;
&lt;p&gt;Теперь поговорим про то, как мы будем строить и хранить эту структуру. Хранить мы ее будем в двумерном массиве размера $\log n \times n$. Для каждой степени двойки и для каждой левой границы сохраним минимум на соответствующем отрезке. Важно обратить внимание на то, что не для любой левой границы и степени двойки существует соответствующий отрезок. К примеру, для последнего индекса массива есть отрезок только длины $1$. У этой проблемы есть два решения: первое — просто игнорировать такие отрезки, потому что они нам все равно не понадобятся, второе — если отрезок вылезает за пределы массива, обрезать его концом массива. Конечно, не делать что-то легче, чем делать, поэтому мы выберем первый вариант, потому что эти отрезки все равно не используются.&lt;/p&gt;
&lt;p&gt;Теперь нужно понять, как быстро насчитать нашу разреженную таблицу. Заметим, что для построения можно воспользоваться идеей, похожей на идею поиска минимума на любом отрезке разбиением его на два маленьких. Действительно, любой отрезок длины $2^{k}$ — это два отрезка длины $2^{k - 1}$, поэтому нужно просто взять минимум из двух минимумов. Тогда если мы изначально определим, что минимумы на отрезках длины $1$ — это просто элементы изначального массива, а потом будем считать нашу таблицу по возрастанию степени двойки, то каждое значение можно будет посчитать за $O(1)$ по следующей формуле:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sparseTable[k][ind] = min(sparseTable[k - 1][ind], sparseTable[k - 1][ind + (1 &amp;lt;&amp;lt; (k - 1))])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Нам нужно найти минимум на полуинтервале $[ind, ind + 2^k)$, он разбивается на два полуинтервала: $[ind, ind + 2^{k - 1})$ и $[ind + 2^{k - 1}, ind + 2^k)$. И в принципе, в этой теме, как и в почти любой другой, лучше всего думать всегда про полуинтервалы, а не про отрезки, чтобы не запутаться.&lt;/p&gt;
&lt;p&gt;Давайте приведем полный код построения разреженной таблицы за $O(n \log n)$:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buildSparseTable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxpow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ceil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 2^{maxpow} &amp;gt; n
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sparse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maxpow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sparse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxpow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ind&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ind&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;sparse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sparse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sparse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ind&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sparse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Здесь для удобства выбран немного иной способ подсчета: мы пересчитываем не $k$-й слой через $k-1$-й, а $k+1$-й через $k$-й.&lt;/p&gt;
&lt;p&gt;Обратите внимание, что для полной корректности выбранного нами подхода условие цикла по $ind$ должно было выглядеть следующим образом:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ind + (1 &amp;lt;&amp;lt; (k + 1)) &amp;lt;= n&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;То есть полуинтервал $[ind, ind + 2^{k + 1})$ полностью лежит в границах массива. Однако мы ослабили это условие, посчитав некоторое количество лишних значений, однако мы все равно не используем такие значения при ответе на запрос, поэтому это никак не повлияет на работу нашей структуры. Но с другой стороны здесь нам не пришлось думать и вспоминать корректное условие. Все, о чем мы беспокоимся, — это то, чтобы индексы массива, через которые мы пересчитываем, были корректны. А так как мы обращаемся к индексу $ind + 2^k$, он должен быть меньше $n$.&lt;/p&gt;
&lt;p&gt;$maxpow$ можно выбрать любым способом, чтобы оно было строго больше $\log n$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Порядок циклов и размерностей в построении может очень сильно влиять на время исполнения программы из-за работы с кэшами. Предложенный вариант является оптимальным (примерно в 3-5 раз быстрее других вариантов).&lt;/p&gt;
&lt;h2 id=&#34;ответ-на-запрос&#34;&gt;Ответ на запрос&lt;/h2&gt;
&lt;p&gt;Для ответа на запрос нам надо найти ближайшую к длине отрезка степень двойки, а потом взять минимум из двух таких подотрезков. Не рекомендуется использовать для этого функцию логарифм, потому что она работает с вещественными числами, поэтому с ней можно легко ошибиться из-за точности. Можно заранее создать массив, в котором для каждого числа от $1$ до $n$ предпосчитать двоичный логарифм. Это делается следующим несложным кодом:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;logs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;logs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Действительно, целая часть двоичного логарифма — это то, сколько раз число надо поделить нацело на два, чтобы оно стало единицей. Это можно посчитать как раз такой динамикой: если числу $\left\lfloor \frac{i}{2} \right\rfloor$ нужно &lt;code&gt;logs[i &amp;gt;&amp;gt; 1]&lt;/code&gt; действий, то числу $i$ нужно на одно действие больше.&lt;/p&gt;
&lt;p&gt;Теперь можно и в построении $maxpow$ определять как &lt;code&gt;logs[n] + 1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Когда мы посчитали логарифмы, мы готовы написать функцию поиска минимума на полуинтервале:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;findMin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [l, r)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;power&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sparse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;power&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sparse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;power&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;power&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Очевидно, запрос поиска минимума работает за $O(1)$.&lt;/p&gt;
&lt;p&gt;Один из полуинтервалов, на которые мы разбиваем, должен начинаться в левой границе, а другой должен заканчиваться в правой, поэтому его левая граница, соответственно, должна быть на $2^{power}$ назад.&lt;/p&gt;
&lt;p&gt;Обратите внимание, что благодаря тому, что мы все считаем на полуинтервалах, у нас во всей функции нет ни одной $\pm 1$.&lt;/p&gt;
&lt;p&gt;Кроме того, есть трюк, которым можно воспользоваться в C++, чтобы не предпосчитывать логарифмы. Конечно, функцию &lt;code&gt;log2&lt;/code&gt; использовать не стоит, потому что она работает с числами с плавающей точкой, однако есть способ получить двоичный логарифм в целых числах. В этом нам поможет функция &lt;code&gt;__builtin_clz&lt;/code&gt;. &lt;code&gt;builtin&lt;/code&gt; означает &amp;laquo;встроенная&amp;raquo;, а &lt;code&gt;clz&lt;/code&gt; расшифровывается как &amp;laquo;count leading zeros&amp;raquo;, то есть количество ведущих нулей. Заметим, что количество ведущих нулей как раз таки совпадает с индексом первой единицы (в числе идет $k$ нулей, а после них стоит единица; это $k$-я позиция). А индекс старшей единицы — это как раз таки логарифм числа. Однако проблема в том, что в этом случае индекс считается с другой стороны: с самого старшего $31$ бита, а нам нужен индекс с самого младшего бита, поэтому для получения целой части двоичного логарифма числа $i$, нужно воспользоваться следующей формулой:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;31 - __builtin_clz(i)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Есть альтернатива — функция &lt;code&gt;__lg(i)&lt;/code&gt;, которая сразу возвращает целую часть логарифма, однако она есть не во всех компиляторах, поэтому будьте осторожны.&lt;/p&gt;
&lt;h2 id=&#34;применения&#34;&gt;Применения&lt;/h2&gt;
&lt;p&gt;Применять разреженные таблицы можно и просто для поиска минимума на отрезке как более простую альтернативу дереву отрезков, так и в специальных случаях. К примеру, можно свести задачу о поиске наименьшего общего предка в дереве к задаче RMQ по высотам на эйлеровом обходе дерева.&lt;/p&gt;
&lt;h2 id=&#34;разреженные-таблицы-для-поиска-суммы-на-отрезке&#34;&gt;Разреженные таблицы для поиска суммы на отрезке&lt;/h2&gt;
&lt;p&gt;Разреженные таблицы используют тот факт, что операция, которая считается на отрезке, идемпотентна, то есть если учесть один элемент два раза, ответ не поменяется. Однако такие операции как сумма не являются идемпотентными, поэтому из стандартных отрезков разреженных таблиц нельзя за $O(1)$ посчитать сумму на отрезке. Есть альтернативный более сложный вариант построения разреженных таблиц (Disjoint Sparse Table), который разбивает любой отрезок на два непересекающихся подотрезка.&lt;/p&gt;
&lt;p&gt;Однако сейчас давайте поймем, как искать сумму на отрезке при помощи стандартных разреженных таблиц за $O(\log n)$. Этот алгоритм будет похож на поиск предков в дереве при помощи бинарных подъемов. Давайте начнем с подотрезка, начинающегося в левой границе отрезка запроса, длины максимальной степени двойки и будем уменьшать степень, пока текущий подотрезок не попадет полностью внутрь отрезка запроса. После чего прибавим сумму на этом подотрезке к ответу и передвинем левую границу в конец этого подотрезка. Далее продолжим перебирать степени двойки по убыванию. Заметим, что если нам не подошла какая-то степень двойки, то далее она никогда нам не сможет подойти, потому что длина оставшегося отрезка запроса не увеличивается. Более того, набор взятых степеней двоек вовсе строго убывает. Действительно, если бы мы дважды взяли подотрезки длины $2^k$, вместо этого можно было бы взять один подотрезок длины $2^{k + 1}$, но мы этого почему-то не сделали. Так что весь отрезок запроса разобьется на набор непересекающихся подотрезков различных длин. Всего таких подотрезков будет не больше логарифма, потому что всего разных степеней двоек есть логарифм.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Если начинать поиск не с самой большой степени двойки, а с самой большой степени двойки, которая не больше длины отрезка (&lt;code&gt;power&lt;/code&gt; из поиска минимума на отрезке), то асимптотика ответа на запрос будет $O(\log len)$, где $len$ — длина отрезка запроса, что, конечно, в общем случае то же самое, что и $O(\log n)$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;findSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [l, r)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;power&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;power&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;power&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;power&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sparse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;power&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;power&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;многомерные-разреженные-таблицы&#34;&gt;Многомерные разреженные таблицы&lt;/h2&gt;
&lt;p&gt;Большим плюсом разреженных таблиц является простота их применения в многомерных случаях. Для примера рассмотрим двумерный случай, для б&#39;{о}льших размерностей все будет аналогично.&lt;/p&gt;
&lt;p&gt;Если раньше отрезок длины $n$ мы покрывали двумя подотрезками длины $2^k$, где $2^k$ — ближайшая к $n$ степень двойки, то теперь прямоугольник размера $n \times m$ мы накроем четырьмя подпрямоугольниками размера $2^k \times 2^l$ (ближайшие степени двойки к $n$ и $m$ соответственно), расположенными в углах прямоугольника запроса. То есть мы накрываем вертикальный отрезок длины $n$ двумя подотрезками длины $2^k$, накрываем горизонтальный отрезок длины $m$ двумя подотрезками длины $2^l$, и берем прямоугольники, полученные из всевозможных пар вертикальных и горизонтальных отрезков.&lt;/p&gt;
&lt;p&gt;Построение двумерной разреженной таблицы можно устроить множеством разных способов. К примеру, можно сначала построить одномерные разреженные таблицы по одной координате для каждой строки, а затем построить двумерную разреженную таблицу на этих одномерных.&lt;/p&gt;
&lt;p&gt;Запрос нахождения минимума на прямоугольнике аналогичен одномерному случаю. В нем мы находим две координаты по одной оси, две координаты по другой и берем минимум среди подпрямоугольников, полученных всеми возможными их парами.&lt;/p&gt;
&lt;p&gt;Очевидно, построение такой структуры будет занимать $O(n \cdot m \cdot \log n \cdot \log m)$ времени, а ответ на запрос все еще будет работать за $O(1)$.&lt;/p&gt;
&lt;p&gt;С реализацией можно ознакомиться по &lt;a href=&#34;https://pastebin.com/1b7HWCPB&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;задачи-для-практики&#34;&gt;Задачи для практики&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://informatics.msk.ru/mod/statements/view.php?id=597#1&#34;&gt;Задача&lt;/a&gt; на поиск максимума и индекса этого максимума на отрезке.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Задачу E &lt;a href=&#34;https://codeforces.com/gym/100093&#34;&gt;этого контеста&lt;/a&gt; сложно решить чем-то кроме разреженных таблиц.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Задачи на Disjoint Sparse Table можно прорешать в специально подготовленном &lt;a href=&#34;https://codeforces.com/group/1rv4rhCsHp/contest/102954&#34;&gt;контесте&lt;/a&gt; на codeforces.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Префиксные суммы</title>
      <link>https://peltorator.ru/posts/prefix_sums/</link>
      <pubDate>Wed, 15 Sep 2021 10:24:12 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/prefix_sums/</guid>
      
      <description>&lt;!--- TODO: возможно, нужно заменить математическую нотацию индексов на программистскую: b_i -&gt; b[i]--&gt;
&lt;!--- TODO: заменить желтый цвет на какой-то другой, потому что его не видно---&gt;
&lt;!--- TODO: можно картинки сделать побольше---&gt;
&lt;h2 id=&#34;определения-основы-и-сила-полуинтервалов&#34;&gt;Определения, основы и сила полуинтервалов&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Определение:&lt;/strong&gt;
&lt;strong&gt;Префиксными суммами&lt;/strong&gt; массива $[a_0, a_1, a_2, \ldots, a_{n - 1}]$ называется массив $[b_0, b_1, b_2, \ldots, b_n]$, определяющийся следующим образом:&lt;/p&gt;
&lt;p&gt;$b_0 = 0$&lt;/p&gt;
&lt;p&gt;$b_1 = a_0$&lt;/p&gt;
&lt;p&gt;$b_2 = a_0 + a_1$&lt;/p&gt;
&lt;p&gt;$b_3 = a_0 + a_1 + a_2$&lt;/p&gt;
&lt;p&gt;$\ldots$&lt;/p&gt;
&lt;p&gt;$b_{n - 1} = a_0 + a_1 + \ldots + a_{n - 2}$&lt;/p&gt;
&lt;p&gt;$b_n = a_0 + a_1 + \ldots + a_{n - 1}$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание: (Сила полуинтервалов)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Обратите внимание на то, что $b_i$ — это сумма первых $i$ элементов массива $a$. Иногда префиксные суммы определяют так, что $b_i = a_0 + a_1 + \ldots + a_i$, но этот способ неудобен на практике, в чем мы убедимся далее.&lt;/p&gt;
&lt;p&gt;На данном примере можно познакомиться с очень важной концепцией в алгоритмах: практически всегда вместо отрезков лучше использовать полуинтервалы. К примеру, в данном случае $b_i$ — это сумма элементов массива $a$ на полуинтервале $[0, i)$, что на практике окажется удобнее, чем хранить в $b_i$ сумму на отрезке $[0, i]$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Также стоит помнить о том, что длина массива $b$ на один больше длины массива $a$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Формулу для $b_i$ можно записать рекуррентно:&lt;/p&gt;
&lt;p&gt;$b_0 = 0$&lt;/p&gt;
&lt;p&gt;$b_{i + 1} = b_{i} + a_{i},$ где $i \ge 0$&lt;/p&gt;
&lt;p&gt;Из рекуррентной формулы сразу становится ясно, как посчитать массив префиксных сумм за $O(n)$:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findPrefixSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;prefixSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Обратите внимание, что элементы массива префиксных сумм — это суммы большого количества элементов исходного массива, поэтому будьте аккуратнее с переполнением. И вообще, на протяжении всей этой темы вы можете столкнуться с переполнением, поэтому будьте всегда начеку! Возможно, вам нужен тип &lt;code&gt;long long&lt;/code&gt; вместо &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Кроме того, есть встроенная в C++ функция &lt;code&gt;std::partial_sum&lt;/code&gt;, которая как раз таки считает префиксные суммы. Пример ее работы:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findPrefixSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;partial_sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Обратите внимание, что сама функция &lt;code&gt;partial_sum&lt;/code&gt; не оставляет нуля в начале, поэтому нам приходится делать это самим, добавляя единицу к &lt;code&gt;prefixSums.begin()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Пояснение:&lt;/strong&gt;
У нас уже есть две интуиции для понимания $b_i$: сумма первых $i$ элементов исходного массива и сумма элементов исходного массива на полуинтервале $[0, i)$. Давайте посмотрим на еще один вариант того, как об этом можно думать. Можно представить, что элементы массива находятся в ячейках, а префиксные суммы находятся между ними — на перегородках. И содержат в себе суммы всего того, что находится перед этой перегородкой.&lt;/p&gt;
&lt;script type=&#34;text/tikz&#34;&gt;
\begin{tikzpicture}
\foreach \n [count=\x] in {5, 4, 7, 2, 2, 1, 8}
  \node[rectangle, minimum size=9mm, draw] at (\x, 0) {$\n$};

\foreach \s [count=\x] in {0, 5, 9, 16, 18, 20, 21, 29}
  \node[below] at (\x-.5, -.5) {$\s$};
\end{tikzpicture}
&lt;/script&gt;
&lt;!---&lt;span style=&#34;color:red&#34;&gt;TODO: Почему-то вместо -1 показывается £1&lt;/span&gt;---&gt;
&lt;h2 id=&#34;базовое-применение&#34;&gt;Базовое применение&lt;/h2&gt;
&lt;p&gt;Давайте сразу же применим префиксные суммы на примере задачи.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача:&lt;/strong&gt;
Дан массив целых чисел, и приходят запросы вида &amp;laquo;найти сумму на полуинтервале с позиции $l$ до позиции $r$&amp;raquo;. Нужно отвечать на запросы за $O(1)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Решение:&lt;/strong&gt;
Давайте изначально перед ответами на запросы предпосчитаем массив префиксных сумм. Тогда если бы во всех запросах $l$ было равно нулю, то ответом на запрос была бы просто префиксная сумма $b_{r}$.&lt;/p&gt;
&lt;p&gt;Но как же действовать, если $l \neq 0$? В префиксной сумме $b_{r}$ содержатся все нужные нам элементы, однако есть еще лишние: $a_0, a_1, \ldots, a_{l - 1}$. Но ведь сумма этих элементов — это как раз таки $b_l$. Таким образом, выполнено тождество:&lt;/p&gt;
&lt;p&gt;$$
a_{l} + a_{l + 1} + \ldots + a_{r - 1} = b_{r} - b_{l}
$$&lt;/p&gt;
&lt;p&gt;То есть для ответа на запрос поиска суммы на полуинтервале нужно просто вычесть друг из друга две предпосчитанные префиксные суммы.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [left, right)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Обратите внимание на то, какие красивые формулы у нас получаются: сумма на полуинтервале $[l, r)$ — это $b_r - b_l$. Такая красота достигается именно благодаря тому, что мы используем полуинтервалы: и запросы у нас даны в виде полуинтервалов, и префиксные суммы. Если бы префиксные суммы были посчитаны в виде $b_i = a_0 + a_1 + \ldots + a_i$, то в формуле появились бы неприятные $\pm 1$, в которых легко запутаться: $b_r - b_{l - 1}$, и случай, когда $l = 0$, стал бы крайним, его надо было бы разбирать отдельно.&lt;/p&gt;
&lt;h2 id=&#34;а-что-кроме-суммы&#34;&gt;А что кроме суммы?&lt;/h2&gt;
&lt;p&gt;Давайте зададимся вопросом: для каких операций можно использовать префиксные суммы? Не только же для сложения? Какими свойствами должна обладать операция, чтобы можно было воспользоваться префиксными суммами?&lt;/p&gt;
&lt;p&gt;На самом деле, необходимо, чтобы функция, которую мы считаем на отрезке, была обратима, что равносильно тому, что должна быть возможность по двум префиксам восстановить значение на отрезке. К примеру, операция суммы обратима, потому что если мы прибавили лишнее, потом это можно вычесть. А операции минимума и максимума необратимы. Нельзя по значениям минимумов на префиксах получить значение минимума на отрезке. К примеру, если элемент на позиции $0$ в массиве самый маленький, то все префиксные минимумы будут равны этому элементу, но минимумы на каких-то отрезках совсем с ним не связаны.&lt;/p&gt;
&lt;!---
&lt;script type=&#34;text/tikz&#34;&gt;
\begin{tikzpicture}
\foreach \n [count=\x] in {0, 4, 3, 2, 8, 2, 7}
\ifthenelse{\x &gt; 2 \AND \x &lt; 7}{\node[rectangle, blue, draw]}{\node[rectangle, draw]} at (\x, 0) {$\n$};

\end{tikzpicture}
&lt;/script&gt;

&lt;script type=&#34;text/tikz&#34;&gt;
\begin{tikzpicture}
\foreach \n [count=\x] in {0, 4, 3, 2, 8, 2, 7}
\ifthenelse{\x &gt; 2 \AND \x &lt; 7}{\node[rectangle, minimum size=9mm, blue, draw]}{\node[rectangle, minimum size=9mm, draw]} at (\x, 0) {$\n$};

\foreach \s [count=\x] in {$+\infty$, $0$, $0$, $0$, $0$, $0$, $0$, $0$}
\ifthenelse{\equal{\x}{3} OR \equal{\x}{7}}{\node[below, rectangle, red, minimum size=4.mm, draw] at (\x-.5, -.5) {\textcolor{red}{\s}}}{\node[below] at (\x-.5, -.5) {\s}};

\draw [decorate, blue, decoration={brace}]
(2.5,0.55) -- (6.5,0.55) node [midway,above]
{\footnotesize $\min = 2$};
\end{tikzpicture}
&lt;/script&gt;

&lt;span style=&#34;color:red&#34;&gt;TODO: Почему-то не отображается картинка tikz&lt;/span&gt;
---&gt;
&lt;p&gt;&lt;img src=&#34;https://peltorator.ru/try_web/images/prefix_sums_min.svg&#34; alt=&#34;test&#34;&gt;&lt;/p&gt;
&lt;p&gt;Но кроме суммы есть и другие операции, которые являются обратимыми. Одна из самых популярных — это, пожалуй, операция &amp;laquo;побитового исключающего или&amp;raquo; (Подробнее про эту операцию можно прочитать &lt;a href=&#34;https://learn.javascript.ru/bitwise-operators#isklyuchayuschee-ili&#34;&gt;здесь&lt;/a&gt;), которая еще называется &amp;laquo;&lt;code&gt;xor&lt;/code&gt;&amp;raquo; и обозначается $\oplus$.&lt;/p&gt;
&lt;p&gt;При этом для &lt;code&gt;xor&lt;/code&gt;&amp;lsquo;а пользоваться префиксными суммами еще удобнее. Выполнено тождество $x \oplus x = 0$ для любого числа $x$, что означает, что операция &lt;code&gt;xor&lt;/code&gt; обратна сама себе, так что формула вычисления побитового исключающего или на отрезке получается такая:&lt;/p&gt;
&lt;p&gt;$$
a_l \oplus a_{l + 1} \oplus \ldots \oplus a_{r - 1} = b_r \oplus b_l
$$&lt;/p&gt;
&lt;h2 id=&#34;продвинутые-применения&#34;&gt;Продвинутые применения&lt;/h2&gt;
&lt;p&gt;Давайте решим еще пару задач, в которых нам понадобятся префиксные суммы.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача:&lt;/strong&gt;
Дан массив. Необходимо за $O(n \log n)$ найти любой его непустой подотрезок с нулевой суммой элементов.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Решение:&lt;/strong&gt;
Как мы уже знаем, суммы на отрезках — это разности префиксных сумм. Поэтому то, что сумма на отрезке равна нулю, равносильно тому, что префиксные суммы его концов равны.&lt;/p&gt;
&lt;p&gt;Таким образом, мы свели задачу нахождения подотрезка нулевой суммы к задаче нахождения двух одинаковых элементов в массиве префиксных сумм. Для этого можно, к примеру, отсортировать массив префиксных сумм и искать совпадающие элементы среди соседних.
Либо же можно воспользоваться хеш-таблицей (&lt;code&gt;unordered_map&lt;/code&gt; в C++), и тогда асимптотика решения будет вовсе $O(n)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Упражнение:&lt;/strong&gt;
Даны два массива одинаковой длины. Необходимо найти такой подотрезок, чтобы сумма элементов первого массива на этом подотрезке совпадала с суммой элементов второго массива на этом подотрезке. Асимптотика $O(n)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача:&lt;/strong&gt;
Кузнечик находится в клетке с индексом $0$ и хочет попасть в клетку с индексом $n$. За один прыжок кузнечик может переместиться на любое количество клеток вперед, но при этом не меньше $l$ и не больше $r$. Найдите, сколько существует маршрутов кузнечика. Асимптотика $O(n)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Решение:&lt;/strong&gt;
Задача очень похожа на стандартную задачу о кузнечике, однако в ней прыжки имели длину $1$ и $2$, а теперь у нас количество разных прыжков не ограничено, поэтому такое же решение будет работать за $O(n \cdot (r - l))$, что в худшем случае будет $O(n^2)$.&lt;/p&gt;
&lt;p&gt;Давайте внимательно посмотрим на формулу пересчета динамики. Количество способов попасть в клетку $i$ — это сумма количеств способов попасть во все предыдущие клетки на пути кузнечика:&lt;/p&gt;
&lt;p&gt;$$
dp_i = dp_{i - r} + dp_{i - r + 1} + \ldots + dp_{i - l - 1} + dp_{i - l}
$$&lt;/p&gt;
&lt;p&gt;То есть элемент массива $dp$ определяется через сумму отрезка элементов того же массива. Давайте идти по позициям в порядке возрастания и не только насчитывать массив $dp$, но и его префиксные суммы. Тогда пересчет $dp_i$ через префиксные суммы будет работать за $O(1)$, а асимптотика всего алгоритма — $O(n)$.&lt;/p&gt;
&lt;p&gt;Таким образом, мы видим, что в задачах необязательно предпосчитывать массив префиксных сумм заранее, он может строиться по ходу решения задачи и одновременно с этим использоваться.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Префиксные суммы очень удобны для подсчета суммы на отрезке в том случае, если массив в ходе запросов не меняется. Потому если какой-то элемент массива поменялся, то нужно пересчитать все префиксные суммы, в которые он входит. Это очень долго! Если есть запросы изменения, то лучше подойдут более продвинутые структуры данных: к примеру, дерево отрезков и дерево Фенвика.&lt;/p&gt;
&lt;h2 id=&#34;двумерный-случай&#34;&gt;Двумерный случай&lt;/h2&gt;
&lt;p&gt;Мы уже научились искать сумму на отрезке в одномерном массиве при помощи префиксных сумм, но префиксные суммы легко обобщаются и на бóльшие размерности. Давайте научимся искать сумму на прямоугольнике в двумерном массиве. Пусть нам дан двумерный массив $a_{i, j}$.
Определим его префиксные суммы так:&lt;/p&gt;
&lt;p&gt;$$
b_{i + 1, j + 1} = \sum_{x \le i} \ \sum_{y \le j} a_{x, y} = a_{0, 0} + a_{0, 1} + a_{0, 2} + \ldots + a_{0, j} + a_{1, 0} + a_{1, 1} + \ldots + a_{1, j} + \ldots + a_{i, 0} + a_{i, 1} + \ldots + a_{i, j}
$$&lt;/p&gt;
&lt;p&gt;Для двумерных префиксных сумм тоже полезно представлять, что они находятся между значениями исходного массива в узлах сетки и отвечают за сумму всего, что выше и левее этой точки.&lt;/p&gt;
&lt;p&gt;Можно воспринимать происходящее, как будто мы построили префиксные суммы по одной координате, а затем посчитали префиксные суммы префиксных сумм по другой координате.&lt;/p&gt;
&lt;!---
&lt;span style=&#34;color:red&#34;&gt;TODO: На белом фоне желтый цвет вообще не видно&lt;/span&gt;

&lt;script type=&#34;text/tikz&#34;&gt;
\begin{tikzpicture}
\foreach \n in {0, 1, 2, 3, 4, 5}
\foreach \col [count=\m, evaluate=\col as \prog (initially 0) using int(6 * (\m - 1) + \n + 1)] in {green, yellow, red, blue, black, black}
    \ifthenelse{\n &lt; 3}{\node[color=\col, rectangle, minimum size=7.5mm, draw]}{\node[rectangle, minimum size=7.5mm, draw]} at (\n * 1.2, -\m * 1.2 + 1.2) {$\prog$};

\foreach \col [count=\x, evaluate=\col as \prog (initially 0) using int(\x * 18 - 12)] in {green, yellow, red, blue}
\node[font=\small, color=\col] at (2.5 * 1.2, -\x * 1.2 + 1.2) {$\prog$};

\foreach \s in {1, 2, 3}
\node[font=\small, color=purple] at (2.5 * 1.2, -\s * 1.2 + 1.2 * 0.5) {$+$};

\node[font=\small, color=purple] at (2.5 * 1.2, -3.25 * 1.2) {$=$};

\node[color=purple] at (2.5 * 1.2, -3.5 * 1.2) {$132$};
\end{tikzpicture}
&lt;/script&gt;

&lt;span style=&#34;color:red&#34;&gt;TODO: Почему-то не отображается картинка tikz&lt;/span&gt;
---&gt;
&lt;p&gt;&lt;img src=&#34;https://peltorator.ru/try_web/images/prefix_sums_2d_1d.svg&#34; alt=&#34;test&#34;&gt;&lt;/p&gt;
&lt;p&gt;Таким образом, можно насчитать префиксные суммы на одномерных массивах, а потом насчитать префиксные суммы на массивах префиксных сумм.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findPrefixSums2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSum1D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;prefixSum1D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findPrefixSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSum2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;prefixSum2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSum2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSum1D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSum2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Альтернативный вариант подсчета префиксных сумм — вновь воспользоваться рекуррентной формулой. Это будет немного сложнее, чем в одномерном случае. Формула выглядит следующим образом:&lt;/p&gt;
&lt;p&gt;$$
b_{i + 1, j + 1} = b_{i, j + 1} + b_{i + 1, j} - b_{i, j} + a_{i, j}
$$&lt;/p&gt;
&lt;p&gt;Эту формулу легко понять из картинки (зеленая область также принадлежит синей и желтой):&lt;/p&gt;
&lt;p&gt;$$\textcolor{purple}{?}=\textcolor{blue}{y}+\textcolor{yellow}{z}-\textcolor{green}{x}+\textcolor{red}{a[i][j]}$$&lt;/p&gt;
&lt;!---
&lt;script type=&#34;text/tikz&#34;&gt;
\begin{tikzpicture}
\foreach \n in {0, 1, 2, 3, 4, 5, 6, 7}
\foreach \m in {0, 1, 2, 3, 4}
\ifthenelse{\n &lt; 5 \AND \m &lt; 3}{\node[rectangle, color=green, minimum size=7.5mm, draw]}{\ifthenelse{\equal{\n}{5} \AND \m &lt; 3}{\node[rectangle, color=blue, minimum size=7.5mm, draw]}{\ifthenelse{\equal{\m}{3} \AND \n &lt; 5}{\node[rectangle, color=yellow, minimum size=7.5mm, draw]}{\ifthenelse{\equal{\m}{3} \AND \equal{\n}{5}}{\node[rectangle, color=red, minimum size=7.5mm, draw]}{\node[rectangle, minimum size=7.5mm, draw]}}}} at (\n * 1.2, -\m * 1.2) {};
    %\ifthenelse{\n &lt; 3}{\node[color=\col, rectangle, minimum size=7.5mm, draw]}{\node[rectangle, minimum size=7.5mm, draw]} at (\n * 1.2, -\m * 1.2 + 1.2) {$\prog$};

\node[font=\small, color=green] at (4.5 * 1.2, -2.5 * 1.2) {$x$};
\node[font=\small, color=blue] at (5.5 * 1.2, -2.5 * 1.2) {$y$};
\node[font=\small, color=yellow] at (4.5 * 1.2, -3.5 * 1.2) {$z$};
\node[font=\small, color=purple] at (5.5 * 1.2, -3.5 * 1.2) {$?$};
 \end{tikzpicture}
&lt;/script&gt;

&lt;span style=&#34;color:red&#34;&gt;TODO: Почему-то не отображается картинка tikz&lt;/span&gt;
---&gt;
&lt;p&gt;&lt;img src=&#34;https://peltorator.ru/try_web/images/prefix_sums_2d_include_exclude.svg&#34; alt=&#34;test&#34;&gt;&lt;/p&gt;
&lt;p&gt;Мы берем сумму двух меньших префиксных сумм, которые накрывают нашу, однако их пересечение учтется дважды, поэтому его надо вычесть. Но ведь это пересечение — это и есть $b_{i, j}$. И в конце стоит не забыть прибавить новый элемент — $a_{i, j}$.&lt;/p&gt;
&lt;p&gt;Элементы, через которые мы считаем $b_{i + 1, j + 1}$ имеют меньшие индексы, поэтому подсчет двумерных префиксных сумм можно вести просто двумя вложенными циклами по возрастанию.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findPrefixSums2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;prefixSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prefixSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Теперь пускай нам надо найти сумму на &amp;laquo;полупрямоугольнике&amp;raquo; (двумерный полуинтервал) с противоположными углами в точках $(lx, ly)$ и $(rx, ry)$ (левые границы — включительно, правые — исключительно). Сумма элементов на этом полупрямоугольнике будет выражаться так:
$$
\sum_{lx \le i &amp;lt; rx} \ \sum_{ly \le j &amp;lt; ry} a_{i, j} = b_{rx, ry} - b_{lx, ry} - b_{rx, ly} + b_{lx, ly}
$$&lt;/p&gt;
&lt;p&gt;Эту формулу также легче понимать, смотря на картинку:&lt;/p&gt;
&lt;p&gt;$$sum=\textcolor{purple}{b[rx][ry]}-\textcolor{blue}{b[lx][ry]}-\textcolor{yellow}{b[rx][ly]}+\textcolor{green}{b[lx][ly]}$$&lt;/p&gt;
&lt;!---
&lt;script type=&#34;text/tikz&#34;&gt;
\begin{tikzpicture}
\foreach \n in {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}
\foreach \m in {0, 1, 2, 3, 4, 5, 6, 7}
\ifthenelse{\n &gt; 5 \AND \n &lt; 12 \AND \m &gt; 1 \AND \m &lt; 6}{\node[rectangle, color=purple, minimum size=4.5mm, draw]}{\node[rectangle, minimum size=4.5mm, draw]} at (\n * 0.7, -\m * 0.7) {};

\draw[color=orange, thick] (5.5 * 0.7, -1.5 * 0.7) -- (5.5 * 0.7, -5.5 * 0.7) -- (11.5 * 0.7, -5.5 * 0.7) -- (11.5 * 0.7, -1.5 * 0.7) -- cycle;

\node[circle, fill=green, draw, inner sep=1.7pt, color=green] at (5.5 * 0.7, -1.5 * 0.7) {};
\node[circle, fill=yellow, draw, inner sep=1.7pt, color=yellow] at (5.5 * 0.7, -5.5 * 0.7) {};
\node[circle, fill=blue, draw, inner sep=1.7pt, color=blue] at (11.5 * 0.7, -1.5 * 0.7) {};
\node[circle, fill=purple, draw, inner sep=1.7pt, color=purple] at (11.5 * 0.7, -5.5 * 0.7) {};

\draw[-&gt;] (-0.4, -0.3) -- (-0.4, -0.3 - 6 * 0.7) node [midway, left] (TextNode) {$x$};
\draw[-&gt;] (-0.4 + 0.7, -0.5 - 7 * 0.7) -- (-0.4 + 0.7 * 14, -0.5 - 7 * 0.7) node [midway, below] (TextNode2) {$y$};
\end{tikzpicture}
&lt;/script&gt;

&lt;span style=&#34;color:red&#34;&gt;TODO: Почему-то не отображается картинка tikz&lt;/span&gt;
---&gt;
&lt;p&gt;&lt;img src=&#34;https://peltorator.ru/try_web/images/prefix_sums_2d_include_exclude_get.svg&#34; alt=&#34;test&#34;&gt;&lt;/p&gt;
&lt;p&gt;Сначала мы взяли большой прямоугольник, который накрывает нужный нам, потом удалили ненужное слева и сверху, но то, что находится на их пересечении, мы удалили дважды, так что надо вернуть это пересечение назад.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Именно в двумерном случае, а также больших размерностях становится видна мощь полуинтервалов. В формуле нет ни одной цифры ($\pm 1$). Мы просто берем префиксные суммы на краях и складываем и вычитаем их.&lt;/p&gt;
&lt;p&gt;Если бы мы определяли $b_{i, j}$ как сумму на отрезке, то есть $\sum_{x \le i} \sum_{y \le j} a_{x, y}$, то формула для суммы на прямоугольнике выглядела бы следующим образом:&lt;/p&gt;
&lt;p&gt;$$
b_{rx, ry} - b_{lx - 1, ry} - b_{rx, ly - 1} + b_{lx - 1, ly - 1}
$$&lt;/p&gt;
&lt;p&gt;Вероятность написать эти формулы правильно постепенно стремится к нулю.&lt;/p&gt;
&lt;h2 id=&#34;трехмерный-случай&#34;&gt;Трехмерный случай&lt;/h2&gt;
&lt;p&gt;Мы разобрались с двумерным случаем, теперь пойдем еще дальше! Префиксные суммы на трехмерном массиве определяются аналогично:&lt;/p&gt;
&lt;p&gt;$$
b_{i + 1, j + 1, k + 1} = \sum_{x \le i} \ \sum_{y \le j} \ \sum_{z \le k} a_{x, y, z}
$$&lt;/p&gt;
&lt;p&gt;Рекурентная формула для их подсчета будет такая:&lt;/p&gt;
&lt;p&gt;$$
b_{i + 1, j + 1, k + 1} = b_{i, j + 1, k + 1} + b_{i + 1, j, k + 1} + b_{i + 1, j + 1, k} - b_{i + 1, j, k} - b_{i, j + 1, k} - b_{i, j, k + 1} + b_{i, j, k} + a_{i, j, k}
$$&lt;/p&gt;
&lt;p&gt;И для поиска суммы на &amp;laquo;полупараллелепипеде&amp;raquo; (трехмерном полуинтервале) с противоположными углами в точках $(lx, ly, lz)$ и $(rx, ry, rz)$ подойдет следующая формула:&lt;/p&gt;
&lt;p&gt;$$
\sum_{lx \le i &amp;lt; rx} \ \sum_{ly \le j &amp;lt; ry} \ \sum_{lz \le k &amp;lt; rz} a_{i, j, k} = b_{rx, ry, rz} - b_{lx, ry, rz} - b_{rx, ly, rz} - b_{rx, ry, lz} + b_{rx, ly, lz} + b_{lx, ry, lz} + b_{lx, ly, rz} - b_{lx, ly, lz}
$$&lt;/p&gt;
&lt;p&gt;Формулы страшные! Но показываю я вам их для того, чтобы сформулировать правила, по которым они работают в общем случае для любой размерности. Потому что если у вас есть пространственное мышление, то по картинке придумать формулу для трехмерного случая вы еще сможете, а вот для четырехмерного уже вряд ли.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема:&lt;/strong&gt;
В рекуррентной формуле подсчета префиксных сумм мы берем комбинацию всех возможных вариантов вычитания единиц из индексов. При этом если мы вычли нечетное количество единиц, то слагаемое идет с плюсом, а если четное, то с минусом. В конце нужно не забыть еще прибавить один новый элемент изначального массива $a$.&lt;/p&gt;
&lt;p&gt;Понять, почему именно нечетное с плюсом, можно по тому, что мы точно знаем, что слагаемые, в которых всего из одной координаты вычли единицу, должны идти с плюсом, ведь при их помощи мы накрываем изначально нашу префиксную сумму, а потом уже остальными пытаемся ее корректировать.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема:&lt;/strong&gt;
Аналогичное правило есть и для формулы поиска суммы на полупараллелепипеде. Берется сумма всевозможных комбинаций левых и правых границ по каждой координате, при этом если левых границ четное количество, то слагаемое берется с плюсом, а если нечетное, то с минусом.&lt;/p&gt;
&lt;p&gt;Опять же, понять, почему именно четное с плюсом, а нечетное с минусом, очень легко: слагаемое, в котором все границы правые — это самое большое слагаемое, которое мы потом корректируем, так что оно точно должно быть с плюсом.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Упражнение:&lt;/strong&gt;
При помощи этих двух незатейливых правил попробуйте составить формулы для построения префиксных сумм и поиска суммы на (полу)гиперпрямоугольнике в четырехмерном пространстве.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Трехмерный префиксный массив можно насчитать другим способом так же как и двумерный: сначала посчитать одномерные префиксные суммы, потом на них насчитать двумерные и затем уже на них посчитать трехмерные.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Если вы знаете, что такое формула включений-исключений, то в каком-то смысле именно она и применяется при построении и при ответе на запросы в многомерных префиксных суммах.&lt;/p&gt;
&lt;h2 id=&#34;разностный-массив&#34;&gt;Разностный массив&lt;/h2&gt;
&lt;p&gt;Мы уже научились по массиву строить его массив префиксных сумм. А теперь давайте научимся по массиву префиксных сумм строить исходный массив, то есть применять обратную операцию.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Определение:&lt;/strong&gt;
&lt;strong&gt;Разностным массивом&lt;/strong&gt; массива $[b_0, b_1, \ldots, b_{n - 1}]$ называется массив $[a_0, a_1, \ldots, a_{n - 2}]$, определяющийся следующим образом:&lt;/p&gt;
&lt;p&gt;$a_0 = b_1 - b_0$&lt;/p&gt;
&lt;p&gt;$a_1 = b_2 - b_1$&lt;/p&gt;
&lt;p&gt;$a_2 = b_3 - b_2$&lt;/p&gt;
&lt;p&gt;$\ldots$&lt;/p&gt;
&lt;p&gt;$a_{n - 3} = b_{n - 2} - b_{n - 3}$&lt;/p&gt;
&lt;p&gt;$a_{n - 2} = b_{n - 1} - b_{n - 2}$&lt;/p&gt;
&lt;p&gt;Очевидно, что если $b$ — массив префиксных сумм массива $a$, то массив $a$ — разностный массив массива $b$, потому что формула $a_i = b_{i + 1} - b_i$ — это просто преобразованная рекуррентная формула для поиска префиксных сумм: $b_{i + 1} = b_i + a_i$.
Однако разностный массив может помочь нам даже там, где массивом префиксных сумм и не пахнет!
Также обратите внимание, что если для подсчета массива префиксных сумм была нужна рекуррентная формула, то каждый член разностного массива зависит всего от двух элементов исходного, так что можно пользоваться формулами из определения для подсчета разностного массива за $O(n)$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findDiffsArray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;diffs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;diffs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;diffs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Если вы знакомы с основами матанализа, можно заметить, что переход к разностному массиву — это дискретное дифференцирование, а переход к массиву префиксных сумм — дискретное интегрирование.&lt;/p&gt;
&lt;h2 id=&#34;применения-разностного-массива&#34;&gt;Применения разностного массива&lt;/h2&gt;
&lt;p&gt;Решим несколько задач, используя разностный массив. Мы уже решили задачу нахождения суммы на отрезке при помощи префиксных сумм, а теперь рассмотрим в некотором смысле обратную задачу: задачу о прибавлении на отрезке.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача:&lt;/strong&gt;
Дан массив длины $n$. Приходят $q$ запросов: прибавить на полуинтервале $[l, r)$ ко всем элементам число $d$. После выполнения всех запросов необходимо вывести получившийся массив. Асимптотика $O(n + q)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Решение:&lt;/strong&gt;
Ранее в одном из замечаний мы говорили о том, что если элементы массива меняются, то для решения задачи понадобятся продвинутые структуры, такие как дерево отрезков или дерево Фенвика. Однако здесь мы обойдемся без них, потому что у нас есть только запросы изменения, а запрос &amp;laquo;получения&amp;raquo; есть только один в самом конце.&lt;/p&gt;
&lt;p&gt;Давайте в начало исходного массива $b$ допишем фиктивный элемент ноль и у получившегося массива возьмем разностный массив $a$. После чего будем наблюдать за тем, как этот массив $a$ будет меняться в следствии запросов изменения массива $b$ на отрезке.
Фиктивный ноль мы добавили для того, чтобы не потерять информацию о нулевом элементе массива $b$, ведь только по разностям соседних элементов восстановить исходный массив не получится.&lt;/p&gt;
&lt;p&gt;Пускай на полуинтервале $[l, r)$ исходного массива (или на полуинтервале $[l + 1, r + 1)$ массива с фиктивным нулем в начале) прибавили ко всем элементам $d$.
Заметим, что элементы массива $a$ на позициях меньших $l$ и больших $r$ никак не поменяются, потому что оба элемента в разности никак не поменялись. На позициях $l + 1, \ldots, r - 1$ тоже ничего не поменяется, потому что к обоим элементам разности прибавят $d$, в результате чего сама разность не изменится. К примеру, для позиции $l + 1$:&lt;/p&gt;
&lt;p&gt;$$b^{new}_{l + 1} - b^{new}_l = \left(b^{old}_{l + 1} + d\right) - \left(b^{old}_l + d\right) = b^{old}_{l + 1} + d - b^{old}_l - d = b^{old}_{l + 1} - b^{old}_l$$&lt;/p&gt;
&lt;p&gt;Таким образом, после операции прибавления на отрезке изменятся только два элемента разностного массива: $a_{l}$ заменится на $a_{l} + d$, и $a_r$ заменится на $a_r - d$.&lt;/p&gt;
&lt;p&gt;Алгоритм получается следующий: изначально перейдем от исходного массива к его разностному массиву, предварительно добавив в начало массива $0$, чтобы не потерять информацию о $b_0$.
Затем выполняем операции изменения за $O(1)$ каждую, потому что нужно поменять каждый раз всего два элемента. И в конце нужно вернуться к исходному виду массива, посчитав префиксные суммы.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;precalc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// add leading zero
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findDiffsArray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;addOnHalfInterval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// [l, r) += d
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;postcalc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;finalB&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findPrefixSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;finalB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;erase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;finalB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// delete leading zero
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;finalB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Обратите внимание на то, что если $r = n$, то такого элемента нет в массиве $a$, ведь этот элемент отвечал бы за разность элемента после конца массива $b$ с последним элементом массива $b$, которая нас не интересует. Поэтому в таком случае мы ничего не делаем.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
На самом деле можно было даже не брать разностный массив. Можно было считать, что изначально массив состоял из всех нулей, тогда его разностный массив тоже состоит из всех нулей; на этом массиве произвести все операции, посчитать массив префиксных сумм и уже в самом конце прибавить начальные значения элементов массива.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача:&lt;/strong&gt;
Дан массив длины $n$. Приходят $q$ запросов: прибавить на полуинтервале $[l, r)$ арифметическую прогрессию с шагом $step$, то есть к элементу на позиции $l$ прибавить $step$, к элементу на позиции $l + 1$ прибавить $2 \cdot step$, к элементу на позиции $l + 2$ прибавить $3 \cdot step$, $\ldots$, и наконец к элементу на позиции $r - 1$ прибавить $\left(r - l\right) \cdot step$.&lt;/p&gt;
&lt;p&gt;После выполнения всех запросов необходимо вывести получившийся массив. Асимптотика $O(n + q)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Решение:&lt;/strong&gt;
Задача похожа на предыдущую, но явно сложнее, ведь к каждому элементу на отрезке прибавляется разное число.
Давайте посмотрим, что произойдет, если мы как и раньше перейдем к разностному массиву.
Заметим, что если мы на полуинтервале прибавили $step, 2 \cdot step, \ldots, (r - l) \cdot step$, то в разностном массиве мы на некотором полуинтервале прибавим ко всем элементам $step$, а также из элемента на правой границе вычтется $(r - l) \cdot step$. Но ведь прибавлять число на отрезке мы уже умеем! Давайте перейдем к разностному массиву разностного массива, при этом не забыв в таком случае добавить уже не один, а два фиктивных нуля в начало массива. Тогда для разностного массива разностного массива изменятся только элементы на позициях $l$, $r$ и $r + 1$, так что мы можем выполнять все операции за $O(1)$, а затем в конце дважды насчитать массив префиксных сумм, вернувшись к исходному массиву.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;precalc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// add two leading zeros
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findDiffsArray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;findDiffsArray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// [l, r) += [step, 2 * step, ..., (r - l) * step]
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;addArithmOnHalfInterval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;step&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;step&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;step&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;step&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;postcalc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;finalB&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findPrefixSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;findPrefixSums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;finalB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;erase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;finalB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;finalB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;erase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;finalB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// delete leading zeros
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;finalB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Упражнение:&lt;/strong&gt;
Попробуйте решить последнюю задачу, если первый член арифметической прогрессии не совпадает с шагом, то есть на полуинтервале прибавляются числа $start, start + step, start + 2 \cdot step, \ldots, start + \left(r - l - 1\right) \cdot step$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Упражнение:&lt;/strong&gt;
Как обобщить решение прошлой задачи на случай, когда на отрезке прибавляется не линейная, а квадратичная функция?
То есть прибавляются числа $step, 4 \cdot step, 9 \cdot step, \ldots, (r - l)^2 \cdot step$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Упражнение:&lt;/strong&gt;
Представьте, что у вас есть список операций виде &amp;laquo;прибавить на полуинтервале $[l, r)$ значение $d$&amp;raquo;. Но вам нужно выполнять не эти операции, а целые отрезки операций! То есть в действительности операция имеет вид &amp;laquo;примените к массиву операции с номерами от $L$-й до $R$-й&amp;raquo;.
В конце нужно вывести получившийся массив.
Как решать такую задачу за $O(n + q)$?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Если вы знаете основы матанализа, можно легко понять, почему мы производили именно такие манипуляции. Ведь если взять производную, то прибавление константы на отрезке превратится в прибавление тождественного нуля, а для линейной функции нужно взять вторую производную.&lt;/p&gt;
&lt;h2 id=&#34;двумерный-разностный-массив&#34;&gt;Двумерный разностный массив&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Задача:&lt;/strong&gt;
Дан двумерный массив размера $n \times m$, изначально состоящий из всех нулей. Приходит $q$ запросов прибавления константы на прямоугольнике. В конце нужно вывести элементы получившегося массива.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Решение:&lt;/strong&gt;
Это двумерная версия задачи, которую мы рассматривали ранее, но для простоты изначальный массив состоит из нулей, поэтому нам не нужно переходить к разностному массиву. Надо подумать, к каким элементам что надо прибавить на разностном массиве, чтобы на исходном массиве прибавить $d$ на полупрямоугольнике $[lx, rx) \times [ly, ry)$.&lt;/p&gt;
&lt;p&gt;Можно заметить, что если в разностном массиве к какому-то элементу прибавить $d$, то в исходном массиве $d$ прибавится ко всем элементам на &lt;strong&gt;суффиксном&lt;/strong&gt; подпрямоугольнике.&lt;/p&gt;
&lt;!---
&lt;script type=&#34;text/tikz&#34;&gt;
\begin{tikzpicture}
\foreach \n in {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
\foreach \m in {0, 1, 2, 3, 4, 5}
\ifthenelse{\n &gt; 4 \AND \m &gt; 2}{\node[rectangle, color=red, minimum size=6mm, draw]}{\node[rectangle, minimum size=6mm, draw]} at (\n, -\m) {};

\node[color=red] at (4.5, -2.5) {$+d$};
\end{tikzpicture}
&lt;/script&gt;

&lt;span style=&#34;color:red&#34;&gt;TODO: Почему-то не отображается картинка tikz&lt;/span&gt;
---&gt;
&lt;p&gt;&lt;img src=&#34;https://peltorator.ru/try_web/images/prefix_sums_2d_suffix_add.svg&#34; alt=&#34;test&#34;&gt;&lt;/p&gt;
&lt;p&gt;Теперь перед нами стоит задача &amp;laquo;прибавить на подпрямоугольнике через прибавления на суффиксных подпрямоугольниках&amp;raquo;. Эта задача аналогична задаче поиска суммы на подпрямоугольнике.&lt;/p&gt;
&lt;!---
&lt;script type=&#34;text/tikz&#34;&gt;
\begin{tikzpicture}
\foreach \n in {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
\foreach \m in {0, 1, 2, 3, 4, 5}
\ifthenelse{\n &gt; 3 \AND \m &gt; 0}{\ifthenelse{\n &gt; 6}{\ifthenelse{\m &gt; 4}{\node[rectangle, color=blue, minimum size=6mm, draw]}{\node[rectangle, color=purple, minimum size=6mm, draw]}}{\ifthenelse{\m &gt; 4}{\node[rectangle, color=yellow, minimum size=6mm, draw]}{\node[rectangle, color=red, minimum size=6mm, draw]}}}{\node[rectangle, minimum size=6mm, draw]} at (\n, -\m) {};

\draw[color=green] (3.5, -0.5)-- (3.5, -4.5) -- (6.5, -4.5) -- (6.5, -0.5)-- cycle;

\node[color=red] at (3.5, -0.5) {$+d$};
\node[color=yellow] at (3.5, -4.5) {$-d$};
\node[color=purple] at (6.5, -0.5) {$-d$};
\node[color=blue] at (6.5, -4.5) {$+d$};

\end{tikzpicture}
&lt;/script&gt;

&lt;span style=&#34;color:red&#34;&gt;TODO: Почему-то не отображается картинка tikz&lt;/span&gt;
---&gt;
&lt;p&gt;&lt;img src=&#34;https://peltorator.ru/try_web/images/prefix_sums_add_on_rectangle.svg&#34; alt=&#34;test&#34;&gt;&lt;/p&gt;
&lt;p&gt;Прибавляем мы к тем же самым клеткам, сумму которых мы брали в задаче поиска суммы на подпрямоугольнике.&lt;/p&gt;
&lt;p&gt;В конце мы возьмем префиксные суммы получившегося двумерного массива, и это и будет ответом.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// [lx, rx) * [ly, ry) += d
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;addOnHalfRectangle&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;diffs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;diffs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;diffs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;diffs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;postcalc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;diffs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;finalArr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findPrefixSums2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;diffs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;finalArr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;erase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;finalArr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// delete leading horizontal zeros
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;finalArr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;finalArr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;erase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;finalArr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// delete leading vertical zeros
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;finalArr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Как и раньше, мы добавляем нули в начало. В случае двумерного массива мы добавили строку и столбец нулей. В качестве упражнения остается проверить, что индексы, к которым надо прибавлять, будут именно такие. При этом как и в одномерном случае, правые индексы могут не существовать в массиве &lt;code&gt;diffs&lt;/code&gt;, если они равны высоте или ширине изначального массива.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Упражнение:&lt;/strong&gt;
Спросите себя: понимаете ли вы, что делать, если изначально массив состоит не из нулей?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Упражнение:&lt;/strong&gt;
Как обобщить решение предыдущей задачи, если массив уже не двумерный, а трехмерный, и прибавлять надо на параллелепипеде?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Определение:&lt;/strong&gt;
Строго говоря, разностный двумерный массив можно строить так же, как и одномерный. Формула для его элементов будет такая:&lt;/p&gt;
&lt;p&gt;$$a_{i + 1, j + 1} = b_{i + 1, j + 1} - b_{i, j + 1} - b_{i + 1, j} + b_{i, j}$$&lt;/p&gt;
&lt;p&gt;что похоже на аналогичную формулу для двумерных префиксных сумм. Но как вы видели, на практике нам не надо изначально строить разностный массив. Нужно просто изначально считать, что он заполнен нулями, а после выполнения операций по нему посчитать массив префиксных сумм. И начальные элементы добавить уже в самом конце.&lt;/p&gt;
&lt;h2 id=&#34;задачи-для-практики&#34;&gt;Задачи для практики&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Предлагается прорешать специально подготовленный &lt;a href=&#34;https://codeforces.com/group/1rv4rhCsHp/contest/319055&#34;&gt;контест&lt;/a&gt; на codeforces. Если у вас нет доступа к соревнованию, нужно сначала вступить в &lt;a href=&#34;https://codeforces.com/group/1rv4rhCsHp/contests&#34;&gt;группу&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Быстрый ввод-вывод в C&#43;&#43;</title>
      <link>https://peltorator.ru/posts/fast_io/</link>
      <pubDate>Wed, 15 Sep 2021 10:16:31 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/fast_io/</guid>
      
      <description>&lt;p&gt;Часто бывает так, что ввод и/или вывод в задаче очень большие. В этом случае только считывание входных данных и вывод ответа уже могут не уложиться в ограничение по времени. Чтобы этого избежать, есть различные техники, которые мы рассмотрим в этой главе.&lt;/p&gt;
&lt;h2 id=&#34;endl-и-n&#34;&gt;endl и \n&lt;/h2&gt;
&lt;p&gt;Обычно перевод строки делается при помощи &lt;code&gt;cout &amp;lt;&amp;lt; endl&lt;/code&gt;, однако эта команда не только переводит строку, но и очищает буфер. Когда вы что-то выводите, на самом деле оно не обязано выводиться сразу. Программа сначала накопит какой-то буфер вывода, а потом выведет его целиком, потому что сама по себе операция вывода весьма долго работает. Однако если вы пишете &lt;code&gt;endl&lt;/code&gt;, то вы заставляете программу насильно очистить буфер. Если вы будете делать это очень часто, то программа будет работать очень долго. Чтобы решить эту проблему, можно вместо &lt;code&gt;endl&lt;/code&gt; использовать &lt;code&gt;cout &amp;lt;&amp;lt; &#39;\n&#39;&lt;/code&gt;. Отличие заключается как раз в том, что это просто символ перевода строки без очистки буфера. В случае, если вы в выводе часто делаете перевод строки, это может существенно ускорить вашу программу.&lt;/p&gt;
&lt;p&gt;Однако не стоит везде всегда писать &lt;code&gt;\n&lt;/code&gt; вместо &lt;code&gt;endl&lt;/code&gt;. В интерактивных задачах важно, чтобы после каждого вывода очищался буфер, чтобы программа, с которой вы взаимодействовала, могла сразу считать то, что вы вывели. Поэтому в интерактивных задачах обязательно использовать &lt;code&gt;endl&lt;/code&gt; для очистки буфера.&lt;/p&gt;
&lt;p&gt;Кроме того, если вы пытаетесь найти ошибку в программе и выводите отладочную информацию, вам важно, чтобы она появлялась на экране, поэтому ее тоже нужно выводить с очисткой буфера. Если вы не хотите при этом переводить строку, можете воспользоваться &lt;code&gt;std::flush&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;sync_with_stdio-и-cintie&#34;&gt;sync_with_stdio и cin.tie&lt;/h2&gt;
&lt;p&gt;Также сильно ускорить программу можно, отключив синхронизацию разных потоков ввода/вывода. Можно использовать следующие две строчки:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;ios&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sync_with_stdio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tie&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Первая строка отключает синхронизацию &lt;code&gt;iostream&lt;/code&gt; и &lt;code&gt;stdio&lt;/code&gt;, то есть вы не можете больше одновременно использовать и &lt;code&gt;cin&lt;/code&gt;, и &lt;code&gt;scanf&lt;/code&gt; в одной программе. Однако вряд ли вам это нужно, поэтому эту синхронизацию можно отключить, что приводит к ускорению программы.&lt;/p&gt;
&lt;p&gt;Вторая строка отключает привязку &lt;code&gt;cin&lt;/code&gt; к &lt;code&gt;cout&lt;/code&gt;, что помогает в случае, когда ввод и вывод чередуются. Кроме того, некоторые люди иногда используют &lt;code&gt;cout.tie(0)&lt;/code&gt;, но эта строка не делает ничего, потому что пытается отключить привязку &lt;code&gt;cout&lt;/code&gt; к &lt;code&gt;cout&lt;/code&gt;, что весьма странно. Миф о том, что &lt;code&gt;cout.tie&lt;/code&gt; полезен подкрепляется примерами, когда при добавлении этой строки код ускорялся, однако при повторных запусках могла наблюдаться обратная ситуация. Разное время работы связано с разными условиями запуска и фазами Венеры, но не с добавлением этой строчки.&lt;/p&gt;
&lt;h2 id=&#34;ручной-быстрый-ввод-вывод&#34;&gt;Ручной быстрый ввод-вывод&lt;/h2&gt;
&lt;p&gt;Если даже предыдущие оптимизации не помогают, можно воспользоваться рукописным быстрым вводом. Это будет еще в несколько раз быстрее. К примеру, можно воспользоваться вот этим &lt;a href=&#34;https://pastebin.com/W5rjcUiE&#34;&gt;кодом&lt;/a&gt; от Сергея Копелиовича. Пример использования:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readInt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;writeInt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Стресс-тестирование</title>
      <link>https://peltorator.ru/posts/stress/</link>
      <pubDate>Tue, 14 Sep 2021 13:38:44 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/stress/</guid>
      
      <description>&lt;h2 id=&#34;общие-концепции&#34;&gt;Общие концепции&lt;/h2&gt;
&lt;p&gt;Стресс-тестирование — это не тестирование задачи в последние минуты контеста под большим давлением.
Стресс-тестирование — это тестирование вашего кода сразу на большом количестве автоматически генерируемых тестов для поиска того теста, на котором ваше решение работает неправильно.&lt;/p&gt;
&lt;p&gt;Стандартный сценарий, когда вам нужен стресс: вы заслали решение в систему, получили WA, но ни ошибка в коде, ни неработающий тест никак не хотят находиться. Для стресс-тестирования вам нужны следующие компоненты:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;smart.cpp&lt;/code&gt;. Ваше решение, которое по какой-то причине не проходит тесты.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stupid.cpp&lt;/code&gt;. Тупое решение. Чаще всего за большую асимптотику. Очень важно, чтобы это решение было максимально тупым, и вы были уверены, что в нем нет никаких ошибок.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gen.cpp&lt;/code&gt;. Генератор тестов. Чаще всего тесты генерируются случайные, при этом они должны быть не очень большие, чтобы тупое решение тоже могло быстро на них работать, а также, чтобы вы могли потом найти ошибку в своем коде, используя этот тест. Когда вы нашли неработающий тест, попытайтесь максимально его минимизировать. Уменьшить константу в генераторе и так далее. Чем проще тест, тем легче вам будет исправлять ошибку.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stress.sh&lt;/code&gt;. Скрипт, который будет повторять следующий процесс: сгенерировать тест, запустить на нем умное решение, запустить на нем тупое решение, сравнить ответы. Если ответы равны, нужно повторить процесс, а если не равны, выдать тот тест, на котором ваше решение работает неправильно, и завершиться.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;checker.cpp&lt;/code&gt;. Пункт, который редко будет вам нужен, но все же может понадобиться, — это чекер. Не всегда в задаче существует единственный правильный ответ на каждый тест. К примеру, если задача заключается в том, чтобы разложить число на два множителя, то разных ответов может быть несколько, и каждый из них при этом верный. Поэтому вам может понадобиться написать программу, которая проверяет правильность вашего ответа, учитывая ответ тупого решения. Также бывает так, что тупого решения написать нет возможности, потому что любое тупое решение по сложности сопоставимо с вашим умным решением. В этом случае вам может помочь некоторая промежуточная мера, когда у вас есть только чекер. Этот чекер может сделать некоторые проверки ответа на адекватность (к примеру, проверить, что в задаче о разложении на два множителя, произведение этих множителей равно входному числу). Эта проверка может не покрывать все случаи, когда ваше решение работает некорректно, но все равно может помочь вам найти нужный тест.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;smart.cpp&lt;/code&gt; у вас уже есть, потому что это ваше решение. Чтобы написать &lt;code&gt;stupid.cpp&lt;/code&gt;, надо просто представить, что ограничения в задаче маленькие, и написать другое решение. Как уже было сказано ранее, очень важно писать максимально простой код, чтобы не допускать ошибок. &lt;code&gt;checker.cpp&lt;/code&gt; принимает на вход три файла: входной файл, правильный ответ и ваш ответ, и проверяет по ним корректность вашего ответа.&lt;/p&gt;
&lt;p&gt;Теперь осталось разобраться, как правильно писать &lt;code&gt;gen.cpp&lt;/code&gt; и &lt;code&gt;stress.sh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Обратите внимание, что здесь речь идет про shell стрессы в linux. В других случаях могут отличаться детали, однако пока мы говорим больше про общие концепции. Конкретные несоответствия будут освещены в соответствующих секциях позже.&lt;/p&gt;
&lt;p&gt;Генератор должен создавать случайный тест (небольшого размера). Рекомендуется использовать фиксированный сид рандома, чтобы тесты были воспроизводимы. При этом мы хотим запускать генератор много раз и получать разные тесты. Давайте для этого передавать сид рандома в аргументах командной строки. Функция &lt;code&gt;main&lt;/code&gt; может принимать два параметра: &lt;code&gt;agrc&lt;/code&gt; и &lt;code&gt;argv&lt;/code&gt;. &lt;code&gt;argc&lt;/code&gt; — это количество аргументов командной строки, а &lt;code&gt;argv&lt;/code&gt; — это массив аргументов размера &lt;code&gt;argc&lt;/code&gt;. К примеру, если вы скомпилировали ваш код в файл &lt;code&gt;main&lt;/code&gt; и запускаете его командой &lt;code&gt;./main aba 123 8&lt;/code&gt;, то &lt;code&gt;argc&lt;/code&gt; будет равен $4$, а в &lt;code&gt;argv&lt;/code&gt; будут храниться &lt;code&gt;./main&lt;/code&gt;, &lt;code&gt;aba&lt;/code&gt;, &lt;code&gt;123&lt;/code&gt; и &lt;code&gt;8&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Нам нужно передавать всего один параметр, который будет храниться в &lt;code&gt;argv[1]&lt;/code&gt;. Правда, он там будет храниться в типе &lt;code&gt;char*&lt;/code&gt; (строки из C), а нам нужно число. Для перевода можно воспользоваться функцией &lt;code&gt;atoi&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Кроме того, стоит помнить о том, что пользоваться стоит не функцией &lt;code&gt;rand&lt;/code&gt;, а генератором &lt;code&gt;mt_19937&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Если вы все таки решили не использовать аргументы командной строки, вам нужен случайный сид. Обычно для этого используют текущее время. Однако вам нужно, чтобы это текущее время менялось часто, а не каждую секунду, к примеру. Потому что в таком случае вы целую секунду будете кучу раз запускать один и тот же тест. Для этого вам поможет следующая инициализация рандома:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Подробнее про генерацию случайных чисел можно прочитать в &lt;a href=&#34;https://peltorator.ru/try_web/post/random/&#34;&gt;соответствующей статье&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Вооружившись всеми этими знаниями, давайте напишем генератор для задачи &amp;laquo;A+B&amp;raquo;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;random&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[])&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;seed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;atoi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;mt19937&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rnd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;seed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rnd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rnd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Теперь наша задача заключается в том, чтобы по очереди запускать &lt;code&gt;gen&lt;/code&gt;, записывать его результат в файл, запускать два решения и сравнивать их ответы. Рассмотрим разные варианты того, как это можно делать.&lt;/p&gt;
&lt;h2 id=&#34;linux-shell-стрессы&#34;&gt;Linux: Shell стрессы&lt;/h2&gt;
&lt;p&gt;Если вы пользуетесь linux, macos и т.п., то вам подойдет этот вариант. Если вы пользуетесь Windows, то для вас есть следующая секция.&lt;/p&gt;
&lt;p&gt;Мы напишем shell скрипт, который будет делать то, что нам нужно. Для этого нужно создать файл с расширением &lt;code&gt;.sh&lt;/code&gt;, в котором можно писать команды как в консоли, а также использовать циклы и т.п.&lt;/p&gt;
&lt;p&gt;Для начала нужно скомпилировать все наши файлы (&lt;code&gt;smart&lt;/code&gt;, &lt;code&gt;stupid&lt;/code&gt;, &lt;code&gt;gen&lt;/code&gt; и, возможно, &lt;code&gt;checker&lt;/code&gt;). Рекомендуется при стресс-тестировании максимально приближаться к компиляции программ в тестирующей системе и использовать соответствующую оптимизацию (скорее всего, это &lt;code&gt;-O2&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Далее мы запускаем цикл, в котором выполняем программы (компилируем мы один раз, а выполняем потом сколько угодно) и сравниваем результаты их работы.&lt;/p&gt;
&lt;p&gt;Пример стресса:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;g++ -std&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;c++17 -O2 smart.cpp -o smart
g++ -std&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;c++17 -O2 stupid.cpp -o stupid
g++ -std&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;c++17 -O2 gen.cpp -o gen

&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; t in &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;seq &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; 100000&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Running test &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$t&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
    ./gen &lt;span class=&#34;nv&#34;&gt;$t&lt;/span&gt; &amp;gt; input
    ./smart &amp;lt; input &amp;gt; smart_output
    ./stupid &amp;lt; input &amp;gt; stupid_output
    diff smart_output stupid_output &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;В первых трех строчках мы компилируем наши программы. Рассмотрим, к примеру, первую строчку. Здесь &lt;code&gt;g++&lt;/code&gt; — это компилятор c++, &lt;code&gt;-std=c++17&lt;/code&gt; устанавливает версию c++, под которой мы хотим компилировать программу, &lt;code&gt;-O2&lt;/code&gt; устанавливает нужный уровень оптимизаций, а &lt;code&gt;-o smart&lt;/code&gt; говорит о том, что мы хотим скомпилировать программу в файл под названием &lt;code&gt;smart&lt;/code&gt; (обратите внимание, что в данном случае у него нет никакого расширения). Остальные две компиляции аналогичны.&lt;/p&gt;
&lt;p&gt;Далее на 5 строке представлен код цикла, который перебирает переменную &lt;code&gt;t&lt;/code&gt; от $1$ до $100000$. Обратите внимание, что цикл завершается словом &lt;code&gt;done&lt;/code&gt; в конце скрипта. После чего при помощи команды &lt;code&gt;echo&lt;/code&gt; мы выводим на экран номер теста, чтобы можно было отслеживать прогресс.&lt;/p&gt;
&lt;p&gt;Затем запускаются программы. Здесь &lt;code&gt;./gen&lt;/code&gt; означает запуск программы &lt;code&gt;gen&lt;/code&gt;, &lt;code&gt;$t&lt;/code&gt; означает, что мы передаем число &lt;code&gt;t&lt;/code&gt; как параметр. Знак больше перенаправляет вывод программы. Таким образом, наш генератор будет писать тест не в консоль, а в файл под названием &lt;code&gt;input&lt;/code&gt;. Затем мы аналогично запускаем два решения. Они пишут в файлы &lt;code&gt;smart_output&lt;/code&gt; и &lt;code&gt;stupid_output&lt;/code&gt;. При этом в этих строчках есть еще знак меньше, который наоборот означает то, откуда мы читаем входные данные. То, какой знак нужно использовать для чего, легко понять по направлению стрелочки. У знака &lt;code&gt;&amp;gt;&lt;/code&gt; стрелочка указывает внутрь файла, то есть в этот файл мы выводим информацию, а у знака &lt;code&gt;&amp;lt;&lt;/code&gt; стрелочка указывает наружу, то есть из этого файла мы достаем информацию.&lt;/p&gt;
&lt;p&gt;После того, как программы отработали, настало время проверить совпадение ответов. Для этого мы воспользуемся консольной утилитой &lt;code&gt;diff&lt;/code&gt;, которая сравнивает файлы на совпадение. Стоит обратить внимание, что если мы не пишем чекер и пользуемся &lt;code&gt;diff&lt;/code&gt;&amp;lsquo;ом, то формат вывода у обеих программ должен совпадать с точностью до пробелов. Утилита &lt;code&gt;diff&lt;/code&gt; возвращает $1$, если файлы равны, и $0$, если файлы не равны. Далее мы используем оператор &lt;code&gt;||&lt;/code&gt;, который, как и в c++, означает &amp;laquo;или&amp;raquo;. Если &lt;code&gt;diff&lt;/code&gt; вернул $1$, то результат &amp;laquo;или&amp;raquo; уже равен единице и второй аргумент не вычисляется. Если же было возвращено значение $0$, то выполняется вторая команда &lt;code&gt;exit&lt;/code&gt;, которая завершает наш скрипт. Кроме того, &lt;code&gt;diff&lt;/code&gt; в этом случае выведет на экран места, в которых различаются файлы. Далее можно уже зайти в файл &lt;code&gt;input&lt;/code&gt;, посмотреть, какой там тест, и пользоваться им для отладки программы. Если же неправильный тест не находится, то либо вы допустили ошибку при написании стресса, либо ваше решение верное, либо ошибка просто не ловится вашим стрессом (возможно, она проявляется только на больших тестах).&lt;/p&gt;
&lt;p&gt;Чтобы запустить этот скрипт, нужно просто написать в консоль &lt;code&gt;./stress.sh&lt;/code&gt;, если вы сохранили его в соответствующий файл. Однако, вероятно, вам выдадут строчку примерно такого содержания:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;permition denied: ./stress.sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Дело в том, что по умолчанию у файлов нет прав на исполнение. Так что нужно их добавить. Это можно сделать при помощи следующей команды:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chmod +x stress.sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;И  затем попытаться запустить скрипт заново.&lt;/p&gt;
&lt;p&gt;Теперь поговорим об улучшениях, которые можно сделать к нашему стрессу. Во-первых, может возникнуть ситуация, в которой какая-то из запускаемых программ упадет с ошибкой выполнения. Наш стресс это просто проигнорирует. Давайте это обработаем. Для этого просто добавим &lt;code&gt;|| exit&lt;/code&gt; в конец запусков наших программ аналогично строке с &lt;code&gt;diff&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;g++ -std&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;c++17 -O2 smart.cpp -o smart
g++ -std&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;c++17 -O2 stupid.cpp -o stupid
g++ -std&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;c++17 -O2 gen.cpp -o gen

&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; t in &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;seq &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; 100000&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Running test &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$t&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
    ./gen &lt;span class=&#34;nv&#34;&gt;$t&lt;/span&gt; &amp;gt; input &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt;
    ./smart &amp;lt; input &amp;gt; smart_output &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt;
    ./stupid &amp;lt; input &amp;gt; stupid_output &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt;
    diff smart_output stupid_output &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Теперь наша программа завершится, если какая-то из программ упала. Однако мы не знаем, какая. Мы можем попытаться запустить их по очереди и проверить. Либо можно добавить описание причины ошибки:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;g++ -std&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;c++17 -O2 smart.cpp -o smart
g++ -std&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;c++17 -O2 stupid.cpp -o stupid
g++ -std&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;c++17 -O2 gen.cpp -o gen

&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; t in &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;seq &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; 100000&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Running test &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$t&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
    ./gen &lt;span class=&#34;nv&#34;&gt;$t&lt;/span&gt; &amp;gt; input &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;gen failed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; exit&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    ./smart &amp;lt; input &amp;gt; smart_output &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;smart failed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    ./stupid &amp;lt; input &amp;gt; stupid_output &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;stupid failed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    diff smart_output stupid_output &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;outputs aren&amp;#39;t equal&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; exit&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;windows-bat-стрессы&#34;&gt;Windows: Bat стрессы&lt;/h2&gt;
&lt;p&gt;Аналогичный пример с bat скриптами в Windows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bat&#34; data-lang=&#34;bat&#34;&gt;g++ -std=c++17 -O2 smart.cpp -o smart.exe
g++ -std=c++17 -O2 stupid.cpp -o stupid.exe
g++ -std=c++17 -O2 gen.cpp -o gen.exe

&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;beg&lt;/span&gt;
gen.exe &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; input &lt;span class=&#34;p&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;exit&lt;/span&gt;
smart.exe &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; input &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; smart_output
stupid.exe &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; input &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; stupid_output
fc smart_output stupid_output
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;errorlevel&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;goto&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;bug&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;goto&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;beg&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;bug&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;echo&lt;/span&gt; found!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Компиляция аналогична варианту с linux. Далее мы используем goto как циклы, бесконечно запуская тесты (здесь представлена вариация без входных параметров, то есть в коде должен использоваться часто меняющийся рандом). Далее используется команда &lt;code&gt;fc&lt;/code&gt;, аналогичная &lt;code&gt;diff&lt;/code&gt; в linux.&lt;/p&gt;
&lt;h2 id=&#34;python-стрессы&#34;&gt;Python стрессы&lt;/h2&gt;
&lt;p&gt;В данном подходе мы используем вместо shell или bat скрипта более высокоуровневый вариант — питон. Из него мы можем запускать все те же консольные команды, но кроме того можем, к примеру, написать прямо там без труда свой собственный чекер или генератор (или не писать). Особых отличий от скриптовых вариантов больше нет, рекомендуется изучить код:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sys&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Running test&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;popen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;./gen &amp;gt; input&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;smart_ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;popen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;./smart &amp;lt; input&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;readlines&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;stupid_ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;popen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;./stupid &amp;lt; input&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;readlines&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;smart_ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stupid_ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Outputs are not equal&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Input:&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;input&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;readlines&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()))&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;stupid answer:&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stupid_ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;smart answer:&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;smart_ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;All tests passed&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Здесь &lt;code&gt;os.popen&lt;/code&gt; выполняет консольную команду, а &lt;code&gt;readlines&lt;/code&gt; сохраняет вывод программы.&lt;/p&gt;
&lt;p&gt;Плюсом этого подхода является платформонезависимость.&lt;/p&gt;
&lt;h2 id=&#34;in-code-стрессы&#34;&gt;In-Code стрессы&lt;/h2&gt;
&lt;p&gt;Наверное, самый простой вариант — сделать все в одной программе. Здесь &lt;code&gt;smart&lt;/code&gt;, &lt;code&gt;stupid&lt;/code&gt;, &lt;code&gt;gen&lt;/code&gt; и &lt;code&gt;checker&lt;/code&gt; будут не отдельными программами, а функциями. Вероятно также, что ввод-вывод в этом случае тестироваться не будут. Только смысловая часть программы. Если вы заранее не писали код в формате блоков: отдельная функция для ввода, отдельная функция для решения, отдельная функция для вывода, то вам придется немного поменять свое решение.&lt;/p&gt;
&lt;p&gt;Однако плюсом данного подхода является его быстрота. Здесь мы не запускаем никаких программ, не пишем в файлы и т.д. В результате чего мы можем запускать миллионы тестов в секунду.&lt;/p&gt;
&lt;p&gt;Если два решения используют функции или переменные с одинаковыми названиями, можно просто заключить оба решения в два разных пространства имен: &lt;code&gt;NamespaceSmart&lt;/code&gt; и &lt;code&gt;NamespaceStupid&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Пример такого стресса для задачи поиска квадрата числа можно посмотреть по &lt;a href=&#34;https://pastebin.com/HqQkPNVG&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Генерация случайных чисел</title>
      <link>https://peltorator.ru/posts/random/</link>
      <pubDate>Tue, 14 Sep 2021 13:26:39 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/random/</guid>
      
      <description>&lt;p&gt;Часто бывает так, что ваши решения задач зависят от случайных чисел. Стандартным примером будет являться декартово дерево, в котором логарифмическая высота достигается в том случае, если потенциалы будут выбраны случайно. Когда ваша программа использует случайные числа, нужно быть внимательным, чтобы не попасть в какую-нибудь ловушку. В этом разделе мы как раз поговорим про то, какие бывают ловушки, как в них не попасться, а также как упростить себе жизнь. В основном речь будет идти про C++, однако некоторые вещи можно по аналогии перенести в другие языки.&lt;/p&gt;
&lt;h2 id=&#34;mt19937&#34;&gt;mt19937&lt;/h2&gt;
&lt;p&gt;Первое, что нужно сделать, когда вы работаете со случайными числами, — это забыть про функцию &lt;code&gt;rand&lt;/code&gt;. Не стоит использовать ее ни-ко-гда! И на это есть три причины.&lt;/p&gt;
&lt;p&gt;Первая причина заключается в том, что случайные числа, которые генерирует &lt;code&gt;rand&lt;/code&gt;, — это &amp;laquo;плохие&amp;raquo; случайные числа. Дело в том, что компьютер не может сгенерировать по настоящему случайные числа. Поэтому вместо этого он генерирует &amp;laquo;псевдослучайные&amp;raquo; числа. Существуют разные способы генерации псевдослучайных чисел, и способ, который используется в &lt;code&gt;rand&lt;/code&gt; далеко не самый лучший. В них легко можно вычленить периодичности и т.п.&lt;/p&gt;
&lt;p&gt;Вторая причина более обозрима. Она заключается в том, что эта функция платформозависима. По стандарту она генерирует случайное число от нуля до &lt;code&gt;RAND_MAX&lt;/code&gt;. Проблема заключается в том, что в linux это число &lt;code&gt;RAND_MAX&lt;/code&gt; совпадает с максимальным числом, которое может храниться в типе &lt;code&gt;int&lt;/code&gt; ($2^{31} - 1$), и все хорошо. Однако в windows &lt;code&gt;RAND_MAX&lt;/code&gt; равен $32767$ ($2^{15} - 1$), а это на самом деле очень маленькое число. Если вы не знаете этого и хотите генерировать много случайных чисел, они будут очень часто повторяться в таком случае. Другая проблема встает тогда, когда вам нужно генерировать действительно большие числа. В этом случае с функцией &lt;code&gt;rand&lt;/code&gt; придется изворачиваться и использовать конструкции типа &lt;code&gt;RAND_MAX * rand() + rand()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;И самое ужасное произойдет в тот момент, когда вы захотите использовать функцию &lt;code&gt;random_shuffle&lt;/code&gt;, которая случайным образом перемешивает элементы массива. Для ее работы нужна генерация случайных индексов массива, то есть случайных чисел от $0$ до $n - 1$, однако число $n$ вполне вероятно может быть сильно больше, чем $32767$. В таком случае сгенерированная перестановка абсолютно не является случайной. К примеру, если $n = 3 \cdot 10^6$, тесты показывают, что каждый элемент находится в среднем на расстоянии $2 % n$ позиций от своего изначального места, хотя с теоретической точки зрения это должно быть $33 %$.&lt;/p&gt;
&lt;p&gt;Третья причина заключается в том, что генератор случайных чисел, который мы рассмотрим далее работает просто быстрее, чем &lt;code&gt;rand&lt;/code&gt;. Подробнее мы поговорим про это позже.&lt;/p&gt;
&lt;p&gt;Для решения всех этих проблем подойдет генератор случайных чисел &lt;code&gt;mt19937&lt;/code&gt;, добавленный в C++11. Он вне зависимости от компилятора генерирует случайные числа от $0$ до $2^{32} - 1$ (обратите внимание, что здесь генерируется случайное &lt;code&gt;unsigned int&lt;/code&gt; число). Этот генератор основан на простом числе Мерсена $2^{19937} - 1$ (его название — это как раз сокращение от его параметров: &amp;laquo;Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits&amp;raquo;). Такой генератор намного более &amp;laquo;рандомный&amp;raquo; и его период — это как раз $2^{19937} - 1$, что является невероятно большим числом (примерно $10^{6000}$). Давайте рассмотрим пример работы этого генератора:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;mt19937&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rnd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4321&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rnd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rnd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Данный код создает генератор под названием &lt;code&gt;rnd&lt;/code&gt; с начальным сидом $4321$. После этого генератор можно использовать как функцию. Данный код выведет на экран два случайных числа от $0$ до $2^{32} - 1$. Стоит обращать внимание на то, что если присвоить значение &lt;code&gt;rnd()&lt;/code&gt; переменной типа &lt;code&gt;int&lt;/code&gt;, то значение может быть отрицательным. Однако если вы сразу знаете, что вам нужно число из какого-то диапазона, то взяв значение по модулю вы избежите отрицательных чисел:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rnd() % 1000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Кроме того, этот генератор можно использовать при перемешивании элементов массива. Для этого нужно воспользоваться функцией &lt;code&gt;std::shuffle&lt;/code&gt;, аналогичной &lt;code&gt;random_shuffle&lt;/code&gt;. Она принимает начало и конец последовательности, а также генератор. К примеру:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shuffle(a.begin(), a.end(), rnd);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Также стоит обратить внимание на то, что мы не только выигрываем в качестве генератора и величине генерируемых чисел, но и во времени. Генерация числа при помощи &lt;code&gt;rnd&lt;/code&gt; в $3$ раза быстрее генерации при помощи &lt;code&gt;rand&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Если вам нужно генерировать еще бóльшие числа, у &lt;code&gt;mt19937&lt;/code&gt; есть старший брат &lt;code&gt;mt19937_64&lt;/code&gt;, который генерирует уже  $64$-битные случайные числа.&lt;/p&gt;
&lt;p&gt;Стоит не забывать и о платформенной независимости. &lt;code&gt;mt19937&lt;/code&gt; не только генерирует большие случайные числа на любой платформе, он кроме того генерирует одни и те же числа (при фиксированном сиде) на любой платформе. Так что вы можете быть уверены, что когда вы засылаете ваше решение в систему, оно будет там работать точно так же, как и на вашем компьютере.&lt;/p&gt;
&lt;p&gt;Еще одним плюсом может быть то, что вы можете создавать несколько разных &lt;code&gt;mt19937&lt;/code&gt; генераторов в одной программе (с одним и тем же сидом, либо с разными) и использовать их независимо. Как это можно использовать, каждый решит для себя сам. К примеру, если вы делаете in-code стресс, вы можете не передавать решениям входные данные, сгенерированные случайно, а генерировать их прямо по ходу решения, и если вы используете один и тот же сид, но разные генераторы в двух решениях, они будут генерировать одни и те же числа.&lt;/p&gt;
&lt;h2 id=&#34;uniform_int_distrubition&#34;&gt;uniform_int_distrubition&lt;/h2&gt;
&lt;p&gt;В C++ помимо &lt;code&gt;mt19937&lt;/code&gt; есть большое количество удобных вспомогательных инструментов для работы со случайными числами.&lt;/p&gt;
&lt;p&gt;Первый пример, который мы рассмотрим, — это &lt;code&gt;uniform_int_distribution&lt;/code&gt;. Это инструмент, позволяющий генерировать случайное целое число в заданном диапазоне. Легче всего понять его принцип работы на примере:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;mt19937&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rnd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4321&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;uniform_int_distribution&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;distrib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;distrib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rnd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Мы создаем объект класса &lt;code&gt;uniform_int_distribution&lt;/code&gt;. В шаблон мы передаем, какого типа должны возвращаться числа, в данном случае это &lt;code&gt;int&lt;/code&gt; (его можно опускать, потому что компилятор сам догадается о типе из типа левой и правой границы). Затем в конструктор передается два числа — левая и правая граница отрезка, в котором будут генерироваться числа. После чего для того, чтобы сгенерировать случайное число, нужно передать в &lt;code&gt;uniform_int_distribution&lt;/code&gt; наш генератор случайных чисел. В данном случае это &lt;code&gt;mt19937&lt;/code&gt;, который мы заранее определили. Такой код выведет случайное целое число от $1$ до $10$ включительно.&lt;/p&gt;
&lt;p&gt;Стандартным способом сгенерировать число в полуинтервале от $l$ до $r$ был бы следующий код:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;uniform_distribution&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rnd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;В случае, если нужно сгенерировать случайное число от $0$ до $r$, код можно упростить, просто взяв значение &lt;code&gt;rnd()&lt;/code&gt; по модулю $r$. &lt;code&gt;uniform_int_distribution&lt;/code&gt; не только упрощает этот процесс, но и спасает вам от неожиданных проблем.&lt;/p&gt;
&lt;p&gt;Обратите внимание, что если &lt;code&gt;rnd&lt;/code&gt; генерирует случайное число от $0$ до $C$, то &lt;code&gt;rnd() % r&lt;/code&gt; — это случайное число от $0$ до $r$ только в том случае, если $C$ делится на $r$. В противном случае остатки $0$, $1$, $\ldots$, $\left(C - 1\right) \bmod r$ будут генерироваться немного чаще, чем все остальные. Вы вряд ли как-то это сможете заметить, если $r$ — это, к примеру, $3$, однако для больших $r$ это может привести к неприятным последствиям. Пускай $r = \left\lfloor \frac{2 \cdot C}{3} \right\rfloor$. Тогда для остатков от $0$ до $\frac{r}{2}$ есть два возможных числа с такими остатками, а для остатков, больших $\frac{r}{2}$, таких чисел по одной штуке. Это значит, что маленькие остатки будут генерироваться в среднем в два раза чаще, чем большие. &lt;code&gt;uniform_int_distribution&lt;/code&gt; как раз таки помогает решить эту проблему.&lt;/p&gt;
&lt;p&gt;Момент, который стоит все таки отметить — это то, что в отличие от &lt;code&gt;mt19937&lt;/code&gt;, &lt;code&gt;uniform_int_distribution&lt;/code&gt; все таки платформозависим. То есть при фиксированном сиде &lt;code&gt;mt19937&lt;/code&gt; могут выдаваться разные числа на разных компиляторах. Не то, чтобы это было очень серьезной проблемой, но стоит учитывать, что у вас на компьютере и в тестирующей системе могут генерироваться разные числа.&lt;/p&gt;
&lt;h2 id=&#34;как-генерировать-случайные-числа-по-модулю&#34;&gt;Как генерировать случайные числа по модулю&lt;/h2&gt;
&lt;p&gt;Сделаем небольшое отступление. Как мы поняли, если нам нужно генерировать случайное число из какого-то отрезка, нам в этом поможет &lt;code&gt;uniform_int_distribution&lt;/code&gt;. Однако что бы мы делали, если бы у нас его не было? Пришлось бы использовать плохой генератор, который генерирует числа неравномерно? Давайте приведем рандомизированный алгоритм, который за ожидаемое время $O(1)$ вернет нам случайный равномерно распределенный остаток по модулю $r$.&lt;/p&gt;
&lt;p&gt;Как мы уже поняли, если $2^{32}$ делится на $r$, то все хорошо. Мы должны просто взять остаток от деления &lt;code&gt;rnd()&lt;/code&gt; на $r$. Однако если $r$ не является степенью двойки, распределение такого остатка будет неравномерным. Давайте избавимся от этих последних остатков, которые мешают равномерности. То есть возьмем число $X$, равное $2^{32} - (2^{32} \bmod r)$. Такое число будет делиться на $r$, но при этом будет не меньше $2^{31}$ (если $r \ge 2^{31}$, то такое число не меньше $r$, которое не меньше $2^{31}$, а если $r &amp;lt; 2^{31}$, то мы вычтем что-то меньшее $2^{31}$, поэтому получим число, которое не меньше $2^{31}$). Тогда давайте сделаем так: если случайно сгенерированное число $q$ меньше $X$, то вернем $q \bmod r$, что будет равномерно распределенным случайным остатком, а если $q$ не меньше $X$, то повторим генерацию заново. Так как $X$ не меньше $\frac{2^{32}}{2}$, то вероятность успеха каждый раз не меньше $\frac{1}{2}$, поэтому нам в среднем понадобится сгенерировать не больше двух случайных чисел.&lt;/p&gt;
&lt;h2 id=&#34;другие-распределения&#34;&gt;Другие распределения&lt;/h2&gt;
&lt;p&gt;По аналогии с &lt;code&gt;uniform_int_distribution&lt;/code&gt; в C++ есть много других распределений. К примеру, &lt;code&gt;normal_distribution&lt;/code&gt; и &lt;code&gt;exponential_distribution&lt;/code&gt;, которые соответствуют нормальному и экспоненциальному распределениям. Маловероятно, что это может понадобиться вам при решении задач, но все же.&lt;/p&gt;
&lt;p&gt;А вот что действительно может понадобиться вам, так это генерировать случайное вещественное число. Для этого подойдет &lt;code&gt;uniform_real_distribution&lt;/code&gt;. Его использование аналогично &lt;code&gt;uniform_int_distribution&lt;/code&gt;, но только теперь генерируется не случайное целое число из отрезка, а случайное вещественное.&lt;/p&gt;
&lt;h2 id=&#34;выбор-сида-рандома&#34;&gt;Выбор сида рандома&lt;/h2&gt;
&lt;p&gt;Важным вопросом является выбор сида рандома. Формально есть всего два варианта выбора сида: детерминированный (фиксированное число) и случайный. Давайте поймем, какой вариант нужно использовать в какой ситуации.&lt;/p&gt;
&lt;p&gt;Чаще всего (частота употребления — это, конечно, индивидуальная вещь, но все же) вы хотите использовать константный сид рандома (мы ранее использовали всегда число $4321$, но это может быть ваше любимое число). Какие у этого плюсы? В таком случае ваши случайные числа весьма условно случайны. На самом деле они вполне детерминированы. Каждый раз, когда вы запускаете программу, вам выдаются одни и те же числа. Чем же это хорошо? Тем, что вы контролируете ситуацию.&lt;/p&gt;
&lt;p&gt;Если ваша программа не работает, и вы пытаетесь найти ошибку, вы знаете, что при каждом запуске программе даются одни и те же случайные числа, и вы не столкнетесь с тем, что один раз ошибка была, потом пропала, а воспроизвести ее не получается.&lt;/p&gt;
&lt;p&gt;Другой плюс — это уверенность в результате. Вы знаете, что когда вы зашлете решение в систему, оно будет работать там на тестах точно так же, как и на вашем компьютере. Кроме того, если вы получили по задаче AC, то вы уверены, что сколько бы раз не происходило перетестирование, ваше решение все равно будет проходить тесты.&lt;/p&gt;
&lt;p&gt;Если же вы используете случайный сид, то при каждом запуске числа, которые выдает ваш случайный генератор, меняются. В результате чего может сложиться такая ситуация, что после окончания контеста все решения будут перетестированы, и вам не повезет со случайными числами, в результате чего ваше решение не пройдет тесты.&lt;/p&gt;
&lt;p&gt;В каком же случае все таки нужно использовать случайный сид (про то, как сгенерировать случайный сид, мы поговорим позже)? Во-первых, в любых контестах со взломами (codeforces, topcoder и т.п.). Если в таких соревнованиях ваш сид не случайный, то человек, который смотрит на ваш код, может запустить у себя локально ваше решение, посмотреть, какие случайные числа оно генерирует, и без труда построить контртест, тем самым вся ваша случайность будет абсолютно бесполезна.&lt;/p&gt;
&lt;p&gt;Во-вторых, это может понадобиться вам, когда вы хотите запустить ваше решение несколько раз и проверить, что от изменения сида вывод не меняется. Это можно сделать, меняя каждый раз сид руками в коде, но после этого каждый раз придется перекомпилировать программу. Случайный сид может быть хорошим решением этой проблемы.&lt;/p&gt;
&lt;p&gt;В-третьих, если вы пишете &lt;a href=&#34;https://peltorator.ru/try_web/post/stress/&#34;&gt;стресс тесты&lt;/a&gt;. Есть два подхода в этом плане. Первый — передавать сид как аргумент командной строки, либо выбирать его случайно. Если вы все таки решили выбрать сид случайно, то вам очень важно &amp;laquo;качество&amp;raquo; этого случайного сида. Об этом мы как раз и поговорим далее.&lt;/p&gt;
&lt;p&gt;Случайным сидом обычно выбирают текущее время, потому что это некоторая меняющаяся величина. Самый простой способ получения времени — это &lt;code&gt;time(0)&lt;/code&gt;. Эта функция возвращает текущее время в секундах. Этот вариант подойдет вам, если вы хотите запустить ваше решение несколько раз и посмотреть, что оно делает при разных сидах (если вы запускаете ваше решение не чаще, чем раз в секунду). Однако эту функцию категорически не стоит использовать в двух других случаях.&lt;/p&gt;
&lt;p&gt;В случае стресс тестирования вы хотите прогонять тысячи тестов в секунду, но при использовании &lt;code&gt;time(0)&lt;/code&gt; ваш генератор целую секунду будет генерировать вам один и тот же тест, поэтому поиск неправильного теста замедляется в тысячи раз.&lt;/p&gt;
&lt;p&gt;В случае взломов проблема не так очевидна. На самом деле человек, который вас взламывает, может подгадать, в какую секунду ваше решение будет тестироваться и подготовить тест специально для нее. Если этот вариант кажется вам невозможным, то есть и более реалистичный случай. Можно сделать тест, который является контртестом сразу к $60$ разным сидам. И если эти сиды — это последовательные секунды, то здесь для взлома остается лишь совершить его в правильную минуту, что совершенно не является проблемой.&lt;/p&gt;
&lt;p&gt;Что же делать? Нужно использовать время в наносекундах (миллиардная доля секунды). Тогда подгадать сид точно уже не представляется возможным. Получить текущее время в наносекундах можно при помощи следующей строки:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chrono::steady_clock::now().time_since_epoch().count()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;И это можно использовать как сид рандома:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Есть еще способ через &lt;code&gt;random_device&lt;/code&gt;. Это генератор случайных чисел, который недетерминирован сам по себе:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;random_device&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;mt19937&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rnd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Однако, к сожалению, это тоже платформозависимое решение&lt;/strong&gt;. На windows &lt;code&gt;random_device&lt;/code&gt; все таки детерминирован, поэтому этот способ не рекомендуется использовать.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Поиск пересечения полуплоскостей с точкой внутри</title>
      <link>https://peltorator.ru/posts/halfplanes_intersection_point_inside/</link>
      <pubDate>Tue, 14 Sep 2021 13:12:00 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/halfplanes_intersection_point_inside/</guid>
      
      <description>&lt;p&gt;Алгоритмы нахождения пересечения полуплоскостей достаточно сложные, поэтому стоит пользоваться ситуациями, когда задачу нужно решать не в общем случае. К примеру, если все полуплоскости &amp;laquo;смотрят вниз&amp;raquo;, то это уже задача Convex Hull Trick. Если нужно лишь проверить пересечение полуплоскостей на непустоту, то это можно сделать при помощи линейного &lt;a href=&#34;https://peltorator.ru/try_web/post/halfplanes_intersection_linear/&#34;&gt;рандомизированного алгоритма&lt;/a&gt;. В этой главе же мы рассмотрим ситуацию, когда нам известно, что какая-то точка $P$ обязательно лежит строго внутри пересечения полуплоскостей.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Обратите внимание, что точка должна лежать строго внутри, поэтому нельзя просто сначала найти точку на границе при помощи рандомизированного линейного алгоритма, а потом запустить алгоритм из этой главы.&lt;/p&gt;
&lt;p&gt;Пусть точка $P$ лежит в пересечении полуплоскостей. Тогда давайте сначала переместим точку $P$ в начало координат. Все полуплоскости тоже сдвинем на вектор $-P$. Теперь начало координат лежит в пересечении полуплоскостей. Давайте все прямые вида $ax + by + c = 0$ заменим на точки $\left( \frac{a}{c}, \frac{b}{c} \right)$. Теперь мы перешли к двойственной задаче, и у полученного набора точек нужно найти выпуклую оболочку, что уже намного проще. После этого мы найдем список индексов прямых, которые образуют пересечение полуплоскостей.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Минимальная покрывающая окружность за $O(n)$</title>
      <link>https://peltorator.ru/posts/min_circle/</link>
      <pubDate>Tue, 14 Sep 2021 13:10:00 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/min_circle/</guid>
      
      <description>&lt;p&gt;Решим за линейное время следующую задачу:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача:&lt;/strong&gt;
Даны $n$ точек на плоскости. Требуется найти окружность минимального радиуса, такую что все данные точки лежат внутри или на границе этой окружности.&lt;/p&gt;
&lt;p&gt;В отличие от других рассмотренных рандомизированных геометрических алгоритмов, у которых есть общеизвестные детерминированные аналоги, работающие в $\log n$ раз дольше, в данном случае рандомизированное решение будет единственным применимым с практической точки зрения.&lt;/p&gt;
&lt;p&gt;Есть два варианта того, как будет выглядеть минимальная покрывающая окружность: либо это описанная окружность какой-то тройки из данных точек, либо окружность, построенная на отрезке между двумя какими-то точками как на диаметре, потому что во всех других случаях ее радиус можно немного уменьшить так, чтобы эта окружность все еще содержала в себе все данные точки.&lt;/p&gt;
&lt;script type=&#34;text/tikz&#34;&gt;
\definecolor{ududff}{rgb}{0.30196078431372547,0.30196078431372547,1.}

\begin{tikzpicture}[line cap=round,line join=round,x=1.0cm,y=1.0cm]
%\clip(1.9532993692172027,-5.315606491485562) rectangle (22.418083000629153,7.063910164237411);
\draw [line width=2.pt] (6.945547737616033,-1.3701101896033616) circle (2.15982720768932cm);
\draw [line width=2.pt] (12.353435313049506,-1.4407171317673966) circle (2.261063915530779cm);
\begin{scriptsize}
\draw [fill=ududff] (5.291407518931119,0.018656782931653123) circle (2.5pt);
\draw [fill=ududff] (9.01532716333559,-0.7529662064494537) circle (2.5pt);
\draw [fill=ududff] (5.9,-3.26) circle (2.5pt);
\draw [fill=ududff] (10.474701078034638,-0.18263617081993994) circle (2.5pt);
\draw [fill=ududff] (14.232169548064373,-2.6987980927148527) circle (2.0pt);
\end{scriptsize}
\end{tikzpicture}
&lt;/script&gt;
&lt;p&gt;Давайте по очереди добавлять точки в случайном порядке, поддерживая минимальную покрывающую окружность текущего набора точек. Если новая точка лежит внутри текущей окружности, то ничего менять не надо, а в противном случае нужно перестроить окружность. Стоит заметить, что если новая точка не лежит в старой окружности, то она обязана лежать на новой минимальной окружности. На окружности лежит $3$ точки, поэтому вероятность такого события — $\frac{3}{k}$, где $k$ — индекс новой точки (если на окружности лежит больше $3$ точек, то эта окружность была минимальной еще до добавления текущей точки, а если окружность построена на двух точках как на диаметре, то вероятность еще меньше — $\frac{2}{k}$). Теперь если мы построим линейный алгоритм, который находит минимальную покрывающую окружность, проходящую через новую точку, то итоговая асимптотика алгоритма будет $\sum_{k = 1}^{n} \frac{3}{k} \cdot k = \sum_{k = 1}^{n} 3 = 3n = O(n)$.&lt;/p&gt;
&lt;script type=&#34;text/tikz&#34;&gt;
\begin{tikzpicture}[line cap=round,line join=round,x=1.0cm,y=1.0cm]
%\clip(0.5970946385918617,-5.021501998660121) rectangle (14.329747363302438,3.2856272725172593);
\draw [line width=2.pt] (7.309601593625497,-1.3147011952191234) circle (3.194715623859915cm);
\begin{scriptsize}
\draw [fill=ududff] (7.3,1.88) circle (2.5pt);
\draw [fill=ududff] (4.24,-2.2) circle (2.5pt);
\draw [fill=ududff] (10.26,-2.54) circle (2.5pt);
\draw [fill=ududff] (7.58,0.24) circle (2.5pt);
\draw [fill=ududff] (6.08,-0.84) circle (2.5pt);
\draw [fill=ududff] (8.52,-3.54) circle (2.5pt);
\draw [fill=ududff] (8.92,-0.76) circle (2.5pt);
\draw [fill=ududff] (6.4,-2.92) circle (2.5pt);
\draw [fill=red] (4.08,0.79) circle (2.5pt);
\end{scriptsize}
\end{tikzpicture}
&lt;/script&gt;
&lt;p&gt;Алгоритм нахождения минимальной покрывающей окружности, проходящей через новую точку аналогичен алгоритму, который мы только что рассмотрели. Мы перебираем все остальные точки в случайном порядке, и если новая точка лежит вне текущей окружности, то эту окружность нужно перестроить. Вероятность того, что новая точка лежит на минимальной окружности не больше $\frac{2}{k}$, поэтому алгоритм будет линейным.&lt;/p&gt;
&lt;p&gt;Остается последний этап: зафиксированы уже две точки и нужно построить минимальную покрывающую окружность, проходящую через них. Алгоритм аналогичен. Начинаем с окружности, построенной на отрезке между этими двумя точками как на диаметре, а затем добавляем остальные точки в случайном порядке. Вероятность, что окружность нужно перестроить не больше $\frac{1}{k}$, при этом если зафиксированы уже три точки на окружности, то окружность определяется однозначно.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Проверка пересечения полуплоскостей на непустоту за $O(n)$</title>
      <link>https://peltorator.ru/posts/halfplanes_intersection_linear/</link>
      <pubDate>Tue, 14 Sep 2021 13:04:00 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/halfplanes_intersection_linear/</guid>
      
      <description>&lt;p&gt;Решим за линейное время следующую задачу:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача:&lt;/strong&gt;
Даны $n$ полуплоскостей. Требуется найти точку, лежащую во всех этих полуплоскостях, либо сказать, что такой нет.&lt;/p&gt;
&lt;p&gt;Задачу пересечения полуплоскостей можно решить за время $O(n \log n)$ различными способами. Они находят не только одну точку, но все множество пересечения.
Мы же рассмотрим рандомизированный алгоритм, работающий за ожидаемое время $O(n)$.&lt;/p&gt;
&lt;p&gt;Давайте будем добавлять полуплоскости по одной в случайном порядке, поддерживая самую высокую точку в множестве пересечения уже добавленных полуплоскостей (Если таких точек несколько, то самую левую из них. При этом изначально ограничим все квадратом $[-10^9, 10^9] \times [-10^9, 10^9]$ при помощи четырех полуплоскостей, чтобы не было проблем с тем, что эта точка бесконечно удалена).&lt;/p&gt;
&lt;script type=&#34;text/tikz&#34;&gt;
\definecolor{zzttqq}{rgb}{0.6,0.2,0.}

\begin{tikzpicture}[line cap=round,line join=round,x=1.0cm,y=1.0cm]
%\clip(-4.3,-8.46) rectangle (20.1,6.3);
\fill[line width=2.pt,color=zzttqq,fill=zzttqq,fill opacity=0.10000000149011612] (1.,-0.58) -- (5.746558852614512,3.8050659598657246) -- (7.395232164677132,3.2526971519879693) -- (9.412625948614792,0.253291579043614) -- (3.82,-4.) -- (1.,-4.) -- cycle;
\draw [line width=2.pt] (1.,5.)-- (1.,-4.);
\draw [line width=2.pt] (1.,-4.)-- (10.,-4.);
\draw [line width=2.pt] (10.,-4.)-- (10.,5.);
\draw [line width=2.pt] (10.,5.)-- (1.,5.);
\draw [line width=2.pt] (7.04,5.)-- (1.,-0.58);
\draw [line width=2.pt] (2.18,5.)-- (10.,2.38);
\draw [line width=2.pt] (6.22,5.)-- (10.,-0.62);
\draw [line width=2.pt] (10.,0.7)-- (3.82,-4.);
\draw [line width=2.pt,color=zzttqq] (1.,-0.58)-- (5.746558852614512,3.8050659598657246);
\draw [line width=2.pt,color=zzttqq] (5.746558852614512,3.8050659598657246)-- (7.395232164677132,3.2526971519879693);
\draw [line width=2.pt,color=zzttqq] (7.395232164677132,3.2526971519879693)-- (9.412625948614792,0.253291579043614);
\draw [line width=2.pt,color=zzttqq] (9.412625948614792,0.253291579043614)-- (3.82,-4.);
\draw [line width=2.pt,color=zzttqq] (3.82,-4.)-- (1.,-4.);
\draw [line width=2.pt,color=zzttqq] (1.,-4.)-- (1.,-0.58);
\begin{scriptsize}
\draw [fill=yellow] (5.746558852614512,3.8050659598657246) circle (2.0pt);
\end{scriptsize}
\end{tikzpicture}
&lt;/script&gt;
&lt;p&gt;Тогда если при добавлении новой полуплоскости эта точка лежит в очередной полуплоскости, то ничего не поменяется, потому что множество пересечения могло только уменьшиться, но при этом его верхняя точка сохранилась.&lt;/p&gt;
&lt;p&gt;Если же эта точка не лежит в новой полуплоскости, то придется заново искать самую верхнюю точку. Заметим, что эта новая точка обязана лежать на прямой, высекающей новую полуплоскость. То есть нам надо найти самую высокую точку на прямой, лежащую в пересечении полуплоскостей. Но ведь все остальные полуплоскости высекают на этой прямой какие-то лучи. Поэтому нам надо найти самую высокую точку в пересечении лучей. Для этого надо отдельно посмотреть на все лучи, смотрящие вниз, и взять из них самый нижний (начинается в точке $A$). Аналогично взять все лучи, смотрящие вверх, и взять из них самый верхний. Проверить, что эти два луча пересекаются, и в таком случае взять точку $A$. Это можно сделать за линейное время.&lt;/p&gt;
&lt;script type=&#34;text/tikz&#34;&gt;
\definecolor{ffxfqq}{rgb}{1.,0.4980392156862745,0.}
\definecolor{ffffqq}{rgb}{1.,1.,0.}
\definecolor{ffccww}{rgb}{1.,0.8,0.4}

\begin{tikzpicture}[line cap=round,line join=round,x=1.0cm,y=1.0cm]
%\clip(-4.3,-7.32) rectangle (20.1,7.44);
\draw [line width=2.pt,color=ffccww] (1.,4.)-- (10.,-4.);
\draw [line width=2.pt] (8.72,2.6)-- (-0.84,1.92);
\draw [line width=2.pt] (-1.3,-0.58)-- (8.34,3.3);
\draw [line width=2.pt] (-1.94,0.42)-- (5.36,4.76);
\draw [line width=2.pt] (8.62,3.96)-- (7.36,-4.44);
\draw [line width=2.pt] (4.92,-4.18)-- (11.36,-0.7);
\draw [line width=2.pt] (9.78,1.3)-- (4.28,-3.98);
\draw [line width=2.pt,color=ffxfqq] (3.8297465191003215,1.4846697607997144)-- (7.019182692307692,-1.350384615384615);
\begin{scriptsize}
\draw [fill=ffffqq] (3.8297465191003215,1.4846697607997144) circle (2.0pt);
\end{scriptsize}
\end{tikzpicture}
&lt;/script&gt;
&lt;p&gt;Почему этот алгоритм работает за линейное время? Доказывается это точно так же, как и для поиска двух ближайших точек на плоскости. Самая верхняя левая точка лежит на пересечении двух прямых, высекающих полуплоскости. Тогда вероятность того, что случайно выбранная прямая лежит на краю равна $\frac{2}{k}$. Асимптотика алгоритма равна $\sum_{k = 1}^{n} k \cdot \frac{2}{k} = \sum_{k = 1}^{n} 2 = 2n = O(n)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Если больше, чем две полуплоскости, пересекаются в одной точке, то легко заметить, что вероятность от этого становится только меньше. Либо эта точка и раньше уже была самой верхней левой, либо же вероятность правильно выбрать нужную прямую не больше $\frac{2}{k}$.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Поиск пары ближайших точек за $O(n)$</title>
      <link>https://peltorator.ru/posts/closest_points_linear/</link>
      <pubDate>Tue, 14 Sep 2021 12:41:00 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/closest_points_linear/</guid>
      
      <description>&lt;p&gt;Решим за линейное время следующую задачу:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача:&lt;/strong&gt;
Даны $n$ точек на плоскости. Требуется найти такую пару точек, что расстояние между ними минимально среди всех расстояний между всеми парами данных точек.&lt;/p&gt;
&lt;p&gt;У этой задачи есть детерминированный алгоритм, основанный на идее &amp;laquo;разделяй и властвуй&amp;raquo;, работающий за $O(n \log n)$.
Мы же рассмотрим рандомизированный алгоритм, работающий за ожидаемое время $O(n)$.&lt;/p&gt;
&lt;p&gt;Давайте будем постепенно добавлять точки по одной в случайном порядке, поддерживая пару ближайших точек. Пусть на данный момент уже было добавлено сколько-то точек, и текущее минимальное расстояние равно $d$. Побьем всю плоскость на квадраты $d \times d$ и для каждого квадрата в хеш-таблице будем хранить все точки, находящиеся в этом квадрате. При этом можно заметить, что так как на данный момент минимальное расстояние между точками равно $d$, то расстояние между любой парой точек не меньше $d$, поэтому в каждом квадрате не больше $4$ точек.&lt;/p&gt;
&lt;script type=&#34;text/tikz&#34;&gt;
\begin{tikzpicture}[line cap=round,line join=round,x=1.0cm,y=1.0cm]
\draw [line width=2.pt] (0.,3.)-- (0.,-3.);
\draw [line width=2.pt] (2.5,3.)-- (2.5,-3.);
\draw [line width=2.pt] (5.,3.)-- (5.,-3.);
\draw [line width=2.pt] (7.5,3.)-- (7.5,-3.);
\draw [line width=2.pt] (-0.5,2.5)-- (8.,2.5);
\draw [line width=2.pt] (8.,0.)-- (-0.5,0.);
\draw [line width=2.pt] (-0.5,-2.5)-- (8.,-2.5);
\begin{scriptsize}
\draw [fill=blue] (5.,0.) circle (2.5pt);
\draw [fill=blue] (5.,-2.5) circle (2.5pt);
\draw [fill=blue] (7.5,-2.5) circle (2.5pt);
\draw [fill=blue] (7.5,0.) circle (2.5pt);
\draw [fill=blue] (1.2,2.32) circle (2.5pt);
\draw [fill=blue] (0.14,0.22) circle (2.5pt);
\draw [fill=blue] (2.14,0.32) circle (2.5pt);
\draw [fill=blue] (3.82,2.24) circle (2.5pt);
\draw [fill=blue] (6.72,2.26) circle (2.5pt);
\draw [fill=blue] (2.84,-1.1) circle (2.5pt);
\draw [fill=blue] (0.22,-2.25) circle (2.5pt);
\end{scriptsize}
\end{tikzpicture}
&lt;/script&gt;
&lt;p&gt;Заметим, что если мы добавляем какую-то новую точку, то если минимальное расстояние изменилось, то есть какая-то точка, которая находится на расстоянии меньше $d$ от новой точки. При этом обратим внимание на то, что эта точка должна находиться либо в том же квадрате $d \times d$, либо в соседнем (по стороне или диагонали), ведь если нарисовать круг радиуса $d$ с центром в новой точке, он целиком будет лежать в квадрате $3d \times 3d$, в центральном квадрате которого лежит новая точка.&lt;/p&gt;
&lt;script type=&#34;text/tikz&#34;&gt;
\definecolor{xdxdff}{rgb}{0.49019607843137253,0.49019607843137253,1.}
\definecolor{ffzzqq}{rgb}{1.,0.6,0.}
\definecolor{ududff}{rgb}{0.30196078431372547,0.30196078431372547,1.}

\begin{tikzpicture}[line cap=round,line join=round,x=1.0cm,y=1.0cm]
%\clip(-2.3879877682440735,-6.345539414293429) rectangle (16.523412413538978,5.094307580916252);
\draw [line width=2.pt] (0.,2.5)-- (0.,-5.);
\draw [line width=2.pt] (0.,-5.)-- (7.5,-5.);
\draw [line width=2.pt] (7.5,-5.)-- (7.5,2.5);
\draw [line width=2.pt] (7.5,2.5)-- (0.,2.5);
\draw [line width=2.pt] (0.,0.)-- (7.5,0.);
\draw [line width=2.pt] (7.5,-2.5)-- (0.,-2.5);
\draw [line width=2.pt] (2.56,2.54)-- (2.5,-5.);
\draw [line width=2.pt] (5.,2.5)-- (5.,-5.);
\draw [line width=2.pt,color=ffzzqq] (3.3,-0.75) circle (2.5068905041903986cm);
\draw [line width=2.4pt] (3.3,-0.75)-- (4.166189323170816,1.602491457248012);
\begin{scriptsize}
\draw [fill=ududff] (3.3,-0.75) circle (2.5pt);
\draw [fill=xdxdff] (4.166189323170816,1.602491457248012) circle (2.5pt);
\end{scriptsize}
\end{tikzpicture}
&lt;/script&gt;
&lt;p&gt;Так как в каждом квадрате лежит не больше $4$ точек, нам придется перебрать не более $9 \cdot 4 = 36$ точек в поиске пары для новой точки. То есть добавление новой точки будет происходить за константное время. Однако если мы все таки нашли новую пару, то нам придется перестроить всю структуру квадратов, потому что $d$ уменьшится.&lt;/p&gt;
&lt;p&gt;Кажется, что такой алгоритм будет работать за квадратичное время, однако вспомним, что мы добавляем точки в случайном порядке! Заметим, что если мы перестроили структуру после добавления $k$-й точки, то это одна из двух точек в паре самых близких. Так как эта точка была выбрана случайно, то вероятность такого события — $\frac{2}{k}$ (если есть несколько одинаковых минимальных расстояний, то либо до добавления этой точки расстояние уже было таким, и ничего перестраивать не надо, либо же во всех таких минимальных расстояниях одной из точек является наша новая точка, и тогда вероятность еще меньше — $\frac{1}{k}$). Если это событие произошло, то нам нужно перестроить заново структуру. Это происходит за $O(k)$. Поэтому ожидаемое время работы равно $\sum_{k = 1}^{n} \frac{2}{k} \cdot k = \sum_{k = 1}^{n} 2 = 2n = O(n)$. Что и требовалось доказать.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Если координаты точек целые, то в алгоритме можно обойтись без вещественных чисел. Вместо минимального расстояния будем хранить его квадрат, а делить на квадраты будем со стороной не $d$, а $\left\lfloor d \right\rfloor$. Очевидно, от этого асимптотика не поменяется.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Чтобы получить номер квадрата, в котором находится точка, вы скорее всего будете делить его координаты на $d$. Будьте внимательны, что если в множестве есть совпадающие точки, то $d$ может стать равно нулю. В этом случае нужно сразу завершиться, потому что более близких точек точно уже не будет.&lt;/p&gt;
&lt;p&gt;С реализацией можно ознакомиться по &lt;a href=&#34;https://pastebin.com/zwSY4tHq&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Легко обобщить этот алгоритм для бóльших размерностей. Нужно побить пространство на кубы со стороной $d$ и искать пару для новой точки во всех соседних кубах. Для фиксированной размерности алгоритм будет все еще линейным.&lt;/p&gt;
&lt;h2 id=&#34;задачи-для-практики&#34;&gt;Задачи для практики&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://codeforces.com/contest/120/problem/J&#34;&gt;https://codeforces.com/contest/120/problem/J&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Дискретное логарифмирование</title>
      <link>https://peltorator.ru/posts/discrete_log/</link>
      <pubDate>Tue, 14 Sep 2021 12:35:00 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/discrete_log/</guid>
      
      <description>&lt;p&gt;Даны числа $a$, $b$ и $m$. Необходимо найти такой $x$, что $a^x = b \mod m$. При этом $gcd(a, m) = 1$, но $m$ не обязано быть простым.&lt;/p&gt;
&lt;p&gt;Ответ есть не всегда, к примеру, при $a = 1$ и $b \neq 1$.&lt;/p&gt;
&lt;p&gt;Сделаем корневую декомпозицию. Известно, что $x \in [0, m - 1]$. Пусть $k = \left\lfloor \sqrt{m} \right\rfloor$. Посчитаем числа вида $a^{k n}$ для $0 \le n \le \left\lceil \sqrt{m} \right\rceil $ и положим их в &lt;code&gt;unordered_map&lt;/code&gt;. Пусть ответ — это $x$. $x = ki - j$, где $0 \le j &amp;lt; k$.&lt;/p&gt;
&lt;p&gt;Тогда равенство можно записать как $a^{ki} = b \cdot a^j \mod p$. Числа слева у нас сохранены. Осталось последовательно домножать $b$ на $a$, пока такое число не попадется среди сохраненных.&lt;/p&gt;
&lt;p&gt;Получается асимптотика $O(\sqrt{m})$.&lt;/p&gt;
&lt;p&gt;Это хорошо, но на выполнение $n$ запросов уйдет $O(n \sqrt{m})$ времени.&lt;/p&gt;
&lt;p&gt;Давайте делать лучше. Пусть $m$ — это $2$, $4$, $p^k$ или $2 \cdot p^k$. Найдем заранее $g$ — первообразный корень по модулю $m$ (он как раз существует ровно для таких $m$) и число $\varphi(m)$. Это можно сделать за $\sqrt{m}$. Затем вместо нахождения логарифма $b$ с основанием $a$, мы будем искать логарифмы обоих чисел по основанию $g$, а потом их надо будет просто поделить друг на друга по модулю $\varphi(m)$.&lt;/p&gt;
&lt;p&gt;Заметим, что если мы всегда логарифмируем с фиксированным основанием, то первый шаг, на котором мы насчитываем все числа вида $g^{kn}$ можно не выполнять каждый раз, а только один раз в самом начале. Тогда можно взять $k \neq \sqrt{m}$.&lt;/p&gt;
&lt;p&gt;Первая фаза работает за $m / k$ и выполняется один раз. Тогда фаза подсчета работает за $O(k)$. Асимптотика — $O(m/k + nk)$. Возьмем $m/k = nk$ для оптимальной асимптотики. $k = \sqrt{m/n}$. Время работы $O(\sqrt{mn} + n \log m)$.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Квадратный корень по простому модулю за $O(\log p)$</title>
      <link>https://peltorator.ru/posts/square_root_mod/</link>
      <pubDate>Tue, 14 Sep 2021 12:32:00 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/square_root_mod/</guid>
      
      <description>&lt;p&gt;Задача формулируется следующим образом.
Даны числа $a$ и $p$. При этом $p$ — простое. Нужно найти такое $z$, что $z^2 \bmod p = a$ или сказать, что такого $z$ не существует.&lt;/p&gt;
&lt;p&gt;Давайте опишем алгоритм.&lt;/p&gt;
&lt;p&gt;Если $p = 2$ или $a = 0$, то $z = a$.&lt;/p&gt;
&lt;p&gt;Иначе $p \ge 3$, $a \ge 1$.&lt;/p&gt;
&lt;p&gt;Если $a^{(p-1)/2} \neq 1 \mod p$,  то ответа не существует. Иначе же ответ есть.&lt;/p&gt;
&lt;p&gt;Запускаем бесконечный цикл, пока не найдем ответ. В нем выбираем $i$ случайным образом из чисел $1, 2, \ldots, p - 1$. Считаем многочлен $T(x)  := (x+i)^{(p-1)/2} - 1 \mod (x^2 - a) = bx + c$ бинарным возведением в степень и взятием по модулю каждый раз.&lt;/p&gt;
&lt;p&gt;После чего если $b \neq 0$, то возьмем $z&#39; = c/b = c \cdot b^{p - 2} \mod p$ и проверим, подходит ли оно (возведем в квадрат). Если подходит, вернем, иначе продолжаем перебирать $i$.&lt;/p&gt;
&lt;p&gt;Почему этот алгоритм работает?
Крайние случаи очевидны. Иначе, числа, у которых есть корень, называются квадратичными вычетами. Давайте заметим, что у каждого числа ровно $2$ корня, либо ровно $0$ (если есть корень, то подходит и минус корень, а больше быть не может, потому что $z^2 = t^2 \mod p$ решается только так). То есть у нас есть ровно $(p-1)/2$ чисел, являющихся квадратичными вычетами и $(p-1)/2$, не являющихся.
$x^{p-1} = 1 \mod p$, так что для проверки, является ли $a$ квадратом, можно возвести в $(p-1)/2$ степень. То есть проверка на несуществование ответа верная. Теперь осталось его найти!&lt;/p&gt;
&lt;p&gt;Пусть $z^2 = a \mod p$.
Корни многочлена $x^2 - a$ — это как раз $z$ и $-z$.&lt;/p&gt;
&lt;p&gt;В каком случае они будут являться корнями многочлена $T$? Если $z + i$ и $-z + i$ являются квадратичными вычетами. Нас интересует ситуация, когда ровно один из них — квадратичный вычет. Пусть это $z + i$. Тогда $z$ — корень обоих многочленов, так что после взятия по модулю ответ делится на $x - z$. При этом ответ — многочлен не более, чем первой степени. Так что он имеет вид $dx - dz$. Тогда если мы поделим коэффициенты, то получим как раз $z$. Аналогично, если $-z$ — корень обоих многочленов. Обратите внимание, что $d \neq 0$, потому что в этом случае оба числа $\pm z$ являются корнями.&lt;/p&gt;
&lt;p&gt;Осталось понять, почему этот алгоритм будет работать быстро. Итерация работает за $O(\log p)$. Докажем, что вероятность успеха — $1/2$, тогда матожидание количества шагов будет равно двум.&lt;/p&gt;
&lt;p&gt;Если ровно одно из чисел $z + i$ и $-z + i$ является квадратичным вычетом, то $(z + i)^{(p-1)/2} \neq (-z + i)^{(p-1)/2} \mod p$. При этом одно из этих чисел — $1$, а другое — $-1$.
Поделим одну часть на другую. $((z+i)/(-z+i))^{(p-1)/2} = -1 \mod p$. То есть это верно, если отношение — не вычет. Докажем, что все такие числа вида $(z+i)/(-z+i)$ различны для всех $i$, тогда это будет как раз биекция во все вычеты, так что вероятность равна $1/2$.&lt;/p&gt;
&lt;p&gt;Пусть $(z +i)/(-z+i) = (z+j)/(-z+j) \mod p$. Домножим на знаменатели, сократим, получим, что $2iz = 2jz \mod p$, то есть $i = j \mod p$.&lt;/p&gt;
&lt;p&gt;Вероятность не совсем $1/2$, потому что нужно, чтобы $z + i \neq 0$ и $-z + i \neq 0$. Так что нам не подходят еще два вычета. Алгоритм от этого не страдает, просто для малых $p$ вероятность становится чуть меньше. Можно доказать, что для $p = 3$ все равно все работает.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Сумма мультипликативной функции: Powerful Number Sieve</title>
      <link>https://peltorator.ru/posts/powerful_number_sieve/</link>
      <pubDate>Tue, 14 Sep 2021 12:04:00 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/powerful_number_sieve/</guid>
      
      <description>&lt;p&gt;&lt;strong&gt;Автор статьи: Александр Голованов&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача:&lt;/strong&gt;
Дана мультипликативная функция $f(n)$, а также число $N$. Необходимо посчитать $s_f(N) = \sum_{k=1}^Nf(k)$.&lt;/p&gt;
&lt;p&gt;Мы умеем делать это за $O(n^{2/3})$, если нам известна мультипликативная функция $g$, для которой мы умеем считать $s_g$ и $s_{f*g}$ за $O(1)$ при помощи &lt;a href=&#34;https://peltorator.ru/try_web/post/mobius_convolution/&#34;&gt;обращения Мёбиуса&lt;/a&gt;. Оказывается, зачастую это можно делать быстрее, если функции обладают некоторыми дополнительными свойствами.&lt;/p&gt;
&lt;p&gt;Пусть $g(n)$ и $h(n)$ — такие мультипликативные функции, что $f = h*g$. Тогда верна следующая лемма:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Лемма:&lt;/strong&gt;
$$s_f(n) = \sum_{k=1}^nh(k)s_g\left(\left\lfloor\frac{n}{k}\right\rfloor\right)$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
В сумме слева есть все возможные слагаемые вида $h(k) \cdot g(l)$, где $k \cdot l \le n$. Таким образом, для фиксированного $k$ мы должны перемножить $h(k)$ со всеми такими $g(l)$, что $l \le \left\lfloor \frac{n}{k} \right\rfloor$, то есть с префиксной суммой $g$. Что и требовалось доказать.&lt;/p&gt;
&lt;p&gt;Пускай функция $h$ такова, что $h(p) = 0$ для любого простого $p$.
Тогда заметим, что в правой части выражения из леммы те слагаемые, в которых $k$ содержит в себе некоторый простой множитель ровно в первой степени, зануляются (из свойства функции $h$). Остальные же числа содержат каждый свой простой множитель хотя бы во второй степени. Будем называть такие числа &lt;em&gt;сильными&lt;/em&gt; (от английского &lt;em&gt;powerful&lt;/em&gt;, которое происходит от слова &lt;em&gt;power&lt;/em&gt; в значении &amp;laquo;степень&amp;raquo;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Лемма:&lt;/strong&gt;
Всякое сильное число $n$ можно представить в виде $a^2b^3$ для некоторых натуральных $a$ и $b$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
Для этого нужно представить каждую степень простого $p_i^{\alpha_i}$, входящую в $n$, в таком виде, а потом перемножить их. То есть надо просто представить степень $\alpha_i$ в виде $2x + 3y$. Безусловно, это можно сделать, так как $\alpha_i \ge 2$ (для четного $n$ можно взять $x = \frac{n}{2}$ и $y = 0$, а для нечетного подойдет решение $x = \frac{n - 3}{2}$ и $y = 1$).&lt;/p&gt;
&lt;p&gt;Тогда для вычисления $s_f$ нам нужно научиться эффективно перебирать все сильные числа $k$ и суммировать $h(k) s_g\left(\left\lfloor \frac{n}{k} \right\rfloor\right)$. Будем делать это рекурсивно, перебирая простые числа по возрастанию и выбирая их в степени либо ноль, либо хотя бы два. Обратите внимание на то, что если простое число $p$ входит в разложение сильного числа $k$, то $p \le \sqrt{k} \le \sqrt{n}$, потому что каждый простой множитель входит в $k$ хотя бы во второй степени, поэтому перебирать простые мы можем только до $\sqrt{n}$.&lt;/p&gt;
&lt;p&gt;Рассмотрим следующий алгоритм вычисления функции $s_f$:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;s_f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new_value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new_value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s_g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;primes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;primes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// can&amp;#39;t multiply anymore
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s_f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;primes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;primes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s_f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;primes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Здесь &lt;code&gt;primes&lt;/code&gt; — массив с простыми числами хотя бы до $\sqrt{N}$; &lt;code&gt;cur&lt;/code&gt; — текущее значение $k$, которое мы перебираем рекурсивно; &lt;code&gt;idx&lt;/code&gt; — индекс текущего простого из списка &lt;code&gt;primes&lt;/code&gt;; &lt;code&gt;new_value&lt;/code&gt; — флаг, который нужен, чтобы мы не прибавили одно и то же значение к ответу несколько раз, когда мы не берем текущее простое в разложение; а тип &lt;code&gt;T&lt;/code&gt; может быть любым типом на Ваш выбор: например, &lt;code&gt;long long&lt;/code&gt; или Ваш класс для модульной арифметики.&lt;/p&gt;
&lt;p&gt;Легко видеть, что этот алгоритм вычисляет $s_f$, перебирая лишь сильные числа. Оценим время его работы. Будем считать, что значение функции $s_g$ в точке $n$ мы можем вычислить за время $T_{s_g}(n)$, а вычисление $h(cur)$ работает за $O(1)$ (оно может считаться на лету по мультипликативности через значения в степенях простых). Тогда&lt;/p&gt;
&lt;p&gt;$$T_{s_f(n)} = \sum_{k\text{ is powerful}}T_{s_g}\left(\left\lfloor\frac{N}{k}\right\rfloor\right)\leq\sum_{a, b : a^2b^3\leq N}T_{s_g}\left(\frac{N}{a^2b^3}\right)\approx\int\limits_{1}^{\sqrt{N}}\int\limits_{1}^{\sqrt[3]{N/a^2}}T_{s_g}\left(\frac{N}{a^2b^3}\right)\ \mathrm{d}b\ \mathrm{d}a$$&lt;/p&gt;
&lt;p&gt;Для простоты предположим, что $T_{s_g}(n) = n^c$, где $c &amp;gt; 1/3$. Тогда&lt;/p&gt;
&lt;p&gt;$$
\int\limits_{1}^{\sqrt{N}}\int\limits_{1}^{\sqrt[3]{N/a^2}}T_{s_g}\left(\frac{N}{a^2b^3}\right)\ \mathrm{d}b\ \mathrm{d}a = \int\limits_{1}^{\sqrt{N}}\int\limits_{1}^{\sqrt[3]{N/a^2}}\frac{N^c}{a^{2c}b^{3c}}\ \mathrm{d}b\ \mathrm{d}a = N^c \int\limits_{1}^{\sqrt{N}} a^{-3c} \int\limits_{1}^{\sqrt[3]{N / a^2}} b^{-3c} \ \mathrm{d}b\ \mathrm{d}a =
$$&lt;/p&gt;
&lt;p&gt;$$
=  N^c \int\limits_{1}^{\sqrt{N}} a^{-2c} \cdot (3c - 1) \cdot (1 - const_1) \ \mathrm{d}a \le
$$&lt;/p&gt;
&lt;p&gt;$$
\le (3c - 1)N^c\int\limits_{1}^{\sqrt{N}} a^{-2c} \  \mathrm{d}a\leq
\begin{cases}
(1 - 2c)(3c - 1)N^c\cdot N^{1/2 - c} = O(\sqrt{N}), &amp;amp; c &amp;lt; \frac{1}{2}, \\&lt;br&gt;
(3c - 1)N^c\ln\sqrt{N} = O(\sqrt{N}\log{n}), &amp;amp; c = \frac{1}{2}, \\&lt;br&gt;
(3c - 1)(2c - 1)N^c = O(T_{s_g}(N)), &amp;amp; c &amp;gt; \frac{1}{2}.
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;Где $const_1$ — какое-то положительное число.&lt;/p&gt;
&lt;p&gt;Очевидно, если $c \le 1/3$, то время работы и подавно составляет $O(\sqrt{N})$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Пример:&lt;/strong&gt;
Если $f(n)=\mathrm{rad}(n)$, то есть $f(p_1^{\alpha_1} \cdot \ldots \cdot p_k^{\alpha_k}) = p_1p_2 \cdot \ldots \cdot p_k$, то в качестве $h(n)$ можно взять мультипликативную функцию, для которой верно $h(1) = 1$, $h(p) = 0$ и $h(p^k) = p - p^2$ для всех $k &amp;gt; 1$, а в качестве $g$ можно взять $g(n) = n$. Легко проверить, что $f = g * h$. Тогда сумма $f(n)$ на префиксе размера $N$ будет считаться за $O(\sqrt{N})$, потому что $T_{s_g}(n) = O(1)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Как видно из примера, при поиске функций $h$ и $g$ имеет смысл подобрать их значения на степенях простых.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
При оценке времени работы мы пользовались представимостью сильных чисел в виде $a^2b^3$. Казалось бы, можно было бы написать два for-а по числам $a$ и $b$, и такой алгоритм был бы проще рекурсивного перебора сильных чисел. Однако сильные числа бывают представимы в таком виде больше, чем одним способом, поэтому при таком алгоритме придётся каким-то образом проверять числа на уникальность, что может повлиять на время работы.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Поиск факториала по простому модулю за $O(\sqrt{\min (p, n)} \log n)$</title>
      <link>https://peltorator.ru/posts/mod_factorial_fast/</link>
      <pubDate>Mon, 13 Sep 2021 18:32:00 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/mod_factorial_fast/</guid>
      
      <description>&lt;p&gt;В прошлом разделе мы научились искать $n! \mod p$ без вхождений $p$ в факториал за $O(p \log_p n)$ или за $O(p + \log_p n)$, если заранее предпосчитать все факториалы. Однако чаще всего модуль — это число порядка $10^9$, поэтому эти алгоритмы нам не подходят. Давайте научимся искать факториал быстрее.&lt;/p&gt;
&lt;p&gt;Давайте сначала научимся искать $n! \mod p$ за $O(\sqrt{n} \log n)$, если $n &amp;lt; p$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
В зависимости от аккуратности реализации $\log n$ может быть в какой-то степени.&lt;/p&gt;
&lt;p&gt;Обозначим $k = \left\lfloor \sqrt{n} \right\rfloor$. Тогда мы хотим построить алгоритм за $O(k \log k)$. Пусть $n = k^2 + b$, где $b \le 2 \cdot k$. В таком случае нам достаточно посчитать $\left(k^2\right)!$, а затем за $O(k)$ домножить его на $b$ недостающих чисел.&lt;/p&gt;
&lt;p&gt;Построим многочлен $P(x) := (kx) \cdot (kx - 1) \cdot \ldots \cdot (kx - k + 1)$. Тогда $\left(k^2\right)! = P(1) \cdot P(2) \cdot \ldots \cdot P(k)$. Введем еще один многочлен $Q(x) := P(2x) \cdot P(2x - 1)$. Получается, что $\left(k^2\right)! = Q(1) \cdot Q(2) \cdot \ldots \cdot Q\left(\frac{k}{2}\right)$, если $k$ четно, а если $k$ нечетно, то еще нужно домножить на $P(k)$, но его мы легко можем сделать за $O(k)$.&lt;/p&gt;
&lt;p&gt;Теперь давайте рекурсивно запустимся от многочлена $Q$. Глубина рекурсии будет $\log k$. Однако проблема в том, что изначально многочлен $P$ имел степень $k$, однако многочлен $Q$ имеет степень уже $2k$, и степень будет возрастать. Но если учесть, что многочлен $Q$ нам нужно посчитать только в точках $1, 2, \ldots, \left\lfloor \frac{k}{2} \right\rfloor$, то можно взять вместо $Q$ многочлен $Q \bmod (x - 1) \cdot (x - 2) \cdot \ldots \cdot (x - \left\lfloor \frac{k}{2} \right\rfloor)$. И у такого многочлена уже степень будет $&amp;lt; \left\lfloor \frac{k}{2} \right\rfloor$.&lt;/p&gt;
&lt;p&gt;Взятие двух многочленов по модулю можно реализовать за $O(k \log k)$. Тогда асимптотика алгоритма получается $O\left(k \log k + \frac{k}{2} \log \left( \frac{k}{2} \right) + \frac{k}{4} \log \left(\frac{k}{4} \right) + \ldots\right) = O\left(\left(k + \frac{k}{2} + \frac{k}{4} + \ldots\right) \log k\right) = O(k \log k)$. Что и требовалось.&lt;/p&gt;
&lt;p&gt;Чтобы получить алгоритм, который работает при $n \ge p$, нужно просто применить алгоритм из &lt;a href=&#34;https://peltorator.ru/try_web/post/mod_factorial/&#34;&gt;предыдущего раздела&lt;/a&gt;, однако вычислять $b!$ с помощью нового метода. $b &amp;lt; p$, поэтому это вычисление будет работать не дольше $\sqrt{p} \log p$. Всего итераций будет $\log_p n$, так что асимптотика получается $O(\sqrt{p} \log p \cdot \log_p n) = O\left(\sqrt{p} \log p \frac{\log n}{\log p}\right) = O\left(\sqrt{p} \log n\right)$. Если объединить случаи $p &amp;lt; n$ и $p \ge n$, получается время работы $O\left(\sqrt{\min (p, n)} \log n\right)$.&lt;/p&gt;
&lt;h2 id=&#34;задачи-для-практики&#34;&gt;Задачи для практики&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.spoj.com/problems/FACTMODP/&#34;&gt;https://www.spoj.com/problems/FACTMODP/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Поиск факториала по простому модулю</title>
      <link>https://peltorator.ru/posts/mod_factorial/</link>
      <pubDate>Mon, 13 Sep 2021 18:25:00 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/mod_factorial/</guid>
      
      <description>&lt;p&gt;Часто в задачах бывает необходимо искать $n! \bmod p$. Обычно модуль — это большое число, а $n$ не очень большое, поэтому можно просто заранее предпосчитать все факториалы. Однако иногда бывает обратная ситуация: $p &amp;lt; n$. С первого взгляда кажется, что это бессмысленная задача: в $n!$ в таком случае входит число $p$, поэтому $n! \bmod p = 0$. Но часто нас не устраивает такой ответ, потому что нам часто нужно делить факториалы друг на друга. В этом случае мы можем получить выражения типа $\frac{0}{0}$, которое на самом деле равно чему-то ненулевому. Встает задача: посчитать $n! \bmod p$ без вхождений $p$ в $n!$ и отдельно посчитать степень вхождения $p$ в факториал, то есть представить $n!$ в виде $a \cdot p^k$, где $a$ не делится на $p$.&lt;/p&gt;
&lt;p&gt;Пускай $\left\lfloor \frac{n}{p} \right\rfloor = k$ и $n \bmod p = b$. Тогда&lt;/p&gt;
&lt;p&gt;$$n! = (1 \cdot 2 \cdot \ldots \cdot (p - 1)) \cdot p \cdot ((p + 1) \cdot (p + 2) \cdot \ldots \cdot (2p - 1)) \cdot (2p) \cdot \ldots \cdot (kp) \cdot ((kp + 1) \cdot \ldots \cdot (kp + b))$$&lt;/p&gt;
&lt;p&gt;Если брать это по модулю $p$, то получится&lt;/p&gt;
&lt;p&gt;$$(p - 1)! \cdot p \cdot (p - 1)! \cdot (2p) \cdot \ldots \cdot (p - 1)! \cdot (kp) \cdot b! = \left((p - 1)!\right)^k \cdot b! \cdot (k! \cdot p^k)$$&lt;/p&gt;
&lt;p&gt;При этом $p^k$ мы игнорируем, потому что это вхождения $p$.&lt;/p&gt;
&lt;p&gt;По теореме Вильсона $(p - 1)! \bmod p = -1$. Так что нам необходимо посчитать $(-1)^k \cdot b! \cdot k!$.
При этом $b &amp;lt; p$ (это остаток от деления на $p$), так что $b!$ можно посчитать за $O(p)$, после чего рекурсивно запуститься для подсчета $k!$. Каждый раз мы делим число $n$ на $p$, так что будет всего $\log_p n = \frac{\log n}{\log p}$ итераций. Асимптотика — $O(p \log_p n)$. С другой стороны, все факториалы до $p$ можно предпосчитать заранее, и тогда асимптотика будет $O(\log_p n)$ на запрос и $O(p)$ на предпосчет.&lt;/p&gt;
&lt;p&gt;Реализация представлена ниже:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;modFactorial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factorial&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;factorial&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1LL&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factorial&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;factorial&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1LL&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factorial&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factorial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;С другой стороны, если нам надо посчитать степень вхождения $p$ в факториал, это делается еще проще. Давайте для этого посчитаем количество чисел, которые делятся на $p$, на $p^2$, на $p^3$ и т.д. И тогда если число делится ровно на $p^k$, то мы учтем его как раз $k$ раз. А если заметить, что количество чисел, делящихся на $p^i$, — это $\left\lfloor \frac{n}{p^i} \right\rfloor$, то получается такой незатейливый алгоритм:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;factorialPower&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;power&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;power&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;power&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Асимптотика равна $O(\log_p n)$.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Нахождение обратных ко всем остаткам за $O(p)$</title>
      <link>https://peltorator.ru/posts/all_mod_inv/</link>
      <pubDate>Mon, 13 Sep 2021 18:10:00 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/all_mod_inv/</guid>
      
      <description>&lt;p&gt;Часто бывает так, что в задаче нужно делить по модулю много раз. Это можно делать обычным алгоритмом взятия обратного по модулю за $O(\log p)$ на запрос. Если мы сделаем $n$ запросов, то асимптотика будет $O(n \log p)$. Сейчас мы рассмотрим алгоритм, который изначально предпосчитает обратные ко всем остаткам за $O(p)$, и тогда на запросы мы будем отвечать за $O(1)$. Если $n$ порядка $p$ или больше, то этот вариант будет более эффективен.&lt;/p&gt;
&lt;p&gt;Есть много разных алгоритмов, которые делают это. Здесь будут представлены два, пожалуй, самых простых: один очень простой в понимании и написании, а другой еще легче в написании, однако не настолько очевидный с точки зрения понимания и придумывания.&lt;/p&gt;
&lt;h2 id=&#34;метод-обратных-факториалов&#34;&gt;Метод обратных факториалов&lt;/h2&gt;
&lt;p&gt;Идея первого алгоритма заключается в том, что мы посчитаем все возможные факториалы и обратные факториалы, а любое обратное к какому-то остатку представим как отношение двух факториалов.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема:&lt;/strong&gt;
Теорема Вильсона гласит, что если $p$ — простое число, то&lt;/p&gt;
&lt;p&gt;$$
(p - 1)! \equiv -1 \pmod p
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Давайте заметим, что все остатки от $1$ до $p - 1$ разбиваются на пары вида $x$, $x^{-1}$. Произведение чисел в паре равно единице по модулю $p$.
Есть один крайний случай: когда $x = x^{-1}$. Это происходит в том случае, если $x^2 \equiv 1 \pmod p$, то есть
$x^2 - 1 = (x - 1) \cdot (x + 1)\  ⋮\ p$. Значит, $x \equiv \pm 1 \pmod p$. Тогда в итоге $(p - 1)!$ по модулю $p$ состоит из произведения нескольких единиц, а также одной $-1$. Так что $(p - 1)! \equiv -1 \pmod p$. Что и требовалось доказать.&lt;/p&gt;
&lt;p&gt;Зная этот факт, мы можем сразу понять, что $\left((p - 1)!\right)^{-1} \equiv -1 \pmod p$, потому что обратное к $-1$ — это $-1$. Таким образом, обратное к $(p - 1)!$ мы уже посчитали.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
На самом деле не обязательно было пользоваться этой формулой. Можно было посчитать за $O(p)$ число $(p - 1)!$, а потом бинарным возведением в степень найти к нему обратное за $O(\log p)$. Итоговая асимптотика бы от этого не пострадала.&lt;/p&gt;
&lt;p&gt;Мы уже нашли обратное к $(p - 1)!$. Как же найти обратное к $(p - 2)!$ теперь?
Заметим следующий факт:&lt;/p&gt;
&lt;p&gt;$$
\frac{1}{k!} = \frac{k + 1}{(k + 1)!}
$$&lt;/p&gt;
&lt;p&gt;Так что алгоритм нахождения всех обратных факториалов следующий: идем с конца, изначально устанавливаем, что обратное к $(p - 1)!$ — это $-1$, а затем пересчитываем по очереди обратное к $k!$ как обратное к $(k + 1)!$, умноженное на $k + 1$.&lt;/p&gt;
&lt;p&gt;Теперь пусть мы посчитали все факториалы и все обратные факториалы за $O(p)$. Как найти обратные ко всем остаткам? С этим нам поможет следующая формула:&lt;/p&gt;
&lt;p&gt;$$
\frac{1}{k} = \frac{(k - 1)!}{k!}
$$&lt;/p&gt;
&lt;p&gt;А отношение двух факториалов — это произведение первого факториала на обратное ко второму.&lt;/p&gt;
&lt;p&gt;Представим код алгоритма:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getAllModularInverses&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inverseFactorials&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;inverseFactorials&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// -1 mod p = p - 1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;inverseFactorials&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1LL&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inverseFactorials&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inverses&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factorial&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;inverses&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1LL&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factorial&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inverseFactorials&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;factorial&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1LL&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factorial&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inverses&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Весь алгоритм — это два прохода по числам от $1$ до $p - 1$, так что работает он за $O(p)$.
Потребление памяти тоже $O(p)$, потому что нужно хранить массивы факториалов и обратных факториалов.
От одного из них можно избавиться, если вычислять ответ на лету (в приведенном коде мы не хранили факториалы), однако не от обоих.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Упражнение:&lt;/strong&gt;
Придумайте модернизацию этого алгоритма, которая работает за $O(p)$, но при этом потребляет $O(\sqrt{p})$ памяти (считайте, что ответы — вектор &lt;code&gt;inverses&lt;/code&gt; — вы можете просто выводить на экран, и вам не нужно их хранить).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Замечание:&lt;/strong&gt;
Заметим, что можно считать обратные факториалы, начиная не обязательно с $p - 1$. Если нам нужно найти обратные ко всем остаткам от $1$ до $n$, то можно за $O(n)$ посчитать $n! \bmod p$, найти к нему обратное за $O(\log p)$ и потом аналогично представленному выше способу насчитать все обратные факториалы от $1$ до $n$. Тогда подсчет обратных ко всем остаткам от $1$ до $n$ будет работать за $O(n + \log p)$.&lt;/p&gt;
&lt;p&gt;Как вы можете видеть, алгоритм очень простой. Однако его редко получится где-то применить, потому что, во-первых, нахождение всех обратных по отдельности работает за $O(p \log p)$, что тяжело отсечь от $O(p)$ на неучебной задаче,
а во-вторых, модуль чаще всего — это число порядка $10^9$, поэтому вы не имеете возможности посчитать обратные ко всем остаткам, и использование стандартного алгоритма за $O(n \log p)$ дает более эффективное решение.&lt;/p&gt;
&lt;h2 id=&#34;алгоритм-одного-цикла&#34;&gt;Алгоритм одного цикла&lt;/h2&gt;
&lt;p&gt;Второй алгоритм пишется всего одним циклом. Однако чтобы его вспомнить, придется написать пару формул на бумажке.&lt;/p&gt;
&lt;p&gt;Алгоритм основывается на одном простом факте:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема:&lt;/strong&gt;
$$
\frac{1}{k} \equiv -\left\lfloor \frac{p}{k} \right\rfloor \cdot \frac{1}{p \bmod k} \pmod p
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
Давайте представим $p$ в виде $k \cdot x + y$, где $x = \left\lfloor \frac{p}{k} \right\rfloor$ и $y = p \bmod k$.&lt;/p&gt;
&lt;p&gt;Необходимо проверить, что&lt;/p&gt;
&lt;p&gt;$$k \cdot \left(-\left\lfloor \frac{p}{k} \right\rfloor \cdot \frac{1}{p \bmod k} \right) \equiv 1 \pmod p$$&lt;/p&gt;
&lt;p&gt;$$
k \cdot (-x \cdot \frac{1}{y}) = - (k \cdot x) \cdot \frac{1}{y} = - \left((k \cdot x + y) - y\right) \cdot \frac{1}{y} = - (p - y) \cdot \frac{1}{y} \equiv y \cdot \frac{1}{y} \equiv 1 \pmod p
$$&lt;/p&gt;
&lt;p&gt;Что и требовалось доказать.&lt;/p&gt;
&lt;p&gt;Таким образом, мы можем посчитать обратное к $k$, если уже посчитано обратное к $p \bmod k$. Заметим, что это число меньше, чем $k$,
поэтому все обратные можно вычислять по порядку.&lt;/p&gt;
&lt;p&gt;Реализация у этого алгоритма крайне проста:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getAllModularInverses&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inverses&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;inverses&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;inverses&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1LL&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inverses&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// +p because this number is negative
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inverses&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Также преимуществом этого метода является то, что это просто один цикл &lt;code&gt;for&lt;/code&gt; по возрастанию, поэтому можно считать обратные не ко всем остаткам, а к первым $n$ остаткам за $O(n)$ очень легко. Однако не очень ясно, для чего это может вам понадобиться.&lt;/p&gt;
&lt;p&gt;При тестировании на $p$ порядка $10^8$ второй алгоритм работает примерно в два раза быстрее, чем первый.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Персистентный Convex Hull Trick</title>
      <link>https://peltorator.ru/posts/persistent_cht/</link>
      <pubDate>Mon, 13 Sep 2021 17:52:00 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/persistent_cht/</guid>
      
      <description>&lt;p&gt;Во многих задачах на динамическое программирование используется &amp;ldquo;Convex Hull Trick&amp;rdquo; (CHT), то есть способ быстрого пересчета динамики как максимума или минимума линейных функций. Однако минусом этой техники является ее амортизированность: хранится стек прямых из выпуклой оболочки, и при добавлении новой прямой удаляются все бесполезные прямые с вершины стека. Одна конкретная такая операция может занимать $O(n)$ времени. В результате чего обычный convex hull trick нельзя сделать персистентным или использовать откаты. Для решения этой проблемы обычно используют &lt;a href=&#34;https://peltorator.ru/try_web/post/li-chao/&#34;&gt;дерево Ли Чао&lt;/a&gt;, которое является неамортизированной альтернативой CHT. В этой главе мы рассмотрим, как легко можно сделать персистентным сам convex hull trick.&lt;/p&gt;
&lt;p&gt;Нам нужно научиться за неамортизированное время удалять большое количество элементов с вершины стека (в принципе, предложенный алгоритм подходит не только конкретно для CHT). При помощи бинпоиска мы могли бы найти последнюю прямую на стеке, которую нужно оставить, но не понятно, как удалить все ненужные прямые быстро. Однако мы все равно хотим сделать наш стек персистентным, поэтому не будем ничего удалять, а создадим новую ветку. То есть вместо стека у нас будет дерево, и если мы находимся в какой-то вершине, то текущий стек — это все элементы на пути до корня. Это сразу решает и проблему амортизированности, и проблему персистентности. Однако появляется новая проблема — и при поиске последней прямой, которую нужно оставить, и при поиске минимума линейных функций в точке, мы используем бинпоиск по стеку. В дереве мы этого сделать, к сожалению, не можем.&lt;/p&gt;
&lt;p&gt;Для этого давайте в дереве хранить двоичные подъемы. Тогда вместо бинпоиска можно использовать подъем по дереву при помощи двоичных подъемов, который используется при поиске LA и LCA. Так как после каждой итерации добавляется ровно одна вершина в дерево как лист, то двоичные подъемы можно пересчитывать на лету для новой вершины. Асимптотика получившегося алгоритма — $O((n + q) \log n)$ на $n$ запросов добавления прямых и $q$ запросов получения минимума в точке. Используемая память — $O(n \log n)$. При помощи &lt;a href=&#34;https://peltorator.ru/try_web/post/linear_binups/&#34;&gt;двоичных подъемов с линейной памятью&lt;/a&gt; можно уменьшить потребляемую память до $O(n)$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Упражнение:&lt;/strong&gt; Дано подвешенное дерево. $p_v$ — предок вершины $v$ ($p_v &amp;lt; v$). В каждой его вершине $v$ находится какая-то линейная функция $v \cdot x + b_v$ и число $a_v$. Для каждой вершины дерева необходимо найти минимум по линейным функциям на пути до корня в точке $a_v$.&lt;/p&gt;
&lt;p&gt;В случае, если в задаче необходим динамический CHT, то есть прямые не упорядочены монотонно по углу наклона, задача становится немного сложнее. Обычно в таком случае прямые хранятся в &lt;code&gt;std::set&lt;/code&gt;, и при добавлении по обе стороны от добавляемой прямой удаляются ненужные. Чтобы сделать эту структуру неамортизированной, будем хранить вместо &lt;code&gt;std::set&lt;/code&gt; декартово дерево. Тогда спуском по дереву можно найти левую и правую границы отрезка прямых, которые нужно удалить, после чего можно вставить новую прямую. Спуск по дереву в данном случае является заменой стандартному бинпоиску. Чтобы сделать эту структуру персистентной, необходимо использовать персистентное декартово дерево.&lt;/p&gt;
&lt;p&gt;В отличие от простого алгоритма для обычного CHT, алгоритм для динамического CHT сложен в реализации, поэтому рекомендуется вместо него использовать все-таки дерево Ли Чао.&lt;/p&gt;
&lt;h2 id=&#34;задачи-для-практики&#34;&gt;Задачи для практики&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ceoi.inf.elte.hu/probarch/09/harbingers.pdf&#34;&gt;http://ceoi.inf.elte.hu/probarch/09/harbingers.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Двоичные подъемы с линейной памятью</title>
      <link>https://peltorator.ru/posts/linear_binups/</link>
      <pubDate>Mon, 13 Sep 2021 17:35:30 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/linear_binups/</guid>
      
      <description>&lt;p&gt;Часто в задачах на деревья используются &lt;a href=&#34;https://e-maxx.ru/algo/lca_simpler&#34;&gt;двоичные подъемы&lt;/a&gt;. Они помогают искать LCA (наименьшего общего предка), какую-то функцию на пути и так далее. Однако они занимают $O(n \log n)$ памяти. В этой главе мы рассмотрим альтернативную структуру со схожей функциональностью, занимающую линейную память.&lt;/p&gt;
&lt;h2 id=&#34;идея&#34;&gt;Идея&lt;/h2&gt;
&lt;p&gt;В двоичных подъемах мы для каждой вершины храним предков на $1$, $2$, $4$, $\ldots$, $2^k$ вверх. Чтобы сделать структуру линейной, мы будем хранить только двух предков: непосредственного отца &lt;code&gt;parent&lt;/code&gt;) и еще какого-то одного предка (&lt;code&gt;jump&lt;/code&gt;). И тогда если мы для каждой вершины еще сохраним ее глубину (&lt;code&gt;depth&lt;/code&gt;), то мы сможем легко отвечать на запросы. К примеру, если нам надо найти предка текущей вершины на какой-то глубине, то каждый раз, когда мы стоим в вершине, мы будем сначала смотреть на более длинный прыжок, если он не выше нужной нам вершины, будем совершать этот прыжок, а если же он все таки выше, то просто переходить в отца. Таким способом мы гарантировано придем в нужную вершину, осталось только построить такие прыжки, чтобы этот путь занимал всегда логарифмическое количество шагов.&lt;/p&gt;
&lt;p&gt;При этом структура будет динамическая, так же как и обычные двоичные подъемы. То есть мы можем добавлять вершины в дерево по очереди, и старые прыжки не будут пересчитываться.&lt;/p&gt;
&lt;p&gt;Остается лишь придумать, как построить прыжки. Давайте сделаем это следующим образом: если прыжок из нашего отца (&lt;code&gt;par&lt;/code&gt;) имеет такую же длину, как и прыжок из прыжка нашего отца (&lt;code&gt;jump[par]&lt;/code&gt;), то мы проведем ребро в прыжок прыжка нашего отца (&lt;code&gt;jump[jump[par]]&lt;/code&gt;), а иначе проведем ребро просто в нашего отца. Если вы запутались, то рекомендую осознать код:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;addLeaf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;par&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;par&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;depth&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;depth&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;par&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;depth&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;par&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;depth&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jump&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;par&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;depth&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jump&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;par&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;depth&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jump&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jump&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;par&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]]])&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;jump&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;jump&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jump&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;par&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]];&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;jump&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;par&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;доказательство&#34;&gt;Доказательство&lt;/h2&gt;
&lt;p&gt;Почему же с такими прыжками нам придется совершить лишь логарифмическое количество переходов? Для понимания полезно нарисовать картинку. Заметим, что на длину прыжка из вершины $v$ (а также длины прыжков из всех ее предков) влияет только ее глубина, но не структура дерева. Поэтому можно рассмотреть лишь ситуацию, в которой наше дерево является бамбуком. Давайте заметим, что длина любого прыжка равна степени двойки (если считать длину не по количеству ребер, а по количеству вершин). Действительно, для прыжка в отца длина равна $2$, а любой новый прыжок — это либо прыжок в отца, либо комбинация двух одинаковых прыжков. Тогда если те прыжки имели длину, равную степени двойки, то и комбинация тоже.&lt;/p&gt;
&lt;p&gt;Однако в отличие от обычных двоичных подъемов, в которых мы постепенно уменьшали длину прыжка, здесь все немного сложнее. Сначала длина прыжка постепенно увеличивается, а потом постепенно уменьшается. Это чем-то похоже на путешествие между городами. Сначала мы едем по маленьким улочкам, постепенно выезжая на более широкие проспекты, в конце концов выезжаем на шоссе, а в конце пути происходит симметричная ситуация: мы съезжаем с магистралей на проспекты, а с проспектов на узкие улочки.&lt;/p&gt;
&lt;p&gt;Давайте разделим наш путь на две части: сначала длины прыжков постепенно возрастают, и мы всегда используем прыжок, потом в какой-то момент прыжок ведет в слишком высокую вершину, поэтому нам приходится использовать переход в отца, после чего мы будем иногда использовать переходы в отцов, а иногда прыжки, но длины прыжков будут не возрастать.&lt;/p&gt;
&lt;p&gt;Докажем несколько утверждений.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема:&lt;/strong&gt; Прыжки не пересекаются (но один может лежать строго внутри другого).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Докажем это утверждение по индукции. Пусть это утверждение верно для всех предков текущей вершины, докажем для прыжка из текущей вершины.
Если прыжок ведет в отца, то такой прыжок, очевидно, не может ни с кем пересекаться. Если же прыжок ведет не в отца, то он является комбинацией двух прыжков. Если какой-то прыжок пересекается с новым прыжком, то он пересекается и с одним из двух меньших прыжков. Но для них мы уже доказали по предположению индукции, что они попарно не пересекаются.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема:&lt;/strong&gt; Не может быть больше двух одинаковых прыжков подряд, то есть не может быть так, что длины прыжков из &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;jump[v]&lt;/code&gt; и &lt;code&gt;jump[jump[v]]&lt;/code&gt; совпадают.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
Действительно, если бы они все совпадали, то прыжок из сына &lt;code&gt;jump[v]&lt;/code&gt; вел бы в &lt;code&gt;jump[jump[v]]&lt;/code&gt;, потому что прыжки его предков равны по длине. А тогда этот прыжок бы пересекался с прыжком из $v$, что невозможно по предыдущей теореме.&lt;/p&gt;
&lt;p&gt;Крайним случаем будет ситуация, когда длины всех трех прыжков равны единице, однако в этой ситуации из &lt;code&gt;v&lt;/code&gt; прыжок должен вести в &lt;code&gt;jump[jump[v]]&lt;/code&gt;, а не в &lt;code&gt;jump[v]&lt;/code&gt;, что противоречит условию.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Теорема:&lt;/strong&gt; Длина прыжка из &lt;code&gt;v&lt;/code&gt; не больше длины прыжка из &lt;code&gt;jump[v]&lt;/code&gt; в том случае, если &lt;code&gt;jump[v]&lt;/code&gt; — это не корень. То есть если мы переходим по прыжкам, то их длины не убывают.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Доказательство:&lt;/strong&gt;
Действительно, если наш прыжок ведет в корень, то оттуда уже некуда прыгать. А иначе прыжок будет иметь не меньшую длину.&lt;/p&gt;
&lt;p&gt;Докажем это утверждение по индукции. Пусть это утверждение верно для всех предков текущей вершины, докажем для прыжка из текущей вершины.
Если этот прыжок ведет в отца, то это самый маленький возможный прыжок, и следующий точно не меньше.
Если же прыжок ведет не в отца, то он был получен из двух меньших прыжков длины в два раза меньше, Тогда так как для всех предков утверждение уже верно, то прыжок из нашего прыжка точно не может быть короче нашего прыжка более, чем в два раза. Однако если он короче ровно в два раза, то мы получаем три последовательных прыжка одинаковой длины, чего не бывает по предыдущей теореме. Поэтому прыжок из нашего прыжка имеет длину не меньше, чем текущий прыжок.&lt;/p&gt;
&lt;p&gt;Из этих утверждений легко понять, что первая фаза путешествия, в которой мы всегда переходим по прыжкам, работает за логарифмическое время. Действительно, длина прыжка не убывает, но при этом она не может оставаться фиксированной более, чем два раза, поэтому через $2 \log n$ итераций длина прыжка станет не меньше $n$, и в этот момент прыжок уже точно будет выше, чем необходимая нам вершина.&lt;/p&gt;
&lt;p&gt;На второй же фазе путешествия мы пытаемся получить точную вершину, в которую нам нужно прийти. нам не подходит прыжок длины $2^k$, то есть наша вершина находится между текущей вершиной и прыжком из нее. Тогда мы переходим в нашего отца, в результате чего отрезок, на котором мы ищем, поделился на два. И если нужная вершина находится в верхней половине, то мы сделаем прыжок из нашего отца, а если в нижней, то не сделаем. В любом случае, через каждые два шага длина прыжка из текущей вершины будет уменьшаться в два раза, и таким бинпоиском мы постепенно придем в нужную вершину.&lt;/p&gt;
&lt;h2 id=&#34;поиск-предка-на-глубине-h&#34;&gt;Поиск предка на глубине $h$&lt;/h2&gt;
&lt;p&gt;Доказательство не совсем очевидно, однако его не нужно помнить, чтобы применять эту структуру данных. Давайте рассмотрим пример ее работы для задачи LA (level ancestor), то есть поиска предка текущей вершины на глубине $h$. Для этого мы постепенно идем наверх, пытаясь пойти в прыжок текущей вершины, если его глубина не меньше $h$, а в противном случае идем в отца.&lt;/p&gt;
&lt;p&gt;С реализацией можно ознакомиться по &lt;a href=&#34;https://pastebin.com/tyrL8gMQ&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Асимптотика ответа на $q$ запросов на дереве из $n$ вершин будет $O(n + q \log n)$.&lt;/p&gt;
&lt;h2 id=&#34;поиск-наименьшего-общего-предка&#34;&gt;Поиск наименьшего общего предка&lt;/h2&gt;
&lt;p&gt;Теперь рассмотрим другую задачу, для решения которой обычно используют бинарные подъемы: LCA (least common ancestor или наименьший общий предок). Воспользуемся следующей идеей: сначала из более глубокой вершины перейдем на глубину менее глубокой при помощи LA, а затем будем параллельно подниматься наверх из двух вершин. Обратите внимание на то, что если две вершины находятся на одной и той же глубине, то длины их прыжков совпадают, поэтому мы можем переходить по прыжку в том случае, если концы этих прыжков не равны, а в противном случае переходить в отца.&lt;/p&gt;
&lt;p&gt;С реализацией можно ознакомиться по &lt;a href=&#34;https://pastebin.com/shHVMMBQ&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Асимптотика ответа на $q$ запросов на дереве из $n$ вершин будет $O(n + q \log n)$.&lt;/p&gt;
&lt;p&gt;Также аналогично двоичным подъемам можно хранить значение какой-то функции на прыжке и при помощи этого искать значение функции на пути в дереве.&lt;/p&gt;
&lt;h2 id=&#34;задачи-для-практики&#34;&gt;Задачи для практики&lt;/h2&gt;
&lt;p&gt;Для практики подойдут любые задачи на двоичные подъемы и LCA.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.hackerrank.com/challenges/kth-ancestor/problem&#34;&gt;Задача&lt;/a&gt; на поиск $k$-го предка в дереве.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.spoj.com/problems/LCA/&#34;&gt;Задача&lt;/a&gt; на поиск наименьшего общего предка.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/contest/609/problem/E&#34;&gt;Задача&lt;/a&gt;, в которой нужно еще некоторые знания о минимальных остовных деревьях.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>RMQ offline: вариация алгоритма Тарьяна</title>
      <link>https://peltorator.ru/posts/rmq_offline/</link>
      <pubDate>Sun, 12 Sep 2021 13:20:05 +0300</pubDate>
      
      <guid>https://peltorator.ru/posts/rmq_offline/</guid>
      
      <description>&lt;p&gt;Общеизвестен &lt;a href=&#34;https://e-maxx.ru/algo/lca_linear_offline&#34;&gt;Алгоритм Тарьяна&lt;/a&gt; для поиска LCA offline. Можно построить аналогичный алгоритм для решения задачи RMQ. Обратите внимание, что в статье по ссылке написано, что алгоритм работает за $O(n + m)$, что не совсем верно. Однако из-за того, что обратная функция Аккермана не больше $5$ для любых практически возможных ограничений ($n, m \le 10^{10^{10^{19500}}}$), можно считать, что это константа. Не смотря на это, в данной статье мы попытаемся соблюдать формальность.&lt;/p&gt;
&lt;p&gt;Так как задача нам дана в оффлайне, мы можем отвечать на запросы в любом порядке. Давайте для каждого индекса массива сохраним все запросы, для которых этот индекс является правой границей. После чего пройдемся по массиву слева направо, постепенно отвечая на запросы для текущей правой границы. При этом будем еще поддерживать стек минимумов (не путать со стеком с минимумом), или как его еще называют «стек рекордов».&lt;/p&gt;
&lt;p&gt;Давайте определим, что это такое. Пускай мы сейчас находимся на позиции $i$ массива. Тогда стек минимумов — это все возможные индексы массива, такие что они будут являться минимумом на каком-то отрезке, правая граница которого — $i$. Если упорядочить эти позиции по возрастанию, то соответствующие значения будут строго возрастать, потому что если постепенно расширять отрезок с фиксированной правой границей $i$ (то есть двигать левую границу налево), то каждый элемент этого стека станет минимумом на отрезке в тот момент, когда мы дойдем до него, а также некоторое время после этого, то есть он точно меньше, чем все числа правее него.&lt;/p&gt;
&lt;p&gt;Научимся пересчитывать стек минимумов при переходе к следующей позиции. Теперь в конец любого отрезка добавился один новый элемент. Тогда нужно удалить из стека все элементы, которые не меньше его, потому что они больше не являются рекордами. В силу того, что стек минимумов строго возрастает, надо просто удалить несколько элементов с конца стека (поэтому эта структура и называется стеком), после чего добавить на вершину стека текущий элемент.&lt;/p&gt;
&lt;p&gt;Заметим, что стек минимумов делит массив на отрезки: каждый элемент стека минимумов является минимумом на любом отрезке с левой границей от текущего элемента стека минимумов до следующего влево. Тогда чтобы найти минимум на отрезке, достаточно для левой границы отрезка найти ближайший справа элемент стека минимумов, он и будет являться минимумом на отрезке.&lt;/p&gt;
&lt;p&gt;Как же мы будем находить этот самый ближайший элемент в стеке минимумов? Это можно делать при помощи бинпоиска по стеку, однако в таком решении асимптотика будет $O(n + m \log n)$, что нас не устраивает. Давайте поддерживать СНМ (систему непересекающихся множеств), в которой элементами будут являться индексы массива, а множествами — отрезки, высекаемые стеком минимумов, на которых минимум фиксирован. Тогда если мы в корне каждого дерева СНМ будем еще поддерживать минимум на множестве, то для данной левой границы достаточно дойти до корня ее дерева и там узнать ответ. Обратите внимание, что множества объединяются очень простым образом. Когда к нам пришел новый элемент, он сначала находится один в своем множестве, но когда мы удаляем со стека элемент, мы объединяем соответствующее множество с множеством текущей правой границы. Каждый элемент будет добавлен в стек (а следовательно, и удален) не более одного раза, так что мы сделаем $O(n)$ операций с СНМом. Асимптотика получается равной $O((n + q) \alpha(n))$, если использовать и эвристику сжатия путей, и ранговую эвристику.&lt;/p&gt;
&lt;p&gt;Реализация доступна по &lt;a href=&#34;https://pastebin.com/WaGMprcc&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Наиболее эффективная реализация доступна по &lt;a href=&#34;https://pastebin.com/QQqptmFm&#34;&gt;ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;задачи-для-практики&#34;&gt;Задачи для практики&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://informatics.msk.ru/mod/statements/view.php?id=597&amp;amp;chapterid=752#1&#34;&gt;Задача&lt;/a&gt; на поиск максимума на отрезке.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ОСТОРОЖНО! СПОЙЛЕРЫ К РОИ!&lt;/strong&gt; &lt;a href=&#34;https://contest.yandex.ru/roiarchive/contest/4284/problems/7/&#34;&gt;Эту задачу&lt;/a&gt; можно очень просто сдать на высокий балл при помощи предложенного алгоритма.&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
  </channel>
</rss>

