<!DOCTYPE html>
<html lang="ru">

<head>
	<meta name="generator" content="Hugo 0.88.1" />
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">


<meta name="author" content="peltorator">



<meta name="description" content="an example site for hugo theme TeXify">



<link rel="icon" href="/favicon.ico">



<meta name="keywords" content=" hugo  latex  theme ">




<script>
  
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true,
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    }
  };
</script>

<script async defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>



<script src="https://tikzjax.com/v1/tikzjax.js"></script>
<script src="https://tikzwolke.com/v1/tikzwolke.js"></script>


<link rel="canonical" href="https://peltorator.ru/try_web/">


<link rel="alternate" type="application/rss+xml" href="https://peltorator.ru/try_web/index.xml" title="peltorator" />


<title>peltorator</title>



<link media="screen" rel="stylesheet" href='https://peltorator.ru/try_web/css/common.css'>
<link media="screen" rel="stylesheet" href='https://peltorator.ru/try_web/css/content.css'>
<link media="screen" rel="stylesheet" href='https://peltorator.ru/try_web/css/highlight.css'>


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="peltorator" />
<meta name="twitter:description" content="" />


  <link rel="stylesheet" href='https://peltorator.ru/try_web/css/index.css'>
</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="https://peltorator.ru/try_web/">peltorator</a>
  </h1>

  <nav>
    
  </nav>
</header>

    <main id="main" class="index">
      
      
      <div class="post">
        <h2>
          <a href="https://peltorator.ru/try_web/post/stress/">Стресс-тестирование</a>
          <time>2021-09-14</time>
        </h2>
        
        <div class="content">
          
          Общие концепции Стресс-тестирование — это не тестирование задачи в последние минуты контеста под большим давлением. Стресс-тестирование — это тестирование вашего кода сразу на большом количестве автоматически генерируемых тестов для поиска того теста, на котором ваше решение работает неправильно.
Стандартный сценарий, когда вам нужен стресс: вы заслали решение в систему, получили WA, но ни ошибка в коде, ни неработающий тест никак не хотят находиться. Для стресс-тестирования вам нужны следующие компоненты:
  smart.
          
        </div>
      </div>
      
      <div class="post">
        <h2>
          <a href="https://peltorator.ru/try_web/post/random/">Генерация случайных чисел</a>
          <time>2021-09-14</time>
        </h2>
        
        <div class="content">
          
          Часто бывает так, что ваши решения задач зависят от случайных чисел. Стандартным примером будет являться декартово дерево, в котором логарифмическая высота достигается в том случае, если потенциалы будут выбраны случайно. Когда ваша программа использует случайные числа, нужно быть внимательным, чтобы не попасть в какую-нибудь ловушку. В этом разделе мы как раз поговорим про то, какие бывают ловушки, как в них не попасться, а также как упростить себе жизнь. В основном речь будет идти про C++, однако некоторые вещи можно по аналогии перенести в другие языки.
          
        </div>
      </div>
      
      <div class="post">
        <h2>
          <a href="https://peltorator.ru/try_web/post/halfplanes_intersection_point_inside/">Поиск пересечения полуплоскостей с точкой внутри</a>
          <time>2021-09-14</time>
        </h2>
        
        <div class="content">
          
          Алгоритмы нахождения пересечения полуплоскостей достаточно сложные, поэтому стоит пользоваться ситуациями, когда задачу нужно решать не в общем случае. К примеру, если все полуплоскости &laquo;смотрят вниз&raquo;, то это уже задача Convex Hull Trick. Если нужно лишь проверить пересечение полуплоскостей на непустоту, то это можно сделать при помощи линейного рандомизированного алгоритма. В этой главе же мы рассмотрим ситуацию, когда нам известно, что какая-то точка $P$ обязательно лежит строго внутри пересечения полуплоскостей.
Замечание: Обратите внимание, что точка должна лежать строго внутри, поэтому нельзя просто сначала найти точку на границе при помощи рандомизированного линейного алгоритма, а потом запустить алгоритм из этой главы.
          
        </div>
      </div>
      
      <div class="post">
        <h2>
          <a href="https://peltorator.ru/try_web/post/min_circle/">Минимальная покрывающая окружность за $O(n)$</a>
          <time>2021-09-14</time>
        </h2>
        
        <div class="content">
          
          Решим за линейное время следующую задачу:
Задача: Даны $n$ точек на плоскости. Требуется найти окружность минимального радиуса, такую что все данные точки лежат внутри или на границе этой окружности.
В отличие от других рассмотренных рандомизированных геометрических алгоритмов, у которых есть общеизвестные детерминированные аналоги, работающие в $\log n$ раз дольше, в данном случае рандомизированное решение будет единственным применимым с практической точки зрения.
Есть два варианта того, как будет выглядеть минимальная покрывающая окружность: либо это описанная окружность какой-то тройки из данных точек, либо окружность, построенная на отрезке между двумя какими-то точками как на диаметре, потому что во всех других случаях ее радиус можно немного уменьшить так, чтобы эта окружность все еще содержала в себе все данные точки.
          
        </div>
      </div>
      
      <div class="post">
        <h2>
          <a href="https://peltorator.ru/try_web/post/halfplanes_intersection_linear/">Проверка пересечения полуплоскостей на непустоту за $O(n)$</a>
          <time>2021-09-14</time>
        </h2>
        
        <div class="content">
          
          Решим за линейное время следующую задачу:
Задача: Даны $n$ полуплоскостей. Требуется найти точку, лежащую во всех этих полуплоскостях, либо сказать, что такой нет.
Задачу пересечения полуплоскостей можно решить за время $O(n \log n)$ различными способами. Они находят не только одну точку, но все множество пересечения. Мы же рассмотрим рандомизированный алгоритм, работающий за ожидаемое время $O(n)$.
Давайте будем добавлять полуплоскости по одной в случайном порядке, поддерживая самую высокую точку в множестве пересечения уже добавленных полуплоскостей (Если таких точек несколько, то самую левую из них.
          
        </div>
      </div>
      
      
      <div class="paginator">
        
        <a></a>
        
        
        <a class="link" href="/try_web/page/2/">next →</a>
        
      </div>
      
    </main>
    <footer id="footer">
  <div>
    <span>© 2021</span> - <span>2021</span>
  </div>

  <div>
    <span>Powered by </span>
    <a class="link" href="https://gohugo.io/">Hugo</a>
    <span> 🍦 Theme </span>
    <a class="link" href="https://github.com/queensferryme/hugo-theme-texify">TeXify</a>
  </div>

  <div class="footnote">
    <span></span>
  </div>
</footer>

  </div>
  





</body>

</html>
