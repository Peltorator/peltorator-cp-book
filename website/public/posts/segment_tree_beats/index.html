<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">


<meta name="author" content="peltorator">



<meta name="description" content="Segment Tree Beats (STB) — это структура данных (Хотя назвать это структурой данных можно весьма условно. Это скорее набор идей, которые наслаиваются на дерево отрезков.), которая была разработана Ruyi jiry_2 Ji в 2016 году. Это очень мощный инструмент, идея которого состоит в том, что мы ослабляем условия выхода из рекурсии в дереве отрезков, в результате чего кажется, что алгоритм начинает работать за $O(n^2)$, но при помощи амортизационного анализа можно доказать, что на самом деле время работы сильно меньше ($O(n \log n)$, $O(n \log^2 n)$ и т.">



<link rel="icon" href="/favicon.ico">



<meta name="keywords" content=" hugo  latex  theme ">




<script>
  
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true,
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    }
  };
</script>

<script async defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>



<link rel="stylesheet" type="text/css" href="http://tikzjax.com/v1/fonts.css">
<script src="https://tikzjax.com/v1/tikzjax.js"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<link rel="canonical" href="https://peltorator.ru/posts/segment_tree_beats/">




<title>Segment Tree Beats - peltorator</title>



<link media="screen" rel="stylesheet" href='https://peltorator.ru/css/common.css'>
<link media="screen" rel="stylesheet" href='https://peltorator.ru/css/content.css'>
<link media="screen" rel="stylesheet" href='https://peltorator.ru/css/highlight.css'>


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Segment Tree Beats" />
<meta name="twitter:description" content="Segment Tree Beats (STB) — это структура данных (Хотя назвать это структурой данных можно весьма условно. Это скорее набор идей, которые наслаиваются на дерево отрезков.), которая была разработана Ruyi jiry_2 Ji в 2016 году. Это очень мощный инструмент, идея которого состоит в том, что мы ослабляем условия выхода из рекурсии в дереве отрезков, в результате чего кажется, что алгоритм начинает работать за $O(n^2)$, но при помощи амортизационного анализа можно доказать, что на самом деле время работы сильно меньше ($O(n \log n)$, $O(n \log^2 n)$ и т." />


  <link rel="stylesheet" href='https://peltorator.ru/css/single.css'>
</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="https://peltorator.ru/">peltorator</a>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      <a class="link" href="/">Статьи</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/about/">Полезные ссылки</a>
    </span>
    
  </nav>
</header>

    <main id="main" class="post">
      
      
      <div class="content">
        <p>Segment Tree Beats (STB) — это структура данных (Хотя назвать это структурой данных можно весьма условно. Это скорее набор идей, которые наслаиваются на дерево отрезков.), которая была разработана Ruyi jiry_2 Ji в 2016 году. Это очень мощный инструмент, идея которого состоит в том, что мы ослабляем условия выхода из рекурсии в дереве отрезков, в результате чего кажется, что алгоритм начинает работать за $O(n^2)$, но при помощи амортизационного анализа можно доказать, что на самом деле время работы сильно меньше ($O(n \log n)$, $O(n \log^2 n)$ и т.д.). Также эта структура данных позволяет работать с &laquo;исторической информацией&raquo; массива. Частным случаем Segment Tree Beats является структура Ji Driver Segment Tree, которая позволяет поддерживать операции вида &laquo;заменить все числа на отрезке массива $A$ на $\max(A_i, x)$&raquo;, а также узнавать сумму на отрезке.</p>
<p>На английском языке на эту тему есть по большому счету только <a href="https://codeforces.com/blog/entry/57319">одна статья</a>. На русском же языке, насколько мне известно, материалов на эту тему нет в принципе. Статья, которую вы сейчас читаете, не только полностью покрывает англоязычный текст, но и затрагивает большое количество тем, которые в ней не упоминались, поэтому, пожалуй, является самым полным материалом про Segment Tree Beats не на китайском языке на данный момент. Я попытался собрать все возможные идеи, которые есть на эту тему, а также дополнить несколькими своими.</p>
<p>На данный момент в русском языке нет какой-либо используемой альтернативы английскому названию, но если вы предпочитаете локализацию, то есть вариант <a href="https://codeforces.com/blog/entry/90460?locale=ru#comment-789207">&laquo;Анимешное Дерево Отрезков&raquo;</a>.</p>
<p>В этой статье мы часто будем говорить про асимптотику. Всегда подразумевается, что $n$ — это размер массива, а $q$ — суммарное количество запросов.</p>
<h2 id="общая-идея">Общая идея</h2>
<p>Давайте посмотрим, как выглядит стандартная функция изменения в дереве отрезков с массовым обновлением и проталкиванием:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ql</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newVal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">qr</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">||</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">ql</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// node is outside of the segment
</span><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ql</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">qr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// node is inside the segment
</span><span class="c1"></span>        <span class="n">updateNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">newVal</span><span class="p">);</span>
        <span class="n">setPush</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">newVal</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// node intersects the segment
</span><span class="c1"></span>    <span class="n">pushDown</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">update</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">ql</span><span class="p">,</span> <span class="n">qr</span><span class="p">,</span> <span class="n">newVal</span><span class="p">);</span>
    <span class="n">update</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">node</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">ql</span><span class="p">,</span> <span class="n">qr</span><span class="p">,</span> <span class="n">newVal</span><span class="p">);</span>
    <span class="n">pullUp</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>Пускай мы находимся в вершине <code>node</code>, которая отвечает за полуинтервал $[l, r)$ массива, и нас попросили обновить значения массива на полуинтервале $[ql, qr)$ значением <code>newVal</code>.</p>
<p>Первое условие (<code>breakCondition</code>) проверяет, что если отрезок, за который отвечает вершина <code>node</code>, не пересекается с отрезком, на котором мы делаем обновление, то в текущем поддереве ничего менять не надо, и можно просто вернуться назад.</p>
<p>Второе условие (<code>tagCondition</code>) проверяет, что если отрезок, за который отвечает вершина <code>node</code>, лежит полностью внутри отрезка, который мы обновляем, то мы обновим значение прямо здесь, а также сохраним <code>push</code>, который в будущем будем проталкивать в детей. После чего мы опять же завершаемся и возвращаемся назад.</p>
<p>Если же ни первое, ни второе условие не выполнились, то это значит, что отрезки запроса и текущей вершины пересекаются, но при этом текущая вершина не лежит полностью внутри запроса. В таком случае мы рекурсивно запускаемся из детей, не забыв предварительно протолкнуть информацию о старых обновлениях, а после завершения работы в детях восстанавливаем значение в текущей вершине через значения детей.</p>
<p>Этот код будет работать за $O(\log n)$, потому что на каждом уровне дерева отрезков не больше, чем две вершины могут пересекаться с отрезком запроса, но при этом не лежать в нем полностью, поэтому только из этих двух вершин мы рекурсивно запустимся на следующий уровень, а значит, на каждом уровне дерева мы посетим не более четырех вершин.</p>
<p>Segment Tree Beats основан на следующей идее: пускай запросы изменения таковы, что мы не всегда можем пересчитать значение на отрезке при условии выполнения <code>tagCondition</code>. Тогда давайте усилим условие <code>breakCondition</code> и ослабим условие <code>tagCondition</code>, чтобы теперь мы могли уже пересчитать значение в вершине, не запускаясь рекурсивно, но при этом асимптотика не стала квадратичной.</p>
<p>То есть, теперь функция изменения будет выглядеть следующим образом:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ql</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newVal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">qr</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">||</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">ql</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// node is outside of the segment
</span><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ql</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">qr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// node is inside the segment
</span><span class="c1"></span>        <span class="n">updateNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">newVal</span><span class="p">);</span>
        <span class="n">setPush</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">newVal</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// node intersects the segment
</span><span class="c1"></span>    <span class="n">pushDown</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">update</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">ql</span><span class="p">,</span> <span class="n">qr</span><span class="p">,</span> <span class="n">newVal</span><span class="p">);</span>
    <span class="n">update</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">node</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">ql</span><span class="p">,</span> <span class="n">qr</span><span class="p">,</span> <span class="n">newVal</span><span class="p">);</span>
    <span class="n">pullUp</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>Иными словами, все, что нам нужно сделать — это придумать наиболее сильное условие <code>breakCondition</code>, при котором в текущем поддереве запрос изменения точно ничего не изменит, а также наиболее сильное условие <code>tagCondition</code>, при котором можно будет обновлять значение в текущей вершине, не запускаясь рекурсивно из детей.</p>
<p>При этом заметьте, что <code>breakCondition</code> и <code>tagCondition</code> из обычного дерева отрезков никуда не деваются. Скорее всего, если отрезки запроса и текущей вершины не пересекаются, то в этой вершине точно ничего не надо менять. С другой стороны, если текущая вершина не лежит полностью внутри отрезка запроса, то вряд ли можно пересчитать значение в ней, не запустившись рекурсивно в детей, так что эти условия будут выглядеть примерно следующим образом:</p>
<p><code>breakCondition = qr &lt;= l || r &lt;= ql || ???</code></p>
<p><code>tagCondition = ql &lt;= l &amp;&amp; r &lt;= qr &amp;&amp; ???</code></p>
<p>В этой статье мы будем пытаться придумать, чем нужно заменить каждый из <code>???</code> в разных задачах.</p>
<p>Задачи в основном будут описываться запросами, которые в них нужно выполнять. К примеру, запрос <code>+=</code> означает, что необходимо уметь прибавлять какое-то значение на отрезке. Запрос <code>=</code> означает, что необходимо уметь присваивать какое-то значение на отрезке. Эти запросы являются весьма стандартными для дерева отрезков. Однако кроме них будут рассмотрены и более сложные: <code>max=</code>, <code>min=</code>, <code>%=</code>, <code>/=</code> и так далее. Они означают, что в результате запроса нужно заменить все элементы на отрезке на результат выполнения соответствующей функции от текущего значения и <code>newVal</code>. К примеру, операция <code>max=</code> заменят все элементы на отрезке массива $A$ по правилу $A_i \to \max(A_i, newVal)$.</p>
<p>Кроме того, не менее важно, какие операции типа <code>get</code> есть в задаче. К примеру, мы будем рассматривать следующие операции: $\sum$ — сумма на отрезке, $\max$ — максимум на отрезке, $\min$ — минимум на отрезке, $gcd$ — НОД на отрезке и т.д.</p>
<p><strong>Замечание:</strong> <br>
Обратите внимание, что запрос типа <code>get</code>, то есть запрос получения какой-либо функции на отрезке, не меняется, потому что мы все еще поддерживаем корректную информацию о подотрезке вершины, когда мы в нее спустились от корня.</p>
<h2 id="--в-точке-sum"><code>%=</code>, <code>=</code> в точке, $\sum$</h2>
<h3 id="формулировка">Формулировка</h3>
<p>В этой задаче у нас есть массив неотрицательных целых чисел $A$ ($0 \le A_i &lt; C$), а также имеются запросы трех типов:</p>
<ol>
<li>Даны $ql, qr, x$ ($1 \le x &lt; C$). Нужно заменить все элементы массива $a$ на полуинтервале $[ql, qr)$ на $A_i \bmod x$.</li>
<li>Даны $qi, y$ ($0 \le y &lt; C$). Нужно заменить элемент массива $A$ на позиции $qi$ на $y$.</li>
<li>Даны $ql, qr$. Необходимо вернуть сумму элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
</ol>
<p>Эту задачу можно найти <a href="https://codeforces.com/contest/438/problem/D">здесь</a>.</p>
<p>Также можно без проблем поддерживать и другие <code>get</code>-запросы, такие как $\max$ или $\min$.</p>
<h3 id="решение">Решение</h3>
<p>Вторую и третью операции мы будем выполнять как обычно. Осталось понять, в какой момент мы можем остановиться в первом запросе, чтобы обновить значение в текущей вершине, а также в будущем иметь возможность эффективно проталкивать это изменение в детей.</p>
<p>Давайте подумаем, каким должно быть <code>breakCondition</code>? При каком условии ни одно число в данном поддереве не поменяется? В том случае, если все числа на подотрезке текущей вершины меньше, чем $x$. Иными словами, если максимум на этом отрезке меньше $x$. Поэтому <code>breakCondition</code> в данном случае будет выглядеть следующим образом: <code>qr &lt;= l || r &lt;= ql || maxValue[node] &lt; x</code>.</p>
<p>Теперь надо придумать такое условие <code>tagCondition</code>, при котором нам не придется идти в детей. Здесь уже может быть несколько вариантов. К примеру, если целые части от деления всех чисел на отрезке на $x$ совпадают. Однако нам хватит более простого условия: если все числа на отрезке равны, то есть, иными словами, максимум на отрезке равен минимуму. В этом случае все числа на отрезке равны <code>maxValue[node]</code>, поэтому операция <code>%=</code> на этом отрезке — это то же самое, что присвоить на этом отрезке всем элементам <code>maxValue[node]</code>$\bmod x$. Это мы можем сделать так же, как и с запросом второго типа, не заходя в детей.</p>
<h3 id="доказательство">Доказательство</h3>
<p>Осталось понять, почему при таком ослаблении <code>tagCondition</code> асимптотика остается приемлимой. На самом деле асимптотика этого решения — $O((n + q) \log n \log C)$.</p>
<p>Введем потенциал вершины дерева отрезков $\varphi(node)$, равный $\sum_{l \le i &lt; r} \log (A_i + 1)$, где $l, r$ — границы полуинтервала исходного массива, за который отвечает данная вершина. Прибавление единицы, конечно, ни на что особо влиять не будет, но оно необходимо, потому что $A_i$ могут быть равны нулю.
Теперь введем потенциал $\Phi$, который будет равен сумме потенциалов всех вершин дерева. В любой момент времени потенциал можно оценить следующим образом: $0 \le \Phi \le O(n \log n \log C)$, потому что каждый элемент массива лежит в поддереве у $\log n$ вершин дерева отрезков и дает вклад $O(\log C)$.</p>
<p>И пускай суммарно за все время этот потенциал увеличился на $\Phi_+$. Давайте разобьем вершины, которые посетит запрос изменения на три вида:</p>
<ul>
<li><strong>обычные</strong></li>
<li><strong>дополнительные</strong></li>
<li><strong>тупиковые</strong></li>
</ul>
<p>Обычные вершины — это те вершины, которые посетило бы стандартное дерево отрезков, тупиковые вершины — это те необычные вершины, в которых выполнилось одно из условий <code>breakCondition</code> или <code>tagCondition</code>, а дополнительные вершины — это все остальные вершины, которые посетил запрос, то есть те не обычные вершины, из которых мы вызвались рекурсивно.
Тогда заметим, что некоторые верхние вершины дерева будут обычными, потом под обычными будет какое-то количество дополнительных, и из дополнительных иногда будут торчать тупиковые. Из тупиковых уже рекурсивных вызовов нет.
При этом заметим, что отец любой тупиковой вершины — это либо обычная вершина, либо дополнительная. Кроме того, у каждой вершины максимум $2$ сына, так что тупиковых вершин максимум в два раза больше, чем обычных и дополнительных, поэтому их посещение не влияет на асимптотику, и можно следить только за дополнительными вершинами. Это можно было понять немного иначе: если мы делаем рекурсивный вызов и сразу завершаемся, то в каком-то смысле можно считать, что этот рекурсивный вызов не был сделан вовсе.</p>
<p>Теперь, когда мы оставили только обычные и дополнительные вершины, докажем, что при посещении дополнительной вершины потенциал в этой вершине (а следовательно и суммарный потенциал $\Phi$) уменьшается хотя бы на $1$, тогда суммарное количество посещенных дополнительных вершин можно оценить как $O(n \log n \log C) + \Phi_+$, а обычных вершин мы на каждом запросе посещаем $O(\log n)$ штук. При этом в каждой вершине дерева мы делаем константное количество операций, так что асимптотика алгоритма будет равна $O(n \log n \log C + \Phi_+ + q \log n)$. Остается только показать, что $\Phi_+ \le O(q \log n \log C)$, а также то, что потенциал уменьшается при посещении дополнительной вершины.</p>
<p>Данное рассуждение может показаться сложным и запутанным, но на самом деле в будущем все рассуждения об амортизированном времени работы будут очень похожи на это. Мы вводим какой-то потенциал. Понимаем, что он всегда находится в пределах от $0$ до $\max\Phi$, смотрим, на сколько он может увеличиваться, а также, на сколько он уменьшается при посещении дополнительных вершин. Из этого делается вывод о времени работы алгоритма.</p>
<p><strong>Замечание:</strong>
Это не совсем обычный способ измерения амортизированного времени работы. Обычно вводят $a_i = t_i - \Delta \Phi_i$, после чего получается, что время работы можно оценить как $\Delta \Phi + \sum a_i$. Однако в данном контексте такие рассуждения, пожалуй, менее удобны для понимания. Мы воспринимаем потенциал как кучку камней, которая может иметь ограниченный размер, за все время в нее положат какое-то конкретное ограниченное количество камней, а за каждую необычную операцию мы будем забирать из этой кучки камень.</p>
<p>Итак, давайте поймем, чему равен $\Phi_+$. Операция первого типа может только уменьшать числа в массиве, а операция третьего типа вовсе не меняет элементов массива. Поэтому увеличения потенциала могут происходить только во время операций второго типа. Мы изменили один элемент массива. Он был $\ge 0$, а стал $&lt; C$, поэтому потенциал мог увеличиться максимум на $\log ((C - 1) + 1) - \log(0 + 1) = \log C$ для каждой вершины, в поддереве которой есть этот элемент, а таких вершин $O(\log n)$. Всего запросов было $q$, поэтому суммарно потенциал увеличится максимум на $O(q \log n \log C)$. Что и требовалась показать.</p>
<p>Теперь покажем, почему при посещении дополнительной вершины ее потенциал уменьшается как минимум на $1$. Если мы посещаем дополнительную вершину, это значит, что ко всем элементам на ее подотрезке нужно применить операцию <code>%=</code>, и при этом на этом отрезке есть хотя бы одно число, которое не меньше $x$. Воспользуемся следующим известным фактом:</p>
<p><strong>Теорема:</strong>
Если $k \ge x$, то $k \bmod x \le \frac{k - 1}{2}$.</p>
<p><strong>Доказательство:</strong>
Во-первых, заметим, что условие $l \le \frac{k - 1}{2}$ для целых $l$ и $k$ равносильно тому, что $l &lt; \frac{k}{2}$.</p>
<p>Во-вторых, разберем два случая:</p>
<ol>
<li>$k \ge 2 x$. В этом случае $k \bmod x &lt; x \le \frac{k}{2}$. Первое равенство верно просто потому, что остаток от деления всегда меньше модуля, а второе верно из-за того, что $k \ge 2 x$.</li>
<li>$k &lt; 2x$. В этом случае $k \bmod x = k - x &lt; \frac{k}{2}$ в силу того, что $k &lt; 2x$.</li>
</ol>
<p>То есть, если мы посетили дополнительную вершину, то какое-то число на этом отрезке уменьшится больше, чем в два раза. Тогда раньше это число давало вклад $\log (k + 1)$ в потенциал, а теперь $\le \log ( \frac{k - 1}{2} + 1) = \log (\frac{k + 1}{2}) = \log (k + 1) - 1$. Таким образом, мы доказали, что потенциал этой вершины уменьшился хотя бы на один. Что и требовалось.</p>
<p><strong>Замечание:</strong>
В одной из последующих секций мы докажем, что абсолютно такое же решение будет работать за такую же асимптотику даже если присвоение происходит на отрезке.</p>
<h2 id="min-sum-max-ji-driver-segment-tree"><code>min=</code>, $\sum$, $\max$ (Ji Driver Segment Tree)</h2>
<h3 id="формулировка-1">Формулировка</h3>
<p>В этой задаче у нас есть массив неотрицательных целых чисел $A$, а также имеются запросы трех типов:</p>
<ol>
<li>Даны $ql, qr, x$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\min(A_i, x)$.</li>
<li>Даны $ql, qr$. Необходимо вернуть сумму элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
<li>Даны $ql, qr$. Необходимо вернуть максимум в массиве $A$ на полуинтервале $[ql, qr)$.</li>
</ol>
<p>Эта задача доступна <a href="https://vjudge.net/problem/HDU-5306">здесь</a> или <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5306">здесь</a>. Это китайские сайты, поэтому там не так просто зарегистрироваться.</p>
<p>Также есть усложненная версия этой задачи <a href="https://codeforces.com/problemset/problem/855/F">&laquo;Нагайна&raquo;</a>.</p>
<h3 id="решение-1">Решение</h3>
<p>Это самая стандартная задача на Segment Tree Beats. Собственно, статья на английском появилась после того, как участники из Китая массово решали задачу &laquo;Нагайна&raquo; при помощи Ji Driver Segment Tree, хотя изначально эта задача была на корневую декомпозицию.</p>
<p>В этой задаче мы будем хранить в каждой вершине следующие значения: <code>sum</code> — сумма на отрезке; <code>max</code> — максимум на отрезке; <code>cntMax</code> — количество элементов на этом отрезке, которые равны максимуму; <code>secondMax</code> — наибольший элемент на отрезке, который строго меньше, чем <code>max</code>. Обратите внимание на то, что это строгий второй максимум, то есть если на отрезке есть числа $0, 1, 2, 3, 3$, то <code>secondMax</code> $ = 2$.</p>
<p>Каким должно быть <code>breakCondition</code>? В каком случае операция <code>min=</code> не поменяет ничего на текущем отрезке? В том случае, если все элементы на этом отрезке уже не больше, чем $x$, и ничего менять не надо. То есть, другими словами, если максимум не больше $x$:</p>
<p><code>breakCondition = qr &lt;= l || r &lt;= ql || max &lt;= x</code></p>
<p>А каким же должно быть <code>tagCondition</code>? В каком случае мы можем быстро обновить значения в текущей вершине? В том случае, если меняются только максимумы, то есть <code>secondMax &lt; x</code>.</p>
<p><code>tagCondition = ql &lt;= l &amp;&amp; r &lt;= qr &amp;&amp; secondMax &lt; x</code></p>
<p>В таком случае мы знаем, что <code>cntMax</code> максимумов заменятся на <code>x</code>, и в этом случае легко можно пересчитать все значения в вершине, и вниз мы будем проталкивать как раз эту информацию: с каким числом нужно произвести операцию <code>min=</code>. Если нужно протолкнуть две операции <code>min=</code>, то достаточно проталкивать всего одну такую операцию с меньшим из параметров.</p>
<p>На самом деле можно заметить, что проталкиваемое значение можно не хранить вовсе, потому что оно всегда совпадает с <code>max</code> в этой вершине (либо проталкивать ничего не надо, но если мы протолкнем максимум, ничего не изменится). То есть мы в каком-то смысле проталкиваем в детей наш максимум на отрезке. Так писать код становится сильно приятнее.</p>
<h3 id="доказательство-1">Доказательство</h3>
<p>Докажем, что это решение работает за $O((n + q) \log n)$.</p>
<p>Опять же воспользуемся методом потенциалов. Определим потенциал вершины $\varphi(node)$ как количество различных чисел на отрезке, за который отвечает эта вершина. Общий потенциал $\Phi$ определяется опять же как сумма потенциалов по всем вершинам дерева.</p>
<p>Количество различных чисел на отрезке не больше, чем длина этого отрезка, так что сумма потенциалов на одном уровне дерева отрезков не больше $n$. Таким образом, в любой момент времени потенциал ограничен следующим образом: $0 \le \Phi \le O(n \log n)$.</p>
<p>Чему равно $\Phi_+$? Во время <code>get</code>-запросов элементы массива не меняются, поэтому в них потенциал не увеличивается. В запросах первого типа потенциал может измениться только для обычных и дополнительных вершин, потому что для непосещенных вершин значения на отрезке не поменяются, а для тупиковых никакие значения не склеятся. При этом для дополнительных вершин количество различных чисел только уменьшается за счет того, что числа склеиваются, но увеличиться точно не может. Поэтому потенциал увеличивается только для обычных вершин, при этом единственное новое значение, которое может появиться, — это <code>x</code>, потому что каждое число либо не меняется, либо заменяется на <code>x</code>. Таким образом, потенциал мог увеличиться только у $O(\log n)$ обычных вершин, и для каждой такой вершины он увеличился максимум на $1$. Поэтому за все время $\Phi_+ \le O(q \log n)$.</p>
<p>Теперь поймем, что посещение дополнительных вершин уменьшает потенциал этой вершины хотя бы на $1$. Это следует из того, что для дополнительных вершин $x \le $ <code>secondMax</code>, поэтому после выполнения этого запроса и <code>max</code>, и <code>secondMax</code> заменятся на $x$, то есть два максимума как бы склеятся между собой, так что количество различных чисел в этой вершине точно уменьшится хотя бы на $1$.</p>
<p>Таким образом, асимптотика алгоритма получается равной $O(n \log n + q \log n + q \log n) = O((n + q) \log n)$ (первое слагаемое от глобального изменения потенциала от начала до конца, второе слагаемое от $\Phi_+$, а третье слагаемое от посещения обычных вершин). Что и требовалось доказать.</p>
<p><strong>Замечание:</strong>
По аналогии с этой задачей можно поддерживать также операцию <code>max=</code> и даже их совмещение. Достаточно хранить 2 максимума, 2 минимума и их количества. Оценка времени работы от этого не изменится.</p>
<p>Кроме того, можно добавить операцию присвоения на отрезке, потому что она так же, как и <code>min=</code> не сильно увеличивает потенциал.</p>
<h2 id="min-max---sum-max-min"><code>min=</code>, <code>max=</code>, <code>=</code>, <code>+=</code>, $\sum$, $\max$, $\min$</h2>
<h3 id="формулировка-2">Формулировка</h3>
<p>В этой задаче у нас есть массив неотрицательных целых чисел $A$, а также имеются запросы шести типов:</p>
<ol>
<li>Даны $ql, qr, x$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\min(A_i, x)$.</li>
<li>Даны $ql, qr, y$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\max(A_i, y)$.</li>
<li>Даны $ql, qr, z$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $z$.</li>
<li>Даны $ql, qr, t$. Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $t$.</li>
<li>Даны $ql, qr$. Необходимо вернуть сумму элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
<li>Даны $ql, qr$. Необходимо вернуть максимум элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
<li>Даны $ql, qr$. Необходимо вернуть минимум элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
</ol>
<!--- TODO: find this problem on some judge --->
<h3 id="решение-2">Решение</h3>
<p>Решение никак не меняется. Оно такое же, как и раньше (только надо добавить стандартную операцию <code>+=</code>), однако теперь старое доказательство перестает работать. Нам надо будет придумать новое.</p>
<h3 id="доказательство-2">Доказательство</h3>
<p>Почему же старое доказательство не работает?</p>
<p>По факту, новая операция здесь всего одна: <code>+=</code>, потому что по замечанию выше остальные запросы просто встраиваются в Ji Driver Segment Tree. Однако с операцией <code>+=</code> потенциал из прошлой задачи не пройдет. Давайте посмотрим на пример массива:</p>
<p>$$1, 2, 3, 4, \ldots, \frac{n}{2} - 1, \frac{n}{2}, 1, 2, 3, 4, \ldots, \frac{n}{2} - 1, \frac{n}{2}$$</p>
<p>Корень дерева отвечает за весь массив, поэтому его потенциал равен $\frac{n}{2}$. Однако если мы прибавим $\frac{n}{2}$ ко второй половине массива, то массив станет выглядеть так:</p>
<p>$$1, 2, 3, 4, \ldots, n - 1, n$$</p>
<p>И в этом случае потенциал корня стал равен $n$, а потенциалы других вершин не изменились. То есть, мы за одну операцию увеличили потенциал на $\frac{n}{2}$. Это слишком много. Нам нужен другой потенциал.</p>
<p>Доказывать мы, однако, будем уже не $O((n + q) \log n)$, а $O(n \log n + q \log^2 n)$. Кроме того, вроде бы теста, на котором это работало бы за $\log^2 n$ на запрос неизвестно, так что, возможно, это настоящий $\log n$, но этим мы, конечно, пользоваться не будем.</p>
<p>В этот раз потенциалом дерева $\Phi_1$ будет количество его вершин, для которых максимумы в левом и правом поддеревьях не совпадают. Скажем, что такие вершины являются помеченными. Аналогично, $\Phi_2$ — это количество вершин, для которых минимумы в левом и правом поддеревьях не совпадают.
Тогда очевидно, что в любой момент времени $0 \le \Phi_1, \Phi_2 \le O(n)$. В каких случаях потенциал $\Phi_1$ мог увеличиваться? Если для какой-то вершины раньше максимумы в детях совпадали, а потом стали различаться. Это могло произойти только в том случае, если к максимуму в одном поддереве применили операцию, а к другому — нет. То есть текущая вершина пересекается с запросом, но не лежит в нем полностью. Это обязательно обычная вершина, таких вершин $O(\log n)$ штук, так что за один запрос $\Phi_1$ могло увеличиться максимум на $O(\log n)$. Аналогично для $\Phi_2$.
Так что $\Phi_{1_+}, \Phi_{2_+} \le O(q \log n)$.</p>
<p>Теперь поймем, как уменьшаются потенциалы при операциях <code>min=</code> и <code>max=</code>. Докажем, что если мы посетили $m$ дополнительных вершин в операции <code>min=</code>, то $\Phi_1$ уменьшится хотя бы на $\frac{m}{\log n}$ (иными словами, если потенциал уменьшится на $k$, то мы посетим не больше $k \log n$ дополнительных вершин). Аналогично, для операции <code>max=</code>, уменьшаться будет $\Phi_2$. Тогда итоговая асимптотика будет равна $O(n \log n + q \log^2 n)$.</p>
<p>Почему потенциал $\Phi_1$ будет уменьшаться? Давайте докажем следующее утверждение:</p>
<p><strong>Теорема:</strong>
В поддереве любой дополнительной вершины $v$ есть помеченная вершина $u$, которая после применения операции перестанет быть помеченной.</p>
<p><strong>Доказательство:</strong>
Если вершина $v$ дополнительная, то для этой вершины <code>max[v]</code> $&gt; x$ и <code>secondMax[v]</code> $\ge x$, потому что не выполнились <code>breakCondition</code> и <code>tagCondition</code>. Тогда докажем, что в поддереве вершины $v$ есть такая вершина $u$, что для нее максимум в одном из детей равен <code>max[v]</code>, а в другом <code>secondMax[v]</code>. И тогда сейчас эти числа различаются, а после применения операции оба будут равны $x$, поэтому из вершины $u$ пропадет пометка.</p>
<p>Почему же такая вершина $u$ существует? Посмотрим на самую глубокую вершину $t$ в поддереве $v$, для которой <code>max[t] = max[v]</code> и <code>secondMax[t] = secondMax[v]</code>. Такая вершина точно есть, потому что как минимум подходит сама вершина $v$. Для вершины $t$ это условие выполнено, а для ее детей — нет, потому что вершина $t$ — это самая глубокая такая вершина. Тогда заметим, что вершина $t$ как раз таки подходит на роль вершины $u$. Если максимум в поддереве $t$ равен <code>max[v]</code>, то и у одного из сыновей максимум равен тому же самому числу. При этом второй максимум в этом сыне не равен <code>secondMax[v]</code>, так как тогда этот сын был бы более глубокой подходящей вершиной. То есть в этом сыне нет значений, равных <code>secondMax[v]</code>. Тогда все эти значения находятся в другом сыне. При этом в другом сыне не может быть значений, равных <code>max[v]</code>, потому что тогда этот другой сын был бы более глубокой вершиной, чем $t$, которая нам подходит. Так что максимум в другом сыне — это <code>secondMax[v]</code>. Поэтому как раз таки вершина $t$ подходит на роль вершины $u$, и в ней была метка, а после применения операции эта метка пропадет.</p>
<p>Пускай после применения операции пропало $k$ меток. Тогда все посещенные дополнительные вершины — это предки этих $k$ вершин, потому что по теореме у любой дополнительной вершины есть потомок, в котором пропала метка. У каждой из этих $k$ вершин есть $\log n$ предков, так что суммарно у них не более $k \log n$ предков, значит, мы посетим не больше, чем столько вершин. Что и требовалось доказать.</p>
<h2 id="min--gcd"><code>min=</code>, <code>+=</code>, $gcd$</h2>
<h3 id="формулировка-3">Формулировка</h3>
<p>В этой задаче у нас есть массив неотрицательных целых чисел $A$ ($0 \le A_i &lt; C$), а также имеются запросы трех типов:</p>
<ol>
<li>Даны $ql, qr, x$ ($0 \le x$). Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\min(A_i, x)$.</li>
<li>Даны $ql, qr, y$ ($0 \le y &lt; C$). Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $x$.</li>
<li>Даны $ql, qr$. Необходимо вернуть наибольший общий делитель ($gcd$, НОД) элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
</ol>
<h3 id="решение--доказательство-упрощенной-версии-задачи">Решение + доказательство упрощенной версии задачи</h3>
<p>Давайте сначала поймем, как решать эту задачу, если запросов первого типа нет. В отличие от других задач, это уже не так очевидно. Если ко всем числам на отрезке прибавили $x$, то не совсем понятно, как изменился НОД чисел на этом отрезке.</p>
<p>Как известно, $gcd(a, b) = gcd(a - b, b)$ (это факт, на котором основан алгоритм Евклида). То есть мы можем заменить одно из чисел на их разность. Но давайте вместо того, чтобы заменять, просто его добавим. Хуже не будет:</p>
<p>$$gcd(a, b) = gcd(a, b, a - b)$$</p>
<p>Этот факт можно обобщить для большего количества членов:</p>
<p>$$gcd(a, b, c) = gcd(a, b, c, a - b, b - c, c - a)$$</p>
<p>И так далее. То есть НОД чисел $a_1, a_2, \ldots, a_k$ равен НОДу этих чисел и всех их возможных $\frac{k \cdot (k - 1)}{2}$ попарных разностей.</p>
<p>С другой стороны, давайте заметим, что из этих членов можно оставить только несколько. Нужно оставить всего  $k$ из них так, чтобы их линейными комбинациями можно было получить $a_1, a_2, \ldots, a_k$. И если эти числа можно получить линейными комбинациями, то НОД такого подмножества будет равен $gcd(a_1, a_2, \ldots, a_k)$.</p>
<p>Давайте представим все числа в виде графа. Ребро между двумя вершинами будет соответствовать их разности. Тогда на самом деле нам достаточно взять какое-то остовное дерево этого графа, а также одно любое из чисел $a_1, a_2, \ldots, a_k$. Почему? Пускай мы взяли число $a_i$, а также какое-то остовное дерево. Как получить линейную комбинацию, равную $a_j$?
Так как мы взяли остовное дерево, то между $a_i$ и $a_j$ в этом дереве есть путь (все, что нам надо от дерева — это связность) $b_1, b_2, \ldots, b_l$, где $b_1 = a_i$ и $b_l = a_j$. Тогда в нашем множестве есть числа $b_1 = a_i$, $b_2 - b_1$, $b_3 - b_2$, $\ldots$, $b_l - b_{l - 1}$. Их сумма как раз равна $b_l = a_j$. Что и требовалось доказать. Кроме того, если бы в нашем множестве не было числа $a_i$, а были бы только разности из какого-то остовного дерева, то исходные числа мы бы получить не смогли таким образом, но разность любых двух — без проблем. Нужно опять же просуммировать все разности на каком-то пути.</p>
<p>Для чего мы это доказывали? Давайте хранить на отрезке отдельно какое-то любое число с этого отрезка (<code>anyValue</code>), а также НОД всех попарных разностей (<code>diffGCD</code>), который, как мы уже выяснили, равен НОДу какого-то остовного дерева. И тогда НОД на отрезке будет вычисляться просто как $gcd($<code>anyValue</code>$,$<code>diffGCD</code>$)$. Однако заметим, что если мы поддерживаем такие значения в вершине, то прибавление числа — это уже не проблема. Если ко всем числам на отрезке прибавили константу $y$, то их попарные разности не поменялись, а значит, не поменялось и <code>diffGCD</code>. А к <code>anyValue</code>, так же, как и ко всем остальным значениям на отрезке, просто прибавится эта самая константа $y$.</p>
<p>Осталось только понять, как пересчитывать значения <code>anyValue</code> и <code>diffGCD</code> в вершине через значения в детях.
<code>anyValue</code> пересчитать очень легко. Можно просто взять любое из <code>anyValue</code> для левого и правого поддеревьев.
А как пересчитать <code>diffGCD</code>? В <code>diffGCD</code> левого поддерева хранится НОД какого-то остовного дерева левого подотрезка, а в <code>diffGCD</code> правого поддерева хранится НОД какого-то остовного дерева правого подотрезка. Поэтому все, что нам нужно, — это соединить эти два остовных дерева, то есть добавить какое-то ребро. Но у нас как раз хранятся <code>anyValue</code> для обоих поддеревьев. Возьмем их разность.
То есть</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">diffGCD</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">diffGCD</span><span class="p">[</span><span class="n">leftChild</span><span class="p">],</span> <span class="n">diffGCD</span><span class="p">[</span><span class="n">rightChild</span><span class="p">],</span>
                 <span class="n">anyValue</span><span class="p">[</span><span class="n">leftChild</span><span class="p">]</span> <span class="o">-</span> <span class="n">anyValue</span><span class="p">[</span><span class="n">rightChild</span><span class="p">])</span>
</code></pre></div><p>И тогда такое решение работает за $O(n \log C + q (\log n +  \log C))$. Во втором слагаемом логарифмы складываются, а не перемножаются по той же причине, по которой так происходит в дереве отрезков с поиском $gcd$ на отрезке и присваиванием на отрезке. Потому что последовательное вычисление НОД у $k$ чисел, не больших $C$ по модулю, работает за $O(k + \log C)$.</p>
<p><strong>Упражнение:</strong>
Докажите, что последовательное вычисление НОД $k$ чисел, не больших $C$ по модулю, работает за $O(k + \log C)$.</p>
<h3 id="решение--доказательство-полной-версии-задачи">Решение + доказательство полной версии задачи</h3>
<p>Итак, мы научились поддерживать операции <code>+=</code> и $gcd$ на отрезке. Давайте добавим к этому еще <code>min=</code>.</p>
<p>Давайте немного изменим концепцию. Будем поддерживать на отрезке не НОД всех попарных разностей, а НОД всех попарных разностей чисел, не равных максимуму на отрезке. А максимумы (как и в Ji Driver Segment Tree) мы будем обрабатывать отдельно. Тогда при условии <code>tagCondition</code> (которое, как и <code>breakCondition</code>, абсолютно такое же, как и в Ji Driver Segment Tree) мы сможем легко пересчитать значения. Нам нужно будет изменить только максимум, а <code>diffGCD</code> никак не поменяется, потому что мы изменяем значения только максимумов, а они не входят в <code>diffGCD</code>.</p>
<p>Как же нам тогда находить НОД на отрезке, зная эти значения? Все числа, не равные максимуму, уже объединены в остовное дерево внутри <code>diffGCD</code>. Остается только присоединить максимумы (или один из них, потому что они все равно равны друг другу). В этом нам как раз может помочь <code>secondMax</code>. Поэтому НОД на отрезке можно вычислить по такой формуле:</p>
<p><code>gcd(diffGCD, max - secondMax, max)</code></p>
<p>В оригинальной статье асимптотика этого алгоритма указана как $O(q \log^3 n)$. Там подразумевается, что $C = q = n$, так что в реальности такая оценка будет выглядеть как $O(n \log n \log C + q \log^2 n \log C)$.</p>
<p>Однако давайте улучшим эту оценку. Давайте докажем, что асимптотика на самом деле $O(n (\log n + \log C) + q \log n (\log n + \log C))$.</p>
<p>Почему мы не можем сказать так же, как и в облегченной версии задачи, что логарифмы складываются, а не перемножаются? Дело в том, что НОД $k$ чисел, не больших $C$ по модулю, вычисляется за $O(k + \log C)$ только в том случае, если мы вычисляем НОД последовательно. То есть сначала берем НОД двух чисел, потом берем НОД этого НОДа и следующего числа, и так далее.
Именно так работает обычное дерево отрезков: в нем мы спускаемся вниз по левой и правой границам отрезка, то есть по бамбукам, в которых будет последовательно вычисляться НОД.
Однако в Segment Tree Beats мы посещаем большое количество дополнительных вершин, которые вовсе не образуют бамбуки, так что логарифмы будут перемножаться. Но давайте копнем глубже.</p>
<p>Давайте вспомним, как мы оценивали асимптотику в задаче <code>min=</code>, <code>+=</code>. Мы ввели потенциал, равный количеству помеченных вершин в дереве, то есть тех вершин, у которых максимум в левом поддереве не совпадает с максимумом в правом поддереве.
Мы доказали, что суммарно за все время он может увеличиться максимум на $O(n + q \log n)$, а также на каждые $O(\log n)$ посещенных дополнительных вершин этот потенциал уменьшается на $1$, поэтому асимптотика будет $O(n \log n + q \log^2 n)$. Там мы показали, что в поддереве любой дополнительной вершины есть метка, которая удалится, поэтому если удалилось $k$ меток, то было посещено не более $k \log n$ вершин. Однако нас интересуют не все вершины, а те, в которых происходит разветвление. Ведь в бамбуке, как мы уже поняли, НОД вычисляется быстро. Но ведь все дополнительные вершины как раз таки лежат на $k$ путях до корня от удаленных меток. И на каждом таком пути НОД будет вычисляться за $O(\log n + \log C)$, а так как всего за все время было удалено максимум $O(n + q \log n)$ меток, то асимптотика алгоритма будет равна $O(n (\log n + \log C) + q \log n (\log n + \log C))$. Что и требовалось доказать.</p>
<h2 id="--на-отрезке-sum"><code>%=</code>, <code>=</code> на отрезке, $\sum$</h2>
<h3 id="формулировка-4">Формулировка</h3>
<p>Простую версию этой задачи мы уже рассматривали ранее. В этой задаче у нас есть массив неотрицательных целых чисел $A$ ($0 \le A_i &lt; C$), а также имеются запросы трех типов:</p>
<ol>
<li>Даны $ql, qr, x$ ($1 \le x &lt; C$). Нужно заменить все элементы массива $a$ на полуинтервале $[ql, qr)$ на $A_i \bmod x$.</li>
<li>Даны $ql, qr, y$ ($0 \le y &lt; C$). Нужно заменить элемент массива $A$ на <strong>отрезке</strong> от $ql$ до $qr$ на $y$.</li>
<li>Даны $ql, qr$. Необходимо вернуть сумму элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
</ol>
<h3 id="решение-3">Решение</h3>
<p>Решение ничем не отличается от решения простой версии задачи, описанного ранее в задаче, где мы делали <code>%=</code> и <code>=</code> в точке.</p>
<h3 id="доказательство-3">Доказательство</h3>
<p><span style="color:gray">Спасибо Антону Степанову за доказательство</span></p>
<p>Однако теперь старый потенциал, равный сумме логарифмов элементов на отрезке, больше не работает, потому что при присвоении на отрезке он может очень сильно увеличиваться. Придумаем новый потенциал и докажем, что время работы останется все тем же самым: $O((n + q) \log n \log C)$.</p>
<p>Для начала скажем, что вершины, на отрезке которых все числа равны, являются помеченными, а потенциал этих вершин равен нулю. В любом случае, такая вершина не может быть дополнительной, так как в ней выполнится <code>tagCondition</code>, потому что $max = min$.</p>
<p>Отрезок, за который отвечает любая вершина разбивается на подотрезки с одинаковыми значениями. У любой непомеченной вершины таких отрезков не меньше двух. Если раньше мы считали в потенциале сумму логарифмов всех элементов на отрезке, то теперь подотрезок одинаковых значений в потенциале будет считаться за одно значение, то есть потенциал вершины — это сумма логарифмов элементов из подотрезков равных значений, на которые разбивается отрезок текущей вершины. Разумеется, чтобы у нас не было логарифма нуля, мы будем брать логарифмы элементов, увеличенных на $1$.</p>
<p>Как уже было сказано ранее, потенциалы помеченных вершин при этом считаются равными нулю.
Потенциал всего дерева как всегда равен сумме потенциалов всех вершин.</p>
<p>Наш новый потенциал не больше старого, так что очевидно, что изначально $\Phi \le n \log n \log C$.</p>
<p>При посещении тупиковых вершин либо потенциал не меняется, если выполнилось <code>breakCondition</code>, либо потенциал как был нулем, так и останется, если выполнилось <code>tagCondition</code>, потому что такие вершины помечены.</p>
<p>При посещении дополнительных вершин в запросе первого типа не появляется никаких новых отрезков значений. Только старые значения уменьшаются и, возможно, некоторые отрезки склеиваются, так что потенциал может только уменьшаться.</p>
<p>Вершины, которые отвечают за отрезки, лежащие полностью внутри отрезка изменения запроса второго типа, становятся помеченными, поэтому потенциал в них становится равен нулю.</p>
<p>При посещении же обычных вершин потенциалы могут увеличиваться, но не очень сильно, при запросах обоих типов. Могло появиться не более трех новых отрезков элементов, каждый из которых даст вклад $O(\log C)$ в потенциал. А если учесть, что обычных вершин в каждом запросе $O(\log n)$, можно понять, что потенциал за все время увеличится максимум на $O(q \log n \log C)$.</p>
<p>Остается лишь показать, что при посещении дополнительной вершины потенциал уменьшается хотя бы на $1$. Действительно, не выполнилось ни <code>breakCondition</code>, ни <code>tagCondition</code>, так что вершина не помечена и $max \ge x$, поэтому на отрезке $max$ значение уменьшится хотя бы в два раза после взятие по модулю, поэтому потенциал текущей вершины уменьшится хотя бы на $1$. Что и требовалось доказать.</p>
<p>Таким образом, асимптотика получившегося алгоритма — $O((n + q) \log n \log C)$.</p>
<h2 id="sqrt--sum-max-min">$\sqrt{}=$, <code>+=</code>, $\sum$, $\max$, $\min$</h2>
<h3 id="формулировка-5">Формулировка</h3>
<p>В этой задаче у нас есть массив неотрицательных целых чисел $A$ ($0 \le A_i &lt; C$), а также имеются запросы пяти типов:</p>
<ol>
<li>Даны $ql, qr$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\left\lfloor \sqrt{A_i} \right\rfloor$.</li>
<li>Даны $ql, qr, x$ ($0 \le x &lt; C$). Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $x$.</li>
<li>Даны $ql, qr$. Необходимо вернуть сумму элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
<li>Даны $ql, qr$. Необходимо вернуть максимум элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
<li>Даны $ql, qr$. Необходимо вернуть минимум элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
</ol>
<p>Эта задача доступна <a href="https://vjudge.net/problem/HDU-5828">здесь</a> или <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5828">здесь</a>. Это китайские сайты, поэтому там не так просто зарегистрироваться.
На этих сайтах нет двух последних операций, но они поддерживаются абсолютно очевидно и все равно необходимы во время решения, так что это ничего не меняет.</p>
<h3 id="решение-4">Решение</h3>
<p>Мы будем поддерживать в каждой вершине сумму, максимум и минимум. Все запросы кроме первого типа выполняются так же, как и в обычном дереве отрезков.</p>
<p>Кроме того, для первой операции нам понадобится еще уметь присваивать на отрезке, поэтому в каждой вершине хранится $2$ <code>push</code>-а: что надо присвоить на отрезке и что надо прибавить на отрезке. При этом только один из них может быть в вершине, потому что комбинация присвоения и прибавления — это то же самое, что просто присвоение.</p>
<p><code>breakCondition</code> в этом случае является стандартным:</p>
<p><code>breakCondition = qr &lt;= l || r &lt;= ql</code>.</p>
<p>А каким же должно быть <code>tagCondition</code>? Первая идея, которая приходит в голову — это</p>
<p><code>tagCondition = ql &lt;= l &amp;&amp; r &lt;= qr &amp;&amp; </code> $\left\lfloor \sqrt{\max} \right\rfloor = \left\lfloor \sqrt{\min} \right\rfloor$,</p>
<p>потому что в этом случае корни из всех чисел на отрезке равны, и нужно просто произвести присвоение этому корню на этом отрезке. <strong>Однако это тот случай, когда очевидный вариант не работает!</strong> Представим себе ситуацию, в которой изначально массив имеет вид $1, 2, 1, 2, 1, 2, \ldots, 1, 2$. После чего к нему $\frac{q}{2}$ раз применяют две операции: $+=2$ на всем массиве и $\sqrt{}=$ на всем массиве.
После первой операции массив превращается в $3, 4, 3, 4, 3, 4, \ldots, 3, 4$. А после второй он возвращается в исходное состояние.
Однако заметим, что целая часть от корня из $3$ — это $1$, а целая часть от корня из $4$ — это $2$, поэтому ни в одной вершине кроме листьев <code>tagCondition</code> не выполнится, так что каждая операция $\sqrt{}=$ будет выполняться за $O(n)$, и итоговая асимптотика будет $O(q \cdot n)$. Поэтому это <code>tagCondition</code> нам не подходит.</p>
<p>На самом деле, правильный <code>tagCondition</code> выглядит следующим образом:</p>
<p><code>tagCondition = ql &lt;= l &amp;&amp; r &lt;= qr &amp;&amp; max[v] - min[v] &lt;= 1</code>.</p>
<p>Казалось бы, условие стало только слабее. Раньше мы проверяли, что корни совпадают, а теперь мы проверяем, что либо максимум равен минимуму, либо они отличаются на $1$. Но здесь кроется принципиальная разница. Единственный плохой случай — это когда $\max$ — это квадрат, а минимум на $1$ меньше. Тогда при взятии корня разница между ними останется равной $1$, и операцией <code>+=</code> можно будет вернуть массив в исходное положение.</p>
<p>Как же нам обновить значение в вершине, когда выполнилось <code>tagCondition</code>? Максимум и минимум, очевидно, заменяются на свои корни.
А как поменяется сумма? Если целые части корней из минимума и максимума равны, то после применения операции на отрезке все числа будут равны, поэтому нужно просто присвоить $\left\lfloor \sqrt{\max} \right\rfloor$ на отрезке. Это частный случай неправильного <code>tagCondition</code>, который мы обсуждали ранее.</p>
<p>Остается один случай: если целые части корней из минимума и максимума не совпадают. При этом максимум и минимум отличаются в точности на $1$. Тогда и корни тоже будут отличаться в точности на $1$. Максимум был равен $k^2$, а минимум $k^2 - 1$. При этом $k^2$ заменился на $k$, а $k^2 - 1$ заменился на $k - 1$. Поэтому нужно просто ко всем числам на отрезке прибавить $k - k^2$.</p>
<h3 id="доказательство-4">Доказательство</h3>
<p>Давайте докажем, что с таким <code>tagCondition</code> асимптотика будет $O(n \log C + q \log n \log C)$.</p>
<p>Давайте введем потенциал вершины $\varphi(v) = \log($<code>max[v]-min[v]</code>$+ 1)$. Прибавление единицы опять же нужно только для того, чтобы не брать логарифм нуля в случае, когда максимум равен минимуму.
Общим потенциалом $\Phi$ будет сумма потенциалов всех вершин дерева.</p>
<p>Заметим, что потенциал любой вершины неотрицателен и не превышает $\log C$, так что в любой момент времени верно $0 \le \Phi \le O(n \log C)$.</p>
<p>При этом как может увеличиваться этот потенциал? В запросах типа <code>get</code> элементы массива не меняются, так что потенциал тоже не меняется. Для запросов второго типа потенциал вершины мог поменяться только в том случае, если данная вершина пересекается с отрезком запроса, но не лежит в нем полностью, потому что если она лежит в нем полностью, то и к минимуму, и к максимуму прибавится $x$, так что разность не поменяется. А вершин, которые пересекаются с отрезком запроса, но не лежат в нем полностью, $O(\log n)$ штук, так что потенциал может увеличиться максимум на $O(q \log n \log C)$ за все время.</p>
<p>Аналогично, операция $\sqrt{}=$ не может увеличить потенциал, если вершина полностью лежит в отрезке запроса, потому что разность корней не больше разности исходных чисел (это легко проверить, но дальше мы докажем даже более сильное условие). А вершин, которые пересекаются с запросом, но не лежат в нем полностью, опять же $O(\log n)$ штук, так что опять же увеличение за все время — это $O(q \log n \log C)$.</p>
<p>Осталось понять, что при посещении дополнительной вершины потенциал уменьшается хотя бы на $\log (1.5)$ (не пугайтесь этого числа, на самом деле неважно, чему оно равно, главное, что это положительная константа), тогда итоговая асимптотика будет равна $O(n \log C + q \log n \log C)$. В этом нам поможет следующий факт:</p>
<p><strong>Теорема:</strong>
Если $a$ и $b$ — неотрицательные целые числа, и $a \ge b + 2$, то $a - b \ge 1.5 \cdot \left( \left\lfloor \sqrt{a} \right\rfloor - \left\lfloor \sqrt{b} \right\rfloor \right) + 0.5$.</p>
<p><strong>Доказательство:</strong>
Обозначим  $\left\lfloor \sqrt{b} \right\rfloor = m$ и $\left\lfloor \sqrt{a} \right\rfloor = n + m$. При этом $n \ge 0$, потому что $a &gt; b$.
Тогда $b = m^2 + l$, где $0 \le l \le 2 \cdot m$ и $a = (n + m)^2 + k$, где $0 \le k \le 2 \cdot (n + m)$. Разберем два случая:</p>
<ol>
<li>$n \le 1$. То есть $\left\lfloor \sqrt{a} \right\rfloor - \left\lfloor \sqrt{b} \right\rfloor \le 1$, так что неравенство, которое нам надо доказать, превращается в $a - b \ge 1.5 \cdot 1 + 0.5 = 2$. Это верно из-за условия на то, что $a \ge b + 2$.</li>
<li>$n \ge 2$. В этом случае мы знаем, что $a \ge (n + m)^2$ и $b \le m^2 + 2m$, поэтому $a - b \ge (n + m)^2 - (m^2 + 2m) = n^2 + 2nm - 2m = n^2 + 2m \cdot (n - 1) \ge n^2$. Последнее неравенство верно, потому что все множители во втором слагаемом неотрицательны. Нам нужно доказать, что это не меньше, чем $1.5 \cdot n + 0.5$. Это легко проверить, потому что $n^2 \ge 2n = 1.5n + 0.5n \ge 1.5n + 0.5$. Первое неравенство верно из-за того, что $n \ge 2$, а второе из-за того, что $n \ge 1$. Что и требовалось доказать.</li>
</ol>
<p>Давайте немного преобразуем получившееся неравенство. Прибавим к обеим частям $1$:</p>
<p>$$a - b + 1 \ge 1.5  \left( \left\lfloor \sqrt{a} \right\rfloor - \left\lfloor \sqrt{b} \right\rfloor + 1\right)$$</p>
<p>И возьмем логарифмы от обеих частей:</p>
<p>$$\log(a - b + 1) \ge \log \left(1.5  \left( \left\lfloor \sqrt{a} \right\rfloor - \left\lfloor \sqrt{b} \right\rfloor + 1\right)\right) = \log (1.5) + \log \left( \left\lfloor \sqrt{a} \right\rfloor - \left\lfloor \sqrt{b} \right\rfloor + 1\right)$$</p>
<p>То есть мы доказали, что потенциал уменьшился хотя бы на $\log (1.5)$, и асимптотика решения доказана.</p>
<p><strong>Замечание:</strong>
Обратите внимание, что операция присвоения на отрезке будет менять потенциалы так же несильно, как и операция прибавления на отрезке, так что ее мы тоже можем поддерживать. Кроме того, мы и так присваиваем на отрезке в одном из случаев, когда берем корень, поэтому особо ничего нового к решению добавлять не придется.</p>
<h2 id="--sum-max-min"><code>/=</code>, <code>+=</code>, $\sum$, $\max$, $\min$</h2>
<h3 id="формулировка-6">Формулировка</h3>
<p>В этой задаче у нас есть массив неотрицательных целых чисел $A$ ($0 \le A_i &lt; C$), а также имеются запросы пяти типов:</p>
<ol>
<li>Даны $ql, qr, x$ ($x \ge 0$). Нужно поделить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $x$ нацело.</li>
<li>Даны $ql, qr, y$ ($1 \le y &lt; C$). Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $y$.</li>
<li>Даны $ql, qr$. Необходимо вернуть сумму элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
<li>Даны $ql, qr$. Необходимо вернуть максимум элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
<li>Даны $ql, qr$. Необходимо вернуть минимум элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
</ol>
<h3 id="решение-5">Решение</h3>
<p>Как бы это ни было удивительно, но решение абсолютно идентично решению предыдущей задачи.</p>
<p><code>breakCondition = qr &lt;= l || r &lt;= ql</code></p>
<p><code>tagCondition = ql &lt;= l &amp;&amp; r &lt;= qr &amp;&amp; max[v] - min[v] &lt;= 1</code></p>
<p>Есть только одно новое условие: если мы пытаемся поделить на отрезке на единицу, то мы просто проигнорируем этот запрос, потому что деление на $1$ не меняет элементов.</p>
<p>И в случае, если <code>tagCondition</code> выполнилось, мы делаем точно такие же изменения, как и для корня. Если $\left\lfloor \frac{\max}{x} \right\rfloor = \left\lfloor \frac{\min}{x} \right\rfloor$, то нужно всем числам на отрезке присвоить $\left\lfloor \frac{\max}{x} \right\rfloor$, а если $\left\lfloor \frac{\max}{x} \right\rfloor \neq \left\lfloor \frac{\min}{x} \right\rfloor$, то тогда $\max = kx$ для некоторого $k$ и $\min = kx - 1$. При этом $\left\lfloor \frac{\max}{x} \right\rfloor = k$ и $\left\lfloor \frac{\min}{x} \right\rfloor = k - 1$, так что надо просто ко всем числам на отрезке прибавить $k - kx$.</p>
<h3 id="доказательство-5">Доказательство</h3>
<p>Почему же такое решение будет работать?</p>
<p>Проведем абсолютно такое же доказательство с таким же потенциалом. Для всех операций кроме первой ничего не поменялось. Для первой операции опять же потенциал вершины не мог увеличиться, если вершина полностью лежит в отрезке запроса, потому что после деления разность максимума и минимума не могла увеличиться (это несложно проверить, но далее мы докажем более сильное условие).</p>
<p>Так что все, что нам надо доказать, — это то, что при посещении дополнительной вершины потенциал уменьшится хотя бы на $\log (\frac{4}{3})$ (как и раньше, просто положительная константа), и тогда асимптотика будет равна $O(n \log C + q \log n \log C)$. В этот момент нам как раз пригодится то, что мы игнорируем запросы, в которых $x = 1$, потому что в этом случае никакие потенциалы не меняются, и мы бы просто делали лишние действия.</p>
<p><strong>Теорема:</strong>
Если $a$, $b$ и $x$ — неотрицательные целые числа, при этом $a \ge b + 2$ и $x \ge 2$, то $a - b \ge \frac{4}{3} \cdot \left( \left\lfloor \frac{a}{x} \right\rfloor - \left\lfloor \frac{b}{x} \right\rfloor \right) + \frac{1}{3}$.</p>
<p><strong>Доказательство:</strong>
Обозначим  $\left\lfloor \frac{b}{x} \right\rfloor = m$ и $\left\lfloor \frac{a}{x} \right\rfloor = n + m$. При этом $n \ge 0$, потому что $a &gt; b$.
Тогда $b = mx + l$, где $0 \le l &lt; x$ и $a = (n + m) \cdot x + k$, где $0 \le k &lt; x$. Разберем два случая:</p>
<ol>
<li>$n \le 1$. То есть $\left\lfloor \frac{a}{x} \right\rfloor - \left\lfloor \frac{b}{x} \right\rfloor \le 1$, так что неравенство, которое нам надо доказать, превращается в $a - b \ge \frac{4}{3} \cdot 1 + \frac{1}{3} = \frac{5}{3}$. Это верно из-за условия на то, что $a \ge b + 2$.</li>
<li>$n \ge 2$. В этом случае мы знаем, что $a \ge (n + m) \cdot x$ и $b \le mx + x - 1$, поэтому $a - b \ge (n + m) \cdot x - (mx + x - 1) = nx - x + 1$. И мы хотим доказать, что это не меньше, чем $\frac{4}{3} n + \frac{1}{3}$. Перенесем все из правой части в левую, а $x$ перенесем в правую:</li>
</ol>
<p>$$n \cdot \left(x - \frac{4}{3}\right) + \frac{2}{3} \ge x$$</p>
<p>$n \ge 2$, поэтому заменим в левой части:</p>
<p>$$2 \cdot \left(x - \frac{4}{3}\right) + \frac{2}{3} \ge x$$</p>
<p>Если раскрыть левую часть, получится:</p>
<p>$$2x - 2 \ge x$$</p>
<p>Это верно в силу того, что $x \ge 2$. Что и требовалось доказать.</p>
<p>Давайте немного преобразуем получившееся неравенство. Прибавим к обеим частям $1$:</p>
<p>$$a - b + 1 \ge \frac{4}{3} \left( \left\lfloor \frac{a}{x} \right\rfloor - \left\lfloor \frac{b}{x} \right\rfloor + 1\right)$$</p>
<p>И возьмем логарифмы от обеих частей:</p>
<p>$\log(a - b + 1) \ge \log \left(\frac{4}{3}  \left( \left\lfloor \frac{a}{x} \right\rfloor - \left\lfloor \frac{b}{x} \right\rfloor + 1\right)\right) = \log (\frac{4}{3}) + \log \left( \left\lfloor \frac{a}{x} \right\rfloor - \left\lfloor \frac{b}{x} \right\rfloor + 1\right)$.</p>
<p>То есть мы доказали, что потенциал уменьшился хотя бы на $\log (\frac{4}{3})$, и асимптотика решения доказана.</p>
<h2 id="--max"><code>&amp;=</code>, <code>|=</code>, $\max$</h2>
<h3 id="формулировка-7">Формулировка</h3>
<p>В этой задаче у нас есть массив целых чисел $A$ ($0 \le A_i &lt; C$), а также имеются запросы трех типов:</p>
<ol>
<li>Даны $ql, qr, x$ ($0 \le x &lt; C$). Нужно заменить все элементы массива $a$ на полуинтервале $[ql, qr)$ на $A_i \&amp; x$ (побитовое &laquo;и&raquo;).</li>
<li>Даны $ql, qr, x$ ($0 \le y &lt; C$). Нужно заменить все элементы массива $a$ на полуинтервале $[ql, qr)$ на $A_i | x$ (побитовое &laquo;или&raquo;).</li>
<li>Даны $ql, qr$. Необходимо вернуть максимум элементов массива $A$ на полуинтервале $[ql, qr)$.</li>
</ol>
<p>В данном случае стоит считать, что $C = 2^k$ для некоторого натурального $k$, то есть мы работаем с $k$-битными числами.</p>
<p>Эта задача доступна <a href="https://csacademy.com/contest/round-70/task/and-or-max/">здесь</a>.</p>
<h3 id="решение-6">Решение</h3>
<p>Давайте заметим, что $\&amp;$ — это то же самое, что побитовый минимум, а $|$ — побитовый максимум, так что эта задача — это в каком-то смысле вариация Ji Driver Segment Tree для битовых операций.</p>
<p>Давайте хранить в каждой вершине дерева максимум на соответствующем подотрезке, побитовое &laquo;или&raquo;, побитовое &laquo;и&raquo;, а также ленивые обновления типа <code>pushAnd</code> и <code>pushOr</code>, которые означают, что ко всем числам на отрезке нужно применить операцию &laquo;и&raquo;, а также &laquo;или&raquo;. Можно заметить, что даже если к нам приходят много операций первых двух типов, мы все равно можем скомбинировать их в два таких значения, которые нужно проталкивать.</p>
<p>Теперь осталось понять, как это все считать, и какие будут <code>breakCondition</code> и <code>tagCondition</code>. В данном случае нестандартным будет только <code>tagCondition</code>. Почему нам вообще не подходит обычное дерево отрезков? Потому что если ко всем числам на отрезке применить запрос одного из первых двух типов, то их относительных порядок может сильно поменяться, а значит, поменяется и максимум. Но в каком случае относительный порядок не поменяется? Посмотрим для примера на первую операцию. Какими свойствами должны обладать числа $a_1 \le a_2 \le \ldots \le a_k$, чтобы при этом выполнялось $a_1 \&amp; x \le a_2 \&amp; x \le \ldots \le a_k \&amp; x$? Те биты, которые в $x$ установлены в единицу, не поменяются в числах. Поменяются только те биты, которые у $a_i$ установлены в $1$, а у $x$ — в $0$. И если у какого-то $a_i$ была установлена $1$, а у другого $0$, то их относительный порядок мог поменяться. Но если на всех позициях, в которых у числа $x$ стоит ноль, у всех $a_i$ стоят одинаковые биты, то относительный порядок никак не изменится. Аналогичное утверждение можно сформулировать для операции &laquo;или&raquo;: если на всех позициях, в которых у числа $y$ стоит единица, у всех $a_i$ выставлены одинаковые биты, то их относительный порядок не изменится.</p>
<p>А проверить, что на этих позициях у всех чисел стоят одинаковые биты, очень легко. Достаточно посмотреть на побитовое &laquo;и&raquo; и побитовое &laquo;или&raquo; всех чисел на отрезке. Тогда если какой-то бит у них совпадает, это как раз равносильно тому, что у всех чисел на отрезке этот бит совпадает. Так что <code>tagCondition</code> для первой и второй операции соответственно будут выглядеть следующим образом:</p>
<p><code>tagCondition_and = ql &lt;= l &amp;&amp; r &lt;= qr &amp;&amp; ((and[v] ^ or[v]) &amp; ~x) == 0</code></p>
<p><code>tagCondition_or = ql &lt;= l &amp;&amp; r &lt;= qr &amp;&amp; ((and[v] ^ or[v]) &amp; y) == 0</code></p>
<p><strong>Упражнение:</strong>
Хорошим упражнением будет понять, почему эта битовая магия соответствует именно тем условиям, которые мы описали ранее.</p>
<h3 id="доказательство-6">Доказательство</h3>
<p>Почему же такое решение будет работать быстро?</p>
<p>Давайте введем потенциал $\varphi(v)$ вершины $v$ дерева отрезков, который будет равен количеству битов, в которых не все числа на соответствующем отрезке совпадают, то есть, иными словами, <code>__builtin_popcount(and[v] ^ or[v])</code>. Потенциал всего дерева $\Phi$, как обычно, будет равен сумме потенциалов всех вершин.</p>
<p>Заметим, что $0 \le \varphi(v) \le \log C$, потому что у нас есть всего $\log C$ битов, так что отличающихся не больше. Поэтому в любой момент времени $0 \le \Phi \le n \log C$.</p>
<p>В каких случаях потенциал может увеличиваться? Операция третьего типа не меняет элементов массива, так что потенциал тоже не меняется. Если у всех чисел на каком-то отрезке какой-то бит был равен, и мы применили ко всем этим числам операцию одного из первых двух типов, то этот бит не мог перестать быть равен. Так что увеличения потенциала могли происходить только в вершинах, подотрезок которых пересекается, но не лежит полностью в отрезке запроса, то есть в обычных вершинах. При этом для каждой такой вершины потенциал мог увеличиться максимум на $\log C$, а для каждого запроса таких вершин $O(\log n)$, так что можно сказать, что $\Phi_+ \le O(q \log n \log C)$.</p>
<p>Теперь поймем, почему при посещении дополнительных вершин потенциал уменьшается. Если мы посетили какую-то дополнительную вершину, то существует такой бит, что на данный момент не у всех чисел он одинаковый, и при этом у $x$ он выставлен в $0$ (либо у $y$ в $1$ для запросов второго типа), то есть после применения текущего запроса у всех чисел этот бит будет равен нулю (или единице для запросов второго типа). Так что потенциал текущей вершины уменьшится как минимум на $1$. Что и требовалось доказать.</p>
<p>Поэтому асимптотика получившегося алгоритма — $O(n \log C + q \log n \log C)$.</p>
<h2 id="min--max-over-sum-для-нескольких-массивов-параллельно"><code>min=</code>, <code>+=</code>, $\max$ over $\sum$ для нескольких массивов параллельно</h2>
<h3 id="формулировка-8">Формулировка</h3>
<p>В этой задаче у нас есть сразу <strong>два массива</strong> целых чисел $A$ и $B$, а также имеются запросы пяти типов:</p>
<ol>
<li>Даны $ql, qr, x$. Нужно заменить все элементы массива $a$ на полуинтервале $[ql, qr)$ на $\min(A_i, x)$.</li>
<li>Аналогичный запрос для массива $B$.</li>
<li>Даны $ql, qr, y$. Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $y$.</li>
<li>Аналогичный запрос для массива $B$.</li>
<li>Даны $ql, qr$. Необходимо вернуть $\max_{ql \le i &lt; qr} A_i + B_i$.</li>
</ol>
<p>Последний запрос как раз называется $\max$ over $\sum$, то есть максимум от поэлементной суммы двух массивов.</p>
<p>Также в конце решения мы покажем, как это обобщается на случай бóльшего количества массивов.</p>
<h3 id="решение--доказательство">Решение + доказательство</h3>
<p>Если бы у нас не было операции <code>min=</code>, то эта задача была бы весьма простой. Мы бы пользовались обычным деревом отрезков, и если мы на отрезке прибавляем число в одном из массивов, то к максимуму поэлементной суммы массивов тоже прибавится это самое число. Иными словами, можно считать, что у нас есть всего один массив $C$, определенный по правилу $C_i = A_i + B_i$, и операции производятся с ним.</p>
<p>Однако, если у нас есть операция <code>min=</code>, то нам важны значения каждого из массивов по отдельности.</p>
<p>Мы воспользуемся стандартной техникой из Ji Driver Segment Tree, то есть будем хранить максимум, их количество и второй максимум. Тогда при условии <code>tagCondition</code> мы меняем в массиве какой-то разрозненный набор позиций, на которых стоят максимумы. Как в таком случае пересчитать максимум поэлементной суммы массивов? Давайте разделим позиции на подотрезке, которому соответсвует текущая вершина, на 4 типа:</p>
<ol>
<li>В обоих массивах на этой позиции стоят максимумы на отрезке</li>
<li>В первом массиве на этой позиции стоит максимум на отрезке, а во втором — нет</li>
<li>Во втором массиве на этой позиции стоит максимум на отрезке, а в первом — нет</li>
<li>В обоих массивах на этой позиции стоят не максимумы на отрезке</li>
</ol>
<p>И после такого разделения выясняется, что хранить максимум сумм для каждого из четырех типов по отдельности оказывается очень просто. Если выполнилось <code>tagCondition</code>, то нужно поменять значения, соответствующие тем типам, в которых в этом массиве стоит максимум. При этом значение максимума изменилось с <code>max</code> на $x$, поэтому из соответствующих значений как раз надо отнять <code>max</code>$-x$.
Ответом на запрос тогда будет просто максимум из четырех отдельных максимумов для каждого из типов.</p>
<p>Осталось научиться пересчитывать значения в вершине через значения в детях. Но это тоже делается очень просто. Мы сначала пересчитываем максимумы в обоих массивах в текущей вершине, после чего для каждого типа каждого из детей понимаем, стоят ли там максимумы или нет. Если там был не максимум для сына, то это будет не максимум и для отца; а если это был максимум для сына, то он мог как остаться максимумом, так и перестать им быть.</p>
<p>Решение ничем не отличается от задачи <code>max=</code>, <code>+=</code>, мы просто поддерживаем в вершине четыре дополнительных значения. Поэтому асимптотика получается $O(n \log n + q \log^2 n)$.</p>
<p><strong>Замечание:</strong>
Если подумать, можно заметить, что эта идея легко обобщается на большее количество массивов. Если у нас $k$ массивов, то мы будем поддерживать $2^k$ дополнительных величин в каждой вершине, потому что в каждом массиве на каждой позиции может стоять либо максимум, либо не максимум (2 варианта), и можно брать всевозможные комбинации максимумов и не максимумов для разных массивов. Получается всего $2^k$ различных комбинаций. И асимптотика тогда возрастет до $O((n \log n + q \log^2 n) \cdot 2^k)$.</p>
<h2 id="историческая-информация-количество-изменений-элемента">Историческая информация: количество изменений элемента</h2>
<h3 id="формулировка-9">Формулировка</h3>
<p>В этой задаче у нас есть массив целых чисел $A$, а также имеются запросы четырех типов:</p>
<ol>
<li>Даны $ql, qr, x$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\min(A_i, x)$.</li>
<li>Даны $ql, qr, y$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\max(A_i, y)$.</li>
<li>Даны $ql, qr, z$. Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $z$.</li>
<li>Даны $ql, qr$. Необходимо вернуть сумму элементов массива $S$ на полуинтервале $[ql, qr)$, где $S_i$ — это количество раз, когда $i$-й элемент массива $A$ менялся.</li>
</ol>
<h3 id="решение--доказательство-1">Решение + доказательство</h3>
<p>Эта задача — первый базовый пример того, что такое &laquo;историческая информация&raquo;. Обычно мы делаем запросы к элементам массива на данный момент, и мы не заботимся о том, как текущий массив был получен. Историческая информация же хранит в себе знания о том, как наш массив менялся с течением времени, а не только его финальный вид.</p>
<p>Однако нет ничего сложного в том, чтобы поддерживать эту информацию. Если бы у нас была только операция <code>+=</code>, то каждый раз, когда массив $A$ меняют на полуинтервале $[ql, qr)$, к массиву $S$ надо было бы на этом полуинтервале просто прибавить $1$, потому что при каждой операции меняются абсолютно все элементы на подотрезке. Однако когда появляется операция <code>min=</code>, это уже неверно. Но все еще мы можем понять, сколько элементов поменялось. Мы останавливаем рекурсию в тот момент, когда выполнилось <code>tagCondition</code>. Это значит, что меняются только максимумы. Поэтому изменится ровно <code>cntMax</code> элементов. На асимптотику алгоритма это никак влиять не будет, она все еще будет равна $O(n \log n + q \log^2 n)$. Стоит помнить о том, что если мы храним отложенную информацию о двух операциях <code>min=</code>, то элементы ниже поменялись дважды.</p>
<p>Далее мы рассмотрим более сложные версии исторической информации.</p>
<h2 id="историческая-информация-исторический-максимум">Историческая информация: исторический максимум</h2>
<h3 id="формулировка-10">Формулировка</h3>
<p>В этой задаче у нас есть массив целых чисел $A$, а также имеются запросы трех типов:</p>
<ol>
<li>Даны $ql, qr, x$. Нужно заменить все элементы массива $A$ на полуинтервале $[ql, qr)$ на $\min(A_i, x)$.</li>
<li>Даны $ql, qr, y$. Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $y$.</li>
<li>Даны $ql, qr$. Необходимо вернуть сумму элементов массива $M$ на полуинтервале $[ql, qr)$, где $M_i$ — это исторический максимум $A_i$, то есть самое большое значение, которое хранилось в $A_i$ за все время.</li>
</ol>
<p>Эта задача доступна <a href="https://uoj.ac/problem/169">здесь</a> в немного ином виде. Там вместо максимумов минимумы, и третий запрос берет не сумму элементов массива $M$, а максимум.</p>
<p>Также похожая задача есть <a href="https://www.luogu.com.cn/problem/P4314">здесь</a>.</p>
<h3 id="решение--доказательство-2">Решение + доказательство</h3>
<p>Первые две операции мы поддерживаем как обычно. И асимптотика получившегося алгоритма будет опять же $O(n \log n + q \log^2 n)$. Остается понять, как поддерживать сумму на отрезке массива $M$.</p>
<p>Давайте введем дополнительный массив $D$, элементы которого будут определяться по формуле $D_i = M_i - A_i$. А массив $M$ мы на самом деле не будем нигде поддерживать. Действительно, заметим, что</p>
<p>$$
\sum_{ql \le i &lt; qr} M_i = \sum_{ql \le i &lt; qr} \left( \left(M_i - A_i \right) + A_i \right) =
\sum_{ql \le i &lt; qr} \left( D_i + A_i \right) = \sum_{ql \le i &lt; qr} D_i + \sum_{ql \le i &lt; qr} A_i
$$</p>
<p>Поэтому нам нужно уметь отдельно поддерживать сумму на отрезках массивов $A$ и $D$, и с их помощью мы сможем находить сумму на отрезке массива $M$. В этом и заключается основная идея исторического максимума. Но почему пересчитывать массив $D$ проще, чем массив $M$?</p>
<p>Давайте сначала рассмотрим, что произойдет с массивом $D$ после операции второго типа. К элементам массива $A$ прибавится $x$, поэтому из $D$ нужно вычесть $x$. Однако если $A_i$ стало новым историческим максимумом, то $M_i$ тоже изменится, и станет равно $A_i$. Это происходит ровно в тот момент, когда $M_i - A_i$ становится отрицательным, и в этот момент нужно заменить $D_i$ на ноль. То есть на самом деле $D_i$ заменяется на $\max(D_i - x, 0)$. А эту операцию можно разделить на две: сначала вычесть на отрезке, а потом применить <code>max=</code> на отрезке с нулем. Это все мы умеем делать.</p>
<p>Теперь разберемся, что происходит с массивом $D$ при операции <code>min=</code>. В этой операции элементы могут только убывать, поэтому $M_i$ точно не поменяются. А $A_i$ поменяются весьма понятным образом. Когда мы пришли в вершину, в которой выполнилось <code>tagCondition</code>, $D_i$ поменяется точно так же, как и $A_i$, а далее это изменение надо будет просто протолкнуть в детей.</p>
<h2 id="историческая-информация-историческая-сумма">Историческая информация: историческая сумма</h2>
<h3 id="формулировка-11">Формулировка</h3>
<p>В этой задаче у нас есть массив целых чисел $A$, а также имеются запросы двух типов:</p>
<ol>
<li>Даны $ql, qr, x$. Нужно прибавить ко всем элементам массива $A$ на полуинтервале $[ql, qr)$ число $x$.</li>
<li>Даны $ql, qr$. Необходимо вернуть сумму элементов массива $S$ на полуинтервале $[ql, qr)$, где $S_i$ — сумма элементов, стоящих на позиции $i$ в массиве $A$ за все время. То есть после каждой операции к $S_i$ прибавляется $A_i$ для всех позиций $i$.</li>
</ol>
<h3 id="решение--доказательство-3">Решение + доказательство</h3>
<p>Эта задача похожа на предыдущую, но на этот раз вместо исторического максимума мы поддерживаем историческую сумму. В этой задаче нам хватит на самом деле даже обычного дерева отрезков.</p>
<p>Введем дополнительный массив $D$, элементы которого будут определяться по формуле $D_i = S_i - ind \cdot A_i$, где $ind$ — это количество операций, которые уже были произведены с массивом на данный момент (после каждой операции $ind$ увеличивается на $1$).</p>
<p>Опять же, сам массив $S$ мы нигде поддерживать не будем, потому что</p>
<p>$$
\sum_{ql \le i &lt; r} S_i = \sum_{ql \le i &lt; r} \left(D_i + ind \cdot A_i\right) = \sum_{ql \le i &lt; r} D_i + ind \cdot \sum_{ql \le i &lt; r} A_i
$$</p>
<p>Так что поддерживая сумму на отрезке в массивах $D$ и $A$, мы сможем вычислять сумму на отрезке в массиве $S$.
Посмотрим, как меняются элементы массива $D$ при операции первого типа.
Пускай до этой операции у нас были массивы $S$, $A$ и $D$, а после применения операции они превратились в массивы $S'$, $A'$ и $D'$.
Мы хотим научиться вычислять $D'$. Мы знаем, что $D_i = S_i - ind \cdot A_i$ и $D'_i = S'_i - (ind + 1) \cdot A'_i$, потому что после применения операции $ind$ увеличился на $1$. Давайте раскроем последнюю формулу:</p>
<p>$$D'_i = S'_i - (ind + 1) \cdot A'_i = (S_i + A'_i) - (ind + 1) \cdot A'_i=$$</p>
<p>$$= S_i - ind \cdot A'_i = S_i - ind \cdot (A_i + x) = S_i - ind \cdot A_i - ind \cdot x = D_i - ind \cdot x$$</p>
<p>Так что у массиву $D$ тоже просто прибавляется константа ($-ind \cdot x$) на отрезке. Для элементов, которые не меняются, к $S_i$ прибавится $A_i$ и $ind$ увеличится на $1$, поэтому $D_i$ никак не поменяются.</p>
<h2 id="задачи-для-практики">Задачи для практики</h2>
<ul>
<li>
<p><a href="https://codeforces.com/contest/438/problem/D">Первая задача</a> из этой главы. <code>%=</code> на отрезке, присвоение в точке и поиск суммы на отрезке.</p>
</li>
<li>
<p>Ji Driver Segment Tree ($\min=$ на отрезке и поиск суммы на отрезке) можно решить <a href="https://vjudge.net/problem/HDU-5306">здесь</a> и <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5306">здесь</a>.</p>
</li>
<li>
<p>Кроме того есть не совсем очевидное применение Ji Driver Segment Tree в задаче <a href="https://codeforces.com/problemset/problem/855/F">&laquo;Нагайна&raquo;</a>.</p>
</li>
<li>
<p>Задачу с операцией $\sqrt{}=$ на отрезке можно решить <a href="https://vjudge.net/problem/HDU-5828">здесь</a> или <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5828">здесь</a>.</p>
</li>
<li>
<p>Задачу с операцией $/=$ на отрезке можно решить <a href="https://www.hackerrank.com/challenges/box-operations/problem">здесь</a>.</p>
</li>
<li>
<p>Задача с операциями $\&amp;=$ и $|=$ на отрезке и поиском максимума на отрезке доступна <a href="https://csacademy.com/contest/round-70/task/and-or-max/">здесь</a>.</p>
</li>
<li>
<p>Задача на сумму исторических максимумов доступна <a href="https://uoj.ac/problem/169">здесь</a>. Также есть похожая задача <a href="https://www.luogu.com.cn/problem/P4314">здесь</a>.</p>
</li>
<li>
<p>Кроме того можете прорешать специально подготовленный <a href="https://codeforces.com/group/1rv4rhCsHp/contest/327313">контест</a> на codeforces.  Если у вас нет доступа к соревнованию, нужно сначала вступить в <a href="https://codeforces.com/group/1rv4rhCsHp/contests">группу</a>.</p>
</li>
</ul>

      </div>
      
    </main>
    <footer id="footer">
  <div>
    <span>© 2021</span> - <span>2021</span>
  </div>

  <div>
    <span>Powered by </span>
    <a class="link" href="https://gohugo.io/">Hugo</a>
    <span> 🍦 Theme </span>
    <a class="link" href="https://github.com/queensferryme/hugo-theme-texify">TeXify</a>
  </div>

  <div class="footnote">
    <span></span>
  </div>
</footer>

  </div>
  





</body>

</html>
