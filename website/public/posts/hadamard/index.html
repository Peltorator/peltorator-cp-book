<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">


<meta name="author" content="peltorator">



<meta name="description" content="Быстрое преобразование Фурье сворачивает два массива, отправляя $a[i], b[j] \to c[i &#43; j]$, что соответствует тому, что $x^i \cdot x^j = x^{i &#43; j}$.
Сейчас мы рассмотрим случаи, когда $x^i \cdot x^j = x^{i \oplus j}$, $x^i \cdot x^j = x^{i | j}$ и $x^i \cdot x^j = x^{i \&amp; j}$.
Преобразование Фурье выглядело примерно таким образом: была матрица
$$M = \begin{pmatrix} \omega_0^0 &amp; \omega_0^1 &amp; \omega_0^2 &amp; \ldots &amp; \omega_0^{n - 1}\\">



<link rel="icon" href="/favicon.ico">



<meta name="keywords" content=" hugo  latex  theme ">




<script>
  
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true,
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    }
  };
</script>

<script async defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>



<link rel="stylesheet" type="text/css" href="http://tikzjax.com/v1/fonts.css">
<script src="https://tikzjax.com/v1/tikzjax.js"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<link rel="canonical" href="https://peltorator.ru/posts/hadamard/">




<title>Преобразование Уолша — Адамара и xor-and-or-свертки - peltorator</title>



<link media="screen" rel="stylesheet" href='https://peltorator.ru/css/common.css'>
<link media="screen" rel="stylesheet" href='https://peltorator.ru/css/content.css'>
<link media="screen" rel="stylesheet" href='https://peltorator.ru/css/highlight.css'>


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Преобразование Уолша — Адамара и xor-and-or-свертки" />
<meta name="twitter:description" content="Быстрое преобразование Фурье сворачивает два массива, отправляя $a[i], b[j] \to c[i &#43; j]$, что соответствует тому, что $x^i \cdot x^j = x^{i &#43; j}$.
Сейчас мы рассмотрим случаи, когда $x^i \cdot x^j = x^{i \oplus j}$, $x^i \cdot x^j = x^{i | j}$ и $x^i \cdot x^j = x^{i \&amp; j}$.
Преобразование Фурье выглядело примерно таким образом: была матрица
$$M = \begin{pmatrix} \omega_0^0 &amp; \omega_0^1 &amp; \omega_0^2 &amp; \ldots &amp; \omega_0^{n - 1}\\" />


  <link rel="stylesheet" href='https://peltorator.ru/css/single.css'>
</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="https://peltorator.ru/">peltorator</a>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      <a class="link" href="/">Статьи</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/about/">Полезные ссылки</a>
    </span>
    
  </nav>
</header>

    <main id="main" class="post">
      
      
      <div class="content">
        <!--- TODO: облачить все xor or and в ``--->
<p>Быстрое преобразование Фурье сворачивает два массива, отправляя $a[i], b[j] \to c[i + j]$,
что соответствует тому, что $x^i \cdot x^j = x^{i + j}$.</p>
<p>Сейчас мы рассмотрим случаи, когда
$x^i \cdot x^j = x^{i \oplus j}$, $x^i \cdot x^j = x^{i | j}$ и $x^i \cdot x^j = x^{i \&amp; j}$.</p>
<p>Преобразование Фурье выглядело примерно таким образом: была матрица</p>
<p>$$M =
\begin{pmatrix}
\omega_0^0 &amp; \omega_0^1 &amp; \omega_0^2 &amp; \ldots &amp; \omega_0^{n - 1}\\<br>
\omega_1^0 &amp; \omega_1^1 &amp; \omega_1^2 &amp; \ldots &amp; \omega_1^{n - 1}\\<br>
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>
\omega_{n - 1}^0 &amp; \omega_{n - 1}^1 &amp; \omega_{n - 1}^2 &amp; \ldots &amp; \omega_{n - 1}^{n - 1}
\end{pmatrix}
$$</p>
<p>Были векторы $A$ и $B$. Мы применяли матрицу $M$ к $A$ и $B$, после чего
перемножали $MA$ и $MB$ поэлементно, а затем применяли $M^{-1}$ к $MA \cdot MB$.</p>
<h2 id="xor-свертка">xor-свертка</h2>
<p>Здесь мы хотим сделать ровно то же самое, надо лишь поменять матрицу.</p>
<p>Давайте зададим матрицы $H_{2^k}$ рекурсивно.
$H_1 =
\begin{pmatrix}
1
\end{pmatrix}
$ и
$H_{2^k} = \frac{1}{\sqrt{2}}
\begin{pmatrix}
H_{2^{k - 1}} &amp; H_{2^{k - 1}}\\<br>
H_{2^{k - 1}} &amp; -H_{2^{k - 1}}
\end{pmatrix}
$</p>
<p>Корень из двух — это не очень удобное число, давайте попытаемся от него избавиться.
Определим матрицы без этого корня:
$G_1 =
\begin{pmatrix}
1
\end{pmatrix}
$ и
$G_{2^k} =
\begin{pmatrix}
G_{2^{k - 1}} &amp; G_{2^{k - 1}}\\<br>
G_{2^{k - 1}} &amp; -G_{2^{k - 1}}
\end{pmatrix}
$</p>
<p>Тогда легко заметить, что $\sqrt{n} \cdot H_n = G_n$. Мы будем считать именно $G_n$.</p>
<p><strong>Обозначение:</strong>
$E_n$ — это матрица тождественного преобразования размера $n \times n$, то есть матрица,
у которой на главной диагонали стоят единицы, а в остальных ячейках нули.</p>
<p>Из-за такого рекурсивного задания сразу видно, как написать быстрое преобразование Уолша-Адамара,
то есть как посчитать $G_{2^k} \cdot A$.
На нижнем уровне рекурсии не нужно менять ничего, потому что $G_1 = E_1$,
а на других уровнях надо сначала запуститься от двух половин, а потом сделать замену
$x, y \to x + y, x - y$. Напишем код:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">hadamard</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">hadamard</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="n">hadamard</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">l</span><span class="p">)];</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">a</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><strong>Лемма:</strong> <br>
Удивительным образом получается, что $H_{2^k}^{-1} = H_{2^k}$.</p>
<p><strong>Доказательство:</strong>
Докажем это по индукции.
Для $H_1$ это очевидно, потому что $H_1 = E_1$.
Докажем для $H_{2^k}$, если уже известно для $H_{2^{k - 1}}$.</p>
<p>$$H_{2^k} \cdot H_{2^k} =
\frac{1}{\sqrt{2}}
\begin{pmatrix}
H_{2^{k - 1}} &amp; H_{2^{k - 1}}\\<br>
H_{2^{k - 1}} &amp; -H_{2^{k - 1}}
\end{pmatrix}
\cdot
\frac{1}{\sqrt{2}}
\begin{pmatrix}
H_{2^{k - 1}} &amp; H_{2^{k - 1}}\\<br>
H_{2^{k - 1}} &amp; -H_{2^{k - 1}}
\end{pmatrix}
=$$</p>
<p>$$ = \frac{1}{2}
\begin{pmatrix}
2H_{2^{k - 1}}^2 &amp; 0\\<br>
0 &amp; 2H_{2^{k - 1}}^2
\end{pmatrix} = \frac{1}{2}
\begin{pmatrix}
2E_{2^{k - 1}} &amp; 0\\<br>
0 &amp; 2E_{2^{k - 1}}
\end{pmatrix}
$$</p>
<p>Мы получили, что $H_n \cdot H_n = E_n$.
Но мы знаем, что $H_n = \frac{G_n}{\sqrt{n}}$,
поэтому $G_n \cdot G_n = n \cdot E_n$.
Так что вместо того, чтобы домножать на $H$, можно домножать на $G$,
но в конце просто поделить на $n$ после обратного преобразования. Таким образом мы научились делать xor-умножение многочленов
без использования вещественных или комплексных чисел:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// we assume that a.size() == b.size() == 2^k
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">xormult</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">hadamard</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">hadamard</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">hadamard</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="c1">// inverse convolution is the same as direct
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Если вы внимательно следили за происходящим, то могли заметить, что я вас немного обманул.
Я доказал кучу всего, но никак не объяснил, почему все это даст нам xor-свертку.</p>
<p>Обозначим xor-свертку за $\$$, то есть</p>
<p>$$(a_0, a_1, \ldots, a_n) \$ (b_0, b_1, \ldots, b_n) =
(\sum \limits_{k = 0}^{n} a_k \cdot b_{0 \oplus k}, \sum \limits_{k = 0}^{n} a_k \cdot b_{1 \oplus k},
\ldots, \sum \limits_{k = 0}^{n} a_k \cdot b_{n \oplus k})$$</p>
<p>Тогда нам необходимо доказать, что $(Ga) \cdot (Gb) = G (a \$ b)$.
Для $G_1$ это очевидно, потому что свертка — это просто умножение чисел.
Для $G_2$ необходимо написать условия:</p>
<p>$$\begin{pmatrix}
a_0\\<br>
a_1
\end{pmatrix}
\$
\begin{pmatrix}
b_0\\<br>
b_1
\end{pmatrix} =
\begin{pmatrix}
a_0 \cdot b_0 + a_1 \cdot b_1\\<br>
a_0 \cdot b_1 + a_1 \cdot b_0
\end{pmatrix}
$$</p>
<p>$$G_2a =
\begin{pmatrix}
a_0 + a_1\\<br>
a_0 - a_1
\end{pmatrix}
$$</p>
<p>$$G_2b =
\begin{pmatrix}
b_0 + b_1\\<br>
b_0 - b_1
\end{pmatrix}
$$</p>
<p>$$(G_2a) \cdot (G_2b) =
\begin{pmatrix}
(a_0 + a_1) \cdot (b_0 + b_1)\\<br>
(a_0 - a_1) \cdot (b_0 - b_1)
\end{pmatrix}
= G (a \$ b)$$</p>
<p>Для бóльших размерностей все доказывается по индукции.
Таким образом можно было бы изначально искать матрицу $G$,
предположив, что $G_2 =
\begin{pmatrix}
c_0 &amp; c_1 \\<br>
c_2 &amp; c_3
\end{pmatrix}
$, решить систему уравнений.</p>
<h2 id="and-свертка">and-свертка</h2>
<p>and-свертка делается аналогично, надо только поменять матрицу.
$T_1 = \begin{pmatrix}
1\\<br>
\end{pmatrix}
$,
$
T_{2^k} =  \begin{pmatrix}
T_{2^{k - 1}} &amp; T_{2^{k - 1}}\\<br>
0 &amp; T_{2^{k - 1}}
\end{pmatrix}
$.</p>
<p>К сожалению, в отличие от xor-свертки, здесь обратная матрица не совпадает с прямой,
но зато нет корней из двойки, поэтому не придется в конце делить на $n$.</p>
<p>Обратные матрицы:
$T_1^{-1} = \begin{pmatrix}
1\\<br>
\end{pmatrix}
$,
$
T_{2^k}^{-1} =  \begin{pmatrix}
T_{2^{k - 1}}^{-1} &amp; -T_{2^{k - 1}}^{-1}\\<br>
0 &amp; T_{2^{k - 1}}^{-1}
\end{pmatrix}
$.</p>
<p>Из-за рекуррентного задания матриц, мы опять же легко можем написать алгоритм:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">andFold</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">andFold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="n">andFold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">l</span><span class="p">)];</span>
    <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">revAndFold</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">revAndFold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="n">revAndFold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">l</span><span class="p">)];</span>
    <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">andmult</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">andFold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">andFold</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">revAndFold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Проверка правильности выбранной матрицы и ее обратной остается читателю в качестве упражнения.</p>
<h2 id="or-свертка">or-свертка</h2>
<p>Все аналогично.</p>
<p>$Q_1 = \begin{pmatrix}
1\\<br>
\end{pmatrix}
$,
$
Q_{2^k} =  \begin{pmatrix}
Q_{2^{k - 1}} &amp; 0\\<br>
Q_{2^{K - 1}} &amp; Q_{2^{k - 1}}
\end{pmatrix}
$.</p>
<p>Обратные матрицы:</p>
<p>$Q_1^{-1} = \begin{pmatrix}
1\\<br>
\end{pmatrix}
$,
$
Q_{2^k}^{-1} =  \begin{pmatrix}
Q_{2^{k - 1}}^{-1} &amp; 0\\<br>
-Q_{2^{K - 1}}^{-1} &amp; Q_{2^{k - 1}}^{-1}
\end{pmatrix}
$.</p>
<p>Из-за рекуррентного задания матриц, мы опять же легко можем написать алгоритм:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">orFold</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">orFold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="n">orFold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">l</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">revOrFold</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">revOrFold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="n">revOrFold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">l</span><span class="p">)]</span> <span class="o">-=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ormult</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">orFold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">orFold</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">revOrFold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><p>Проверка правильности выбранной матрицы и ее обратной остается читателю в качестве упражнения.</p>
<p><strong>Замечание:</strong>
Заметим, что $a | b = \overline{\overline{a} \&amp; \overline{b}}$, где $\overline{x}$ — замена всех единичных битов числа
на нулевые, а нулевых на единичные. Поэтому or-свертку можно написать через $and$-свертку (и наоборот).</p>
<h2 id="оптимизации">Оптимизации</h2>
<p>Убрать рекурсию здесь проще, чем в FFT. Рекурсия головная, поэтому раскрывается очевидным образом.
Также прямые и обратные отображения очень похожи, так что их можно объединить в одну функцию.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">hadamard</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">len</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">],</span> <span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">;</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">andFold</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">inv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">len</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">inv</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">orFold</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">inv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">len</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">inv</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="альтернативный-взгляд-на-and-or-свертки">Альтернативный взгляд на and-or-свертки</h2>
<p>Представленные выше алгебраические рассуждения на самом деле необходимы только для xor-свертки. Для and- и or-сверток можно обойтись без этого. Давайте докажем иначе, что or-свертка будет выглядеть так.</p>
<p>Для and-свертки это будет аналогично из-за замечания выше об их эквивалентности, так как операции and и or отличаются заменой нулей на единицы, а единиц на нули.</p>
<p>Для альтернативного доказательства работы алгоритма or-свертки давайте введем понятие массива сумм по подмножествам (эта техника также известна как SOS-DP (sum over subsets)).</p>
<p><strong>Определение:</strong>
Пусть дан массив $A$. Давайте назовем массивом сумм по подмножествам массива $A$ такой массив $B$, что</p>
<p>$$ B_i = \sum_{j : j \subset i} A_j$$</p>
<p>При этом условие $j \subset i$ в данном случае воспринимается как содержание подмножеств единичных битов. То есть если бы мы воспринимали числа как маски. На языке битовых операций это условие можно записать как <code>i | j = i</code>, то есть $j$ — это число $i$, в котором занулили некоторые единичные биты.</p>
<p>Это называется массивом сумм по подмножествам именно потому, что если все индексы лежат в промежутке $[0, 2^k)$, то их стоит воспринимать как маски подмножеств множества ${, 0, 1, 2, \ldots, k - 1 ,}$.</p>
<p>Давайте покажем, что or-свертка как раз таки насчитывает массив сумм по подмножествам.</p>
<p>Давайте считать динамику по битам. <code>dp[mask][ind]</code> — это сумма по тем подмножествам маски $mask$, в которых изменялись только первые $ind$ битов. Если $ind = 0$, то мы не меняли никаких битов, и это просто $A_{mask}$. Далее при переходе от $ind - 1$ к $ind$ нужно, возможно, поменять текущий бит, либо не менять его. То есть если бит $ind$ в $mask$ равен нулю, то мы ничего поменять не можем:</p>
<p><code>dp[mask][ind] = dp[mask][ind - 1]</code></p>
<p>А если он равен единице, то мы его можем занулить:</p>
<p><code>dp[mask][ind] = dp[mask][ind - 1] + dp[mask ^ (1 &lt;&lt; ind)][ind - 1]</code></p>
<p>Теперь если мы уберем вторую координату динамики и будем насчитывать ее in-place, то как раз таки получим or-свертку. Алгоритм перебирает бит, после чего рассматривает все пары чисел с битом и без и прибавляет меньшее к большему. Соответственно, обратная or-свертка — это обратное преобразование: по массиву сумм по подмножествам получаем изначальный массив.</p>
<p>Тогда остается заметить, что с точки зрения массивов сумм по подмножествам or-свертка — это просто поэлементное умножение, потому что если <code>or</code> двух масок — это подмаска $mask$, то это равносильно просто тому, что обе эти маски — это подмаски $mask$.
Что и требовалось доказать.</p>
<p>Из такого объяснения вытекает немного другой способ написания той же or-свертки, который может показаться вам более простым:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">orFold</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">inv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">len</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">inv</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="n">len</span><span class="p">]</span> <span class="o">-=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="n">len</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="задачи-для-практики">Задачи для практики</h2>
<ul>
<li>
<p><a href="https://csacademy.com/contest/archive/task/random_nim_generator/">https://csacademy.com/contest/archive/task/random_nim_generator/</a></p>
</li>
<li>
<p><a href="https://csacademy.com/contest/archive/task/and-closure/">https://csacademy.com/contest/archive/task/and-closure/</a></p>
</li>
<li>
<p><a href="https://csacademy.com/contest/archive/task/token-grid/">https://csacademy.com/contest/archive/task/token-grid/</a></p>
</li>
<li>
<p><a href="https://www.codechef.com/NOV19A/problems/MDSWIN">https://www.codechef.com/NOV19A/problems/MDSWIN</a></p>
</li>
</ul>

      </div>
      
    </main>
    <footer id="footer">
  <div>
    <span>© 2021</span> - <span>2021</span>
  </div>

  <div>
    <span>Powered by </span>
    <a class="link" href="https://gohugo.io/">Hugo</a>
    <span> 🍦 Theme </span>
    <a class="link" href="https://github.com/queensferryme/hugo-theme-texify">TeXify</a>
  </div>

  <div class="footnote">
    <span></span>
  </div>
</footer>

  </div>
  





</body>

</html>
