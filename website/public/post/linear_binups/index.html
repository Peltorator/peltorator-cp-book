<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">


<meta name="author" content="peltorator">



<meta name="description" content="Часто в задачах на деревья используются двоичные подъемы. Они помогают искать LCA (наименьшего общего предка), какую-то функцию на пути и так далее. Однако они занимают $O(n \log n)$ памяти. В этой главе мы рассмотрим альтернативную структуру со схожей функциональностью, занимающую линейную память.
Идея В двоичных подъемах мы для каждой вершины храним предков на $1$, $2$, $4$, $\ldots$, $2^k$ вверх. Чтобы сделать структуру линейной, мы будем хранить только двух предков: непосредственного отца parent) и еще какого-то одного предка (jump).">



<link rel="icon" href="/favicon.ico">



<meta name="keywords" content=" hugo  latex  theme ">




<script>
  
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true,
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    }
  };
</script>

<script async defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>



<script src="https://tikzjax.com/v1/tikzjax.js"></script>
<script src="https://tikzwolke.com/v1/tikzwolke.js"></script>


<link rel="canonical" href="https://peltorator.ru/try_web/post/linear_binups/">




<title>Двоичные подъемы с линейной памятью - peltorator</title>



<link media="screen" rel="stylesheet" href='https://peltorator.ru/try_web/css/common.css'>
<link media="screen" rel="stylesheet" href='https://peltorator.ru/try_web/css/content.css'>
<link media="screen" rel="stylesheet" href='https://peltorator.ru/try_web/css/highlight.css'>


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Двоичные подъемы с линейной памятью" />
<meta name="twitter:description" content="Часто в задачах на деревья используются двоичные подъемы. Они помогают искать LCA (наименьшего общего предка), какую-то функцию на пути и так далее. Однако они занимают $O(n \log n)$ памяти. В этой главе мы рассмотрим альтернативную структуру со схожей функциональностью, занимающую линейную память.
Идея В двоичных подъемах мы для каждой вершины храним предков на $1$, $2$, $4$, $\ldots$, $2^k$ вверх. Чтобы сделать структуру линейной, мы будем хранить только двух предков: непосредственного отца parent) и еще какого-то одного предка (jump)." />


  <link rel="stylesheet" href='https://peltorator.ru/try_web/css/single.css'>
</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="https://peltorator.ru/try_web/">peltorator</a>
  </h1>

  <nav>
    
  </nav>
</header>

    <main id="main" class="post">
      
      
      
      <h1>Двоичные подъемы с линейной памятью</h1>
      
      <div class="content">
        
        <p>Часто в задачах на деревья используются <a href="https://e-maxx.ru/algo/lca_simpler">двоичные подъемы</a>. Они помогают искать LCA (наименьшего общего предка), какую-то функцию на пути и так далее. Однако они занимают $O(n \log n)$ памяти. В этой главе мы рассмотрим альтернативную структуру со схожей функциональностью, занимающую линейную память.</p>
<h2 id="идея">Идея</h2>
<p>В двоичных подъемах мы для каждой вершины храним предков на $1$, $2$, $4$, $\ldots$, $2^k$ вверх. Чтобы сделать структуру линейной, мы будем хранить только двух предков: непосредственного отца <code>parent</code>) и еще какого-то одного предка (<code>jump</code>). И тогда если мы для каждой вершины еще сохраним ее глубину (<code>depth</code>), то мы сможем легко отвечать на запросы. К примеру, если нам надо найти предка текущей вершины на какой-то глубине, то каждый раз, когда мы стоим в вершине, мы будем сначала смотреть на более длинный прыжок, если он не выше нужной нам вершины, будем совершать этот прыжок, а если же он все таки выше, то просто переходить в отца. Таким способом мы гарантировано придем в нужную вершину, осталось только построить такие прыжки, чтобы этот путь занимал всегда логарифмическое количество шагов.</p>
<p>При этом структура будет динамическая, так же как и обычные двоичные подъемы. То есть мы можем добавлять вершины в дерево по очереди, и старые прыжки не будут пересчитываться.</p>
<p>Остается лишь придумать, как построить прыжки. Давайте сделаем это следующим образом: если прыжок из нашего отца (<code>par</code>) имеет такую же длину, как и прыжок из прыжка нашего отца (<code>jump[par]</code>), то мы проведем ребро в прыжок прыжка нашего отца (<code>jump[jump[par]]</code>), а иначе проведем ребро просто в нашего отца. Если вы запутались, то рекомендую осознать код:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">addLeaf</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">par</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">par</span><span class="p">;</span>
    <span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">depth</span><span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="o">-</span> <span class="n">depth</span><span class="p">[</span><span class="n">jump</span><span class="p">[</span><span class="n">par</span><span class="p">]]</span> <span class="o">==</span> <span class="n">depth</span><span class="p">[</span><span class="n">jump</span><span class="p">[</span><span class="n">par</span><span class="p">]]</span> <span class="o">-</span> <span class="n">depth</span><span class="p">[</span><span class="n">jump</span><span class="p">[</span><span class="n">jump</span><span class="p">[</span><span class="n">par</span><span class="p">]]])</span> <span class="p">{</span>
        <span class="n">jump</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">jump</span><span class="p">[</span><span class="n">jump</span><span class="p">[</span><span class="n">par</span><span class="p">]];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">jump</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">par</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="доказательство">Доказательство</h2>
<p>Почему же с такими прыжками нам придется совершить лишь логарифмическое количество переходов? Для понимания полезно нарисовать картинку. Заметим, что на длину прыжка из вершины $v$ (а также длины прыжков из всех ее предков) влияет только ее глубина, но не структура дерева. Поэтому можно рассмотреть лишь ситуацию, в которой наше дерево является бамбуком. Давайте заметим, что длина любого прыжка равна степени двойки (если считать длину не по количеству ребер, а по количеству вершин). Действительно, для прыжка в отца длина равна $2$, а любой новый прыжок — это либо прыжок в отца, либо комбинация двух одинаковых прыжков. Тогда если те прыжки имели длину, равную степени двойки, то и комбинация тоже.</p>
<p>Однако в отличие от обычных двоичных подъемов, в которых мы постепенно уменьшали длину прыжка, здесь все немного сложнее. Сначала длина прыжка постепенно увеличивается, а потом постепенно уменьшается. Это чем-то похоже на путешествие между городами. Сначала мы едем по маленьким улочкам, постепенно выезжая на более широкие проспекты, в конце концов выезжаем на шоссе, а в конце пути происходит симметричная ситуация: мы съезжаем с магистралей на проспекты, а с проспектов на узкие улочки.</p>
<p>Давайте разделим наш путь на две части: сначала длины прыжков постепенно возрастают, и мы всегда используем прыжок, потом в какой-то момент прыжок ведет в слишком высокую вершину, поэтому нам приходится использовать переход в отца, после чего мы будем иногда использовать переходы в отцов, а иногда прыжки, но длины прыжков будут не возрастать.</p>
<p>Докажем несколько утверждений.</p>
<p><strong>Теорема:</strong> Прыжки не пересекаются (но один может лежать строго внутри другого).</p>
<p><strong>Доказательство:</strong></p>
<p>Докажем это утверждение по индукции. Пусть это утверждение верно для всех предков текущей вершины, докажем для прыжка из текущей вершины.
Если прыжок ведет в отца, то такой прыжок, очевидно, не может ни с кем пересекаться. Если же прыжок ведет не в отца, то он является комбинацией двух прыжков. Если какой-то прыжок пересекается с новым прыжком, то он пересекается и с одним из двух меньших прыжков. Но для них мы уже доказали по предположению индукции, что они попарно не пересекаются.</p>
<p><strong>Теорема:</strong> Не может быть больше двух одинаковых прыжков подряд, то есть не может быть так, что длины прыжков из <code>v</code>, <code>jump[v]</code> и <code>jump[jump[v]]</code> совпадают.</p>
<p><strong>Доказательство:</strong>
Действительно, если бы они все совпадали, то прыжок из сына <code>jump[v]</code> вел бы в <code>jump[jump[v]]</code>, потому что прыжки его предков равны по длине. А тогда этот прыжок бы пересекался с прыжком из $v$, что невозможно по предыдущей теореме.</p>
<p>Крайним случаем будет ситуация, когда длины всех трех прыжков равны единице, однако в этой ситуации из <code>v</code> прыжок должен вести в <code>jump[jump[v]]</code>, а не в <code>jump[v]</code>, что противоречит условию.</p>
<p><strong>Теорема:</strong> Длина прыжка из <code>v</code> не больше длины прыжка из <code>jump[v]</code> в том случае, если <code>jump[v]</code> — это не корень. То есть если мы переходим по прыжкам, то их длины не убывают.</p>
<p><strong>Доказательство:</strong>
Действительно, если наш прыжок ведет в корень, то оттуда уже некуда прыгать. А иначе прыжок будет иметь не меньшую длину.</p>
<p>Докажем это утверждение по индукции. Пусть это утверждение верно для всех предков текущей вершины, докажем для прыжка из текущей вершины.
Если этот прыжок ведет в отца, то это самый маленький возможный прыжок, и следующий точно не меньше.
Если же прыжок ведет не в отца, то он был получен из двух меньших прыжков длины в два раза меньше, Тогда так как для всех предков утверждение уже верно, то прыжок из нашего прыжка точно не может быть короче нашего прыжка более, чем в два раза. Однако если он короче ровно в два раза, то мы получаем три последовательных прыжка одинаковой длины, чего не бывает по предыдущей теореме. Поэтому прыжок из нашего прыжка имеет длину не меньше, чем текущий прыжок.</p>
<p>Из этих утверждений легко понять, что первая фаза путешествия, в которой мы всегда переходим по прыжкам, работает за логарифмическое время. Действительно, длина прыжка не убывает, но при этом она не может оставаться фиксированной более, чем два раза, поэтому через $2 \log n$ итераций длина прыжка станет не меньше $n$, и в этот момент прыжок уже точно будет выше, чем необходимая нам вершина.</p>
<p>На второй же фазе путешествия мы пытаемся получить точную вершину, в которую нам нужно прийти. нам не подходит прыжок длины $2^k$, то есть наша вершина находится между текущей вершиной и прыжком из нее. Тогда мы переходим в нашего отца, в результате чего отрезок, на котором мы ищем, поделился на два. И если нужная вершина находится в верхней половине, то мы сделаем прыжок из нашего отца, а если в нижней, то не сделаем. В любом случае, через каждые два шага длина прыжка из текущей вершины будет уменьшаться в два раза, и таким бинпоиском мы постепенно придем в нужную вершину.</p>
<h2 id="поиск-предка-на-глубине-h">Поиск предка на глубине $h$</h2>
<p>Доказательство не совсем очевидно, однако его не нужно помнить, чтобы применять эту структуру данных. Давайте рассмотрим пример ее работы для задачи LA (level ancestor), то есть поиска предка текущей вершины на глубине $h$. Для этого мы постепенно идем наверх, пытаясь пойти в прыжок текущей вершины, если его глубина не меньше $h$, а в противном случае идем в отца.</p>
<p>С реализацией можно ознакомиться по <a href="https://pastebin.com/tyrL8gMQ">ссылке</a>.</p>
<p>Асимптотика ответа на $q$ запросов на дереве из $n$ вершин будет $O(n + q \log n)$.</p>
<h2 id="поиск-наименьшего-общего-предка">Поиск наименьшего общего предка</h2>
<p>Теперь рассмотрим другую задачу, для решения которой обычно используют бинарные подъемы: LCA (least common ancestor или наименьший общий предок). Воспользуемся следующей идеей: сначала из более глубокой вершины перейдем на глубину менее глубокой при помощи LA, а затем будем параллельно подниматься наверх из двух вершин. Обратите внимание на то, что если две вершины находятся на одной и той же глубине, то длины их прыжков совпадают, поэтому мы можем переходить по прыжку в том случае, если концы этих прыжков не равны, а в противном случае переходить в отца.</p>
<p>С реализацией можно ознакомиться по <a href="https://pastebin.com/shHVMMBQ">ссылке</a>.</p>
<p>Асимптотика ответа на $q$ запросов на дереве из $n$ вершин будет $O(n + q \log n)$.</p>
<p>Также аналогично двоичным подъемам можно хранить значение какой-то функции на прыжке и при помощи этого искать значение функции на пути в дереве.</p>
<h2 id="задачи-для-практики">Задачи для практики</h2>
<p>Для практики подойдут любые задачи на двоичные подъемы и LCA.</p>
<ul>
<li>
<p><a href="https://www.hackerrank.com/challenges/kth-ancestor/problem">Задача</a> на поиск $k$-го предка в дереве.</p>
</li>
<li>
<p><a href="https://www.spoj.com/problems/LCA/">Задача</a> на поиск наименьшего общего предка.</p>
</li>
<li>
<p><a href="https://codeforces.com/contest/609/problem/E">Задача</a>, в которой нужно еще некоторые знания о минимальных остовных деревьях.</p>
</li>
</ul>

        
      </div>
      <div class="paginator">
        
        <a class="link" href="https://peltorator.ru/try_web/post/rmq_offline_tarjan_variation/">← prev</a>
        
        
        <a class="link" href="https://peltorator.ru/try_web/post/persistent_cht/">next →</a>
        
      </div>
      <div class="comment">
        
        
        
        
      </div>
      
    </main>
    <footer id="footer">
  <div>
    <span>© 2021</span> - <span>2021</span>
  </div>

  <div>
    <span>Powered by </span>
    <a class="link" href="https://gohugo.io/">Hugo</a>
    <span> 🍦 Theme </span>
    <a class="link" href="https://github.com/queensferryme/hugo-theme-texify">TeXify</a>
  </div>

  <div class="footnote">
    <span></span>
  </div>
</footer>

  </div>
  





</body>

</html>
