<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">


<meta name="author" content="peltorator">



<meta name="description" content="Часто бывает так, что ваши решения задач зависят от случайных чисел. Стандартным примером будет являться декартово дерево, в котором логарифмическая высота достигается в том случае, если потенциалы будут выбраны случайно. Когда ваша программа использует случайные числа, нужно быть внимательным, чтобы не попасть в какую-нибудь ловушку. В этом разделе мы как раз поговорим про то, какие бывают ловушки, как в них не попасться, а также как упростить себе жизнь. В основном речь будет идти про C&#43;&#43;, однако некоторые вещи можно по аналогии перенести в другие языки.">



<link rel="icon" href="/favicon.ico">



<meta name="keywords" content=" hugo  latex  theme ">




<script>
  
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true,
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    }
  };
</script>

<script async defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>



<link rel="stylesheet" type="text/css" href="http://tikzjax.com/v1/fonts.css">
<script src="https://tikzjax.com/v1/tikzjax.js"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<link rel="canonical" href="https://peltorator.ru/posts/random/">




<title>Генерация случайных чисел - peltorator</title>



<link media="screen" rel="stylesheet" href='https://peltorator.ru/css/common.css'>
<link media="screen" rel="stylesheet" href='https://peltorator.ru/css/content.css'>
<link media="screen" rel="stylesheet" href='https://peltorator.ru/css/highlight.css'>


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Генерация случайных чисел" />
<meta name="twitter:description" content="Часто бывает так, что ваши решения задач зависят от случайных чисел. Стандартным примером будет являться декартово дерево, в котором логарифмическая высота достигается в том случае, если потенциалы будут выбраны случайно. Когда ваша программа использует случайные числа, нужно быть внимательным, чтобы не попасть в какую-нибудь ловушку. В этом разделе мы как раз поговорим про то, какие бывают ловушки, как в них не попасться, а также как упростить себе жизнь. В основном речь будет идти про C&#43;&#43;, однако некоторые вещи можно по аналогии перенести в другие языки." />


  <link rel="stylesheet" href='https://peltorator.ru/css/single.css'>
</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="https://peltorator.ru/">peltorator</a>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      <a class="link" href="/">Статьи</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/about/">Полезные ссылки</a>
    </span>
    
  </nav>
</header>

    <main id="main" class="post">
      
      
      <div class="content">
        <p>Часто бывает так, что ваши решения задач зависят от случайных чисел. Стандартным примером будет являться декартово дерево, в котором логарифмическая высота достигается в том случае, если потенциалы будут выбраны случайно. Когда ваша программа использует случайные числа, нужно быть внимательным, чтобы не попасть в какую-нибудь ловушку. В этом разделе мы как раз поговорим про то, какие бывают ловушки, как в них не попасться, а также как упростить себе жизнь. В основном речь будет идти про C++, однако некоторые вещи можно по аналогии перенести в другие языки.</p>
<h2 id="mt19937">mt19937</h2>
<p>Первое, что нужно сделать, когда вы работаете со случайными числами, — это забыть про функцию <code>rand</code>. Не стоит использовать ее ни-ко-гда! И на это есть три причины.</p>
<p>Первая причина заключается в том, что случайные числа, которые генерирует <code>rand</code>, — это &laquo;плохие&raquo; случайные числа. Дело в том, что компьютер не может сгенерировать по настоящему случайные числа. Поэтому вместо этого он генерирует &laquo;псевдослучайные&raquo; числа. Существуют разные способы генерации псевдослучайных чисел, и способ, который используется в <code>rand</code> далеко не самый лучший. В них легко можно вычленить периодичности и т.п.</p>
<p>Вторая причина более обозрима. Она заключается в том, что эта функция платформозависима. По стандарту она генерирует случайное число от нуля до <code>RAND_MAX</code>. Проблема заключается в том, что в linux это число <code>RAND_MAX</code> совпадает с максимальным числом, которое может храниться в типе <code>int</code> ($2^{31} - 1$), и все хорошо. Однако в windows <code>RAND_MAX</code> равен $32767$ ($2^{15} - 1$), а это на самом деле очень маленькое число. Если вы не знаете этого и хотите генерировать много случайных чисел, они будут очень часто повторяться в таком случае. Другая проблема встает тогда, когда вам нужно генерировать действительно большие числа. В этом случае с функцией <code>rand</code> придется изворачиваться и использовать конструкции типа <code>RAND_MAX * rand() + rand()</code>.</p>
<p>И самое ужасное произойдет в тот момент, когда вы захотите использовать функцию <code>random_shuffle</code>, которая случайным образом перемешивает элементы массива. Для ее работы нужна генерация случайных индексов массива, то есть случайных чисел от $0$ до $n - 1$, однако число $n$ вполне вероятно может быть сильно больше, чем $32767$. В таком случае сгенерированная перестановка абсолютно не является случайной. К примеру, если $n = 3 \cdot 10^6$, тесты показывают, что каждый элемент находится в среднем на расстоянии $2 % n$ позиций от своего изначального места, хотя с теоретической точки зрения это должно быть $33 %$.</p>
<p>Третья причина заключается в том, что генератор случайных чисел, который мы рассмотрим далее работает просто быстрее, чем <code>rand</code>. Подробнее мы поговорим про это позже.</p>
<p>Для решения всех этих проблем подойдет генератор случайных чисел <code>mt19937</code>, добавленный в C++11. Он вне зависимости от компилятора генерирует случайные числа от $0$ до $2^{32} - 1$ (обратите внимание, что здесь генерируется случайное <code>unsigned int</code> число). Этот генератор основан на простом числе Мерсена $2^{19937} - 1$ (его название — это как раз сокращение от его параметров: &laquo;Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits&raquo;). Такой генератор намного более &laquo;рандомный&raquo; и его период — это как раз $2^{19937} - 1$, что является невероятно большим числом (примерно $10^{6000}$). Давайте рассмотрим пример работы этого генератора:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">mt19937</span> <span class="nf">rnd</span><span class="p">(</span><span class="mi">4321</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rnd</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">rnd</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div><p>Данный код создает генератор под названием <code>rnd</code> с начальным сидом $4321$. После этого генератор можно использовать как функцию. Данный код выведет на экран два случайных числа от $0$ до $2^{32} - 1$. Стоит обращать внимание на то, что если присвоить значение <code>rnd()</code> переменной типа <code>int</code>, то значение может быть отрицательным. Однако если вы сразу знаете, что вам нужно число из какого-то диапазона, то взяв значение по модулю вы избежите отрицательных чисел:</p>
<p><code>rnd() % 1000</code></p>
<p>Кроме того, этот генератор можно использовать при перемешивании элементов массива. Для этого нужно воспользоваться функцией <code>std::shuffle</code>, аналогичной <code>random_shuffle</code>. Она принимает начало и конец последовательности, а также генератор. К примеру:</p>
<p><code>shuffle(a.begin(), a.end(), rnd);</code></p>
<p>Также стоит обратить внимание на то, что мы не только выигрываем в качестве генератора и величине генерируемых чисел, но и во времени. Генерация числа при помощи <code>rnd</code> в $3$ раза быстрее генерации при помощи <code>rand</code>.</p>
<p>Если вам нужно генерировать еще бóльшие числа, у <code>mt19937</code> есть старший брат <code>mt19937_64</code>, который генерирует уже  $64$-битные случайные числа.</p>
<p>Стоит не забывать и о платформенной независимости. <code>mt19937</code> не только генерирует большие случайные числа на любой платформе, он кроме того генерирует одни и те же числа (при фиксированном сиде) на любой платформе. Так что вы можете быть уверены, что когда вы засылаете ваше решение в систему, оно будет там работать точно так же, как и на вашем компьютере.</p>
<p>Еще одним плюсом может быть то, что вы можете создавать несколько разных <code>mt19937</code> генераторов в одной программе (с одним и тем же сидом, либо с разными) и использовать их независимо. Как это можно использовать, каждый решит для себя сам. К примеру, если вы делаете in-code стресс, вы можете не передавать решениям входные данные, сгенерированные случайно, а генерировать их прямо по ходу решения, и если вы используете один и тот же сид, но разные генераторы в двух решениях, они будут генерировать одни и те же числа.</p>
<h2 id="uniform_int_distrubition">uniform_int_distrubition</h2>
<p>В C++ помимо <code>mt19937</code> есть большое количество удобных вспомогательных инструментов для работы со случайными числами.</p>
<p>Первый пример, который мы рассмотрим, — это <code>uniform_int_distribution</code>. Это инструмент, позволяющий генерировать случайное целое число в заданном диапазоне. Легче всего понять его принцип работы на примере:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">mt19937</span> <span class="nf">rnd</span><span class="p">(</span><span class="mi">4321</span><span class="p">);</span>
<span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">distrib</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">distrib</span><span class="p">(</span><span class="n">rnd</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div><p>Мы создаем объект класса <code>uniform_int_distribution</code>. В шаблон мы передаем, какого типа должны возвращаться числа, в данном случае это <code>int</code> (его можно опускать, потому что компилятор сам догадается о типе из типа левой и правой границы). Затем в конструктор передается два числа — левая и правая граница отрезка, в котором будут генерироваться числа. После чего для того, чтобы сгенерировать случайное число, нужно передать в <code>uniform_int_distribution</code> наш генератор случайных чисел. В данном случае это <code>mt19937</code>, который мы заранее определили. Такой код выведет случайное целое число от $1$ до $10$ включительно.</p>
<p>Стандартным способом сгенерировать число в полуинтервале от $l$ до $r$ был бы следующий код:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">uniform_distribution</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">rnd</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">l</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>В случае, если нужно сгенерировать случайное число от $0$ до $r$, код можно упростить, просто взяв значение <code>rnd()</code> по модулю $r$. <code>uniform_int_distribution</code> не только упрощает этот процесс, но и спасает вам от неожиданных проблем.</p>
<p>Обратите внимание, что если <code>rnd</code> генерирует случайное число от $0$ до $C$, то <code>rnd() % r</code> — это случайное число от $0$ до $r$ только в том случае, если $C$ делится на $r$. В противном случае остатки $0$, $1$, $\ldots$, $\left(C - 1\right) \bmod r$ будут генерироваться немного чаще, чем все остальные. Вы вряд ли как-то это сможете заметить, если $r$ — это, к примеру, $3$, однако для больших $r$ это может привести к неприятным последствиям. Пускай $r = \left\lfloor \frac{2 \cdot C}{3} \right\rfloor$. Тогда для остатков от $0$ до $\frac{r}{2}$ есть два возможных числа с такими остатками, а для остатков, больших $\frac{r}{2}$, таких чисел по одной штуке. Это значит, что маленькие остатки будут генерироваться в среднем в два раза чаще, чем большие. <code>uniform_int_distribution</code> как раз таки помогает решить эту проблему.</p>
<p>Момент, который стоит все таки отметить — это то, что в отличие от <code>mt19937</code>, <code>uniform_int_distribution</code> все таки платформозависим. То есть при фиксированном сиде <code>mt19937</code> могут выдаваться разные числа на разных компиляторах. Не то, чтобы это было очень серьезной проблемой, но стоит учитывать, что у вас на компьютере и в тестирующей системе могут генерироваться разные числа.</p>
<h2 id="как-генерировать-случайные-числа-по-модулю">Как генерировать случайные числа по модулю</h2>
<p>Сделаем небольшое отступление. Как мы поняли, если нам нужно генерировать случайное число из какого-то отрезка, нам в этом поможет <code>uniform_int_distribution</code>. Однако что бы мы делали, если бы у нас его не было? Пришлось бы использовать плохой генератор, который генерирует числа неравномерно? Давайте приведем рандомизированный алгоритм, который за ожидаемое время $O(1)$ вернет нам случайный равномерно распределенный остаток по модулю $r$.</p>
<p>Как мы уже поняли, если $2^{32}$ делится на $r$, то все хорошо. Мы должны просто взять остаток от деления <code>rnd()</code> на $r$. Однако если $r$ не является степенью двойки, распределение такого остатка будет неравномерным. Давайте избавимся от этих последних остатков, которые мешают равномерности. То есть возьмем число $X$, равное $2^{32} - (2^{32} \bmod r)$. Такое число будет делиться на $r$, но при этом будет не меньше $2^{31}$ (если $r \ge 2^{31}$, то такое число не меньше $r$, которое не меньше $2^{31}$, а если $r &lt; 2^{31}$, то мы вычтем что-то меньшее $2^{31}$, поэтому получим число, которое не меньше $2^{31}$). Тогда давайте сделаем так: если случайно сгенерированное число $q$ меньше $X$, то вернем $q \bmod r$, что будет равномерно распределенным случайным остатком, а если $q$ не меньше $X$, то повторим генерацию заново. Так как $X$ не меньше $\frac{2^{32}}{2}$, то вероятность успеха каждый раз не меньше $\frac{1}{2}$, поэтому нам в среднем понадобится сгенерировать не больше двух случайных чисел.</p>
<h2 id="другие-распределения">Другие распределения</h2>
<p>По аналогии с <code>uniform_int_distribution</code> в C++ есть много других распределений. К примеру, <code>normal_distribution</code> и <code>exponential_distribution</code>, которые соответствуют нормальному и экспоненциальному распределениям. Маловероятно, что это может понадобиться вам при решении задач, но все же.</p>
<p>А вот что действительно может понадобиться вам, так это генерировать случайное вещественное число. Для этого подойдет <code>uniform_real_distribution</code>. Его использование аналогично <code>uniform_int_distribution</code>, но только теперь генерируется не случайное целое число из отрезка, а случайное вещественное.</p>
<h2 id="выбор-сида-рандома">Выбор сида рандома</h2>
<p>Важным вопросом является выбор сида рандома. Формально есть всего два варианта выбора сида: детерминированный (фиксированное число) и случайный. Давайте поймем, какой вариант нужно использовать в какой ситуации.</p>
<p>Чаще всего (частота употребления — это, конечно, индивидуальная вещь, но все же) вы хотите использовать константный сид рандома (мы ранее использовали всегда число $4321$, но это может быть ваше любимое число). Какие у этого плюсы? В таком случае ваши случайные числа весьма условно случайны. На самом деле они вполне детерминированы. Каждый раз, когда вы запускаете программу, вам выдаются одни и те же числа. Чем же это хорошо? Тем, что вы контролируете ситуацию.</p>
<p>Если ваша программа не работает, и вы пытаетесь найти ошибку, вы знаете, что при каждом запуске программе даются одни и те же случайные числа, и вы не столкнетесь с тем, что один раз ошибка была, потом пропала, а воспроизвести ее не получается.</p>
<p>Другой плюс — это уверенность в результате. Вы знаете, что когда вы зашлете решение в систему, оно будет работать там на тестах точно так же, как и на вашем компьютере. Кроме того, если вы получили по задаче AC, то вы уверены, что сколько бы раз не происходило перетестирование, ваше решение все равно будет проходить тесты.</p>
<p>Если же вы используете случайный сид, то при каждом запуске числа, которые выдает ваш случайный генератор, меняются. В результате чего может сложиться такая ситуация, что после окончания контеста все решения будут перетестированы, и вам не повезет со случайными числами, в результате чего ваше решение не пройдет тесты.</p>
<p>В каком же случае все таки нужно использовать случайный сид (про то, как сгенерировать случайный сид, мы поговорим позже)? Во-первых, в любых контестах со взломами (codeforces, topcoder и т.п.). Если в таких соревнованиях ваш сид не случайный, то человек, который смотрит на ваш код, может запустить у себя локально ваше решение, посмотреть, какие случайные числа оно генерирует, и без труда построить контртест, тем самым вся ваша случайность будет абсолютно бесполезна.</p>
<p>Во-вторых, это может понадобиться вам, когда вы хотите запустить ваше решение несколько раз и проверить, что от изменения сида вывод не меняется. Это можно сделать, меняя каждый раз сид руками в коде, но после этого каждый раз придется перекомпилировать программу. Случайный сид может быть хорошим решением этой проблемы.</p>
<p>В-третьих, если вы пишете <a href="/try_web/post/stress/">стресс тесты</a>. Есть два подхода в этом плане. Первый — передавать сид как аргумент командной строки, либо выбирать его случайно. Если вы все таки решили выбрать сид случайно, то вам очень важно &laquo;качество&raquo; этого случайного сида. Об этом мы как раз и поговорим далее.</p>
<p>Случайным сидом обычно выбирают текущее время, потому что это некоторая меняющаяся величина. Самый простой способ получения времени — это <code>time(0)</code>. Эта функция возвращает текущее время в секундах. Этот вариант подойдет вам, если вы хотите запустить ваше решение несколько раз и посмотреть, что оно делает при разных сидах (если вы запускаете ваше решение не чаще, чем раз в секунду). Однако эту функцию категорически не стоит использовать в двух других случаях.</p>
<p>В случае стресс тестирования вы хотите прогонять тысячи тестов в секунду, но при использовании <code>time(0)</code> ваш генератор целую секунду будет генерировать вам один и тот же тест, поэтому поиск неправильного теста замедляется в тысячи раз.</p>
<p>В случае взломов проблема не так очевидна. На самом деле человек, который вас взламывает, может подгадать, в какую секунду ваше решение будет тестироваться и подготовить тест специально для нее. Если этот вариант кажется вам невозможным, то есть и более реалистичный случай. Можно сделать тест, который является контртестом сразу к $60$ разным сидам. И если эти сиды — это последовательные секунды, то здесь для взлома остается лишь совершить его в правильную минуту, что совершенно не является проблемой.</p>
<p>Что же делать? Нужно использовать время в наносекундах (миллиардная доля секунды). Тогда подгадать сид точно уже не представляется возможным. Получить текущее время в наносекундах можно при помощи следующей строки:</p>
<p><code>chrono::steady_clock::now().time_since_epoch().count()</code></p>
<p>И это можно использовать как сид рандома:</p>
<p><code>mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());</code></p>
<p>Есть еще способ через <code>random_device</code>. Это генератор случайных чисел, который недетерминирован сам по себе:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
<span class="n">mt19937</span> <span class="nf">rnd</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
</code></pre></div><p><strong>Однако, к сожалению, это тоже платформозависимое решение</strong>. На windows <code>random_device</code> все таки детерминирован, поэтому этот способ не рекомендуется использовать.</p>

      </div>
      
    </main>
    <footer id="footer">
  <div>
    <span>© 2021</span> - <span>2021</span>
  </div>

  <div>
    <span>Powered by </span>
    <a class="link" href="https://gohugo.io/">Hugo</a>
    <span> 🍦 Theme </span>
    <a class="link" href="https://github.com/queensferryme/hugo-theme-texify">TeXify</a>
  </div>

  <div class="footnote">
    <span></span>
  </div>
</footer>

  </div>
  





</body>

</html>
