\chapter{Быстрый ввод-вывод в C++} \label{fastio}

Часто бывает так, что ввод и/или вывод в задаче очень большие. В этом случае только считывание входных данных и вывод ответа уже могут не уложиться в ограничение по времени. Чтобы этого избежать, есть различные техники, которые мы рассмотрим в этой главе.

\section{endl и \textbackslash n}

Обычно перевод строки делается при помощи \verb+cout << endl+, однако эта команда не только переводит строку, но и очищает буфер. Когда вы что-то выводите, на самом деле оно не обязано выводиться сразу. Программа сначала накопит какой-то буфер вывода, а потом выведет его целиком, потому что сама по себе операция вывода весьма долго работает. Однако если вы пишете \verb+endl+, то вы заставляете программу насильно очистить буфер. Если вы будете делать это очень часто, то программа будет работать очень долго. Чтобы решить эту проблему, можно вместо \verb+endl+ использовать \verb+cout << '\n'+. Отличие заключается как раз в том, что это просто символ перевода строки без очистки буфера. В случае, если вы в выводе часто делаете перевод строки, это может существенно ускорить вашу программу.

Однако не стоит везде всегда писать \verb+\n+ вместо \verb+endl+. В интерактивных задачах важно, чтобы после каждого вывода очищался буфер, чтобы программа, с которой вы взаимодействовала, могла сразу считать то, что вы вывели. Поэтому в интерактивных задачах обязательно использовать \verb+endl+ для очистки буфера.

Кроме того, если вы пытаетесь найти ошибку в программе и выводите отладочную информацию, вам важно, чтобы она появлялась на экране, поэтому ее тоже нужно выводить с очисткой буфера. Если вы не хотите при этом переводить строку, можете воспользоваться \verb+std::flush+.

\section{sync\_with\_stdio и cin.tie}

Также сильно ускорить программу можно, отключив синхронизацию разных потоков ввода/вывода. Можно использовать следующие две строчки:

\begin{code}
    ios::sync_with_stdio(0);
    cin.tie(0);
\end{code}

Первая строка отключает синхронизацию \verb+iostream+ и \verb+stdio+, то есть вы не можете больше одновременно использовать и \verb+cin+, и \verb+scanf+ в одной программе. Однако вряд ли вам это нужно, поэтому эту синхронизацию можно отключить, что приводит к ускорению программы.

Вторая строка отключает привязку \verb+cin+ к \verb+cout+, что помогает в случае, когда ввод и вывод чередуются. Кроме того, некоторые люди иногда используют \verb+cout.tie(0)+, но эта строка не делает ничего, потому что пытается отключить привязку \verb+cout+ к \verb+cout+, что весьма странно. Миф о том, что \verb+cout.tie+ полезен подкрепляется примерами, когда при добавлении этой строки код ускорялся, однако при повторных запусках могла наблюдаться обратная ситуация. Разное время работы связано с разными условиями запуска и фазами Венеры, но не с добавлением этой строчки.

\section{Ручной быстрый ввод-вывод}

Если даже предыдущие оптимизации не помогают, можно воспользоваться рукописным быстрым вводом. Это будет еще в несколько раз быстрее. К примеру, можно воспользоваться вот этим \href{https://pastebin.com/W5rjcUiE}{кодом} от Сергея Копелиовича. Пример использования:

\begin{code}
    int n = readInt();
    writeInt(n, ' ');
\end{code}
