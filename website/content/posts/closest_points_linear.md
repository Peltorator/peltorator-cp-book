---
title: "Поиск пары ближайших точек за $O(n)$"
date: 2021-09-14T12:41:00+03:00
draft: false
---

<center> <h2>Поиск пары ближайших точек за $O(n)$</h2> </center>
<br/>
<br/>

Решим за линейное время следующую задачу:

**Задача:**
Даны $n$ точек на плоскости. Требуется найти такую пару точек, что расстояние между ними минимально среди всех расстояний между всеми парами данных точек.


У этой задачи есть детерминированный алгоритм, основанный на идее <<разделяй и властвуй>>, работающий за $O(n \log n)$.
Мы же рассмотрим рандомизированный алгоритм, работающий за ожидаемое время $O(n)$.

Давайте будем постепенно добавлять точки по одной в случайном порядке, поддерживая пару ближайших точек. Пусть на данный момент уже было добавлено сколько-то точек, и текущее минимальное расстояние равно $d$. Побьем всю плоскость на квадраты $d \times d$ и для каждого квадрата в хеш-таблице будем хранить все точки, находящиеся в этом квадрате. При этом можно заметить, что так как на данный момент минимальное расстояние между точками равно $d$, то расстояние между любой парой точек не меньше $d$, поэтому в каждом квадрате не больше $4$ точек.

<!---
<script type="text/tikz">
\begin{tikzpicture}[line cap=round,line join=round,x=1.0cm,y=1.0cm]
\draw [line width=2.pt] (0.,3.)-- (0.,-3.);
\draw [line width=2.pt] (2.5,3.)-- (2.5,-3.);
\draw [line width=2.pt] (5.,3.)-- (5.,-3.);
\draw [line width=2.pt] (7.5,3.)-- (7.5,-3.);
\draw [line width=2.pt] (-0.5,2.5)-- (8.,2.5);
\draw [line width=2.pt] (8.,0.)-- (-0.5,0.);
\draw [line width=2.pt] (-0.5,-2.5)-- (8.,-2.5);
\begin{scriptsize}
\draw [fill=blue] (5.,0.) circle (2.5pt);
\draw [fill=blue] (5.,-2.5) circle (2.5pt);
\draw [fill=blue] (7.5,-2.5) circle (2.5pt);
\draw [fill=blue] (7.5,0.) circle (2.5pt);
\draw [fill=blue] (1.2,2.32) circle (2.5pt);
\draw [fill=blue] (0.14,0.22) circle (2.5pt);
\draw [fill=blue] (2.14,0.32) circle (2.5pt);
\draw [fill=blue] (3.82,2.24) circle (2.5pt);
\draw [fill=blue] (6.72,2.26) circle (2.5pt);
\draw [fill=blue] (2.84,-1.1) circle (2.5pt);
\draw [fill=blue] (0.22,-2.25) circle (2.5pt);
\end{scriptsize}
\end{tikzpicture}
</script>
--->

![Closest points grid](/images/closest_points_grid.svg)


Заметим, что если мы добавляем какую-то новую точку, то если минимальное расстояние изменилось, то есть какая-то точка, которая находится на расстоянии меньше $d$ от новой точки. При этом обратим внимание на то, что эта точка должна находиться либо в том же квадрате $d \times d$, либо в соседнем (по стороне или диагонали), ведь если нарисовать круг радиуса $d$ с центром в новой точке, он целиком будет лежать в квадрате $3d \times 3d$, в центральном квадрате которого лежит новая точка.

<!---
<script type="text/tikz">
\definecolor{xdxdff}{rgb}{0.49019607843137253,0.49019607843137253,1.}
\definecolor{ffzzqq}{rgb}{1.,0.6,0.}
\definecolor{ududff}{rgb}{0.30196078431372547,0.30196078431372547,1.}

\begin{tikzpicture}[line cap=round,line join=round,x=1.0cm,y=1.0cm]
%\clip(-2.3879877682440735,-6.345539414293429) rectangle (16.523412413538978,5.094307580916252);
\draw [line width=2.pt] (0.,2.5)-- (0.,-5.);
\draw [line width=2.pt] (0.,-5.)-- (7.5,-5.);
\draw [line width=2.pt] (7.5,-5.)-- (7.5,2.5);
\draw [line width=2.pt] (7.5,2.5)-- (0.,2.5);
\draw [line width=2.pt] (0.,0.)-- (7.5,0.);
\draw [line width=2.pt] (7.5,-2.5)-- (0.,-2.5);
\draw [line width=2.pt] (2.56,2.54)-- (2.5,-5.);
\draw [line width=2.pt] (5.,2.5)-- (5.,-5.);
\draw [line width=2.pt,color=ffzzqq] (3.3,-0.75) circle (2.5068905041903986cm);
\draw [line width=2.4pt] (3.3,-0.75)-- (4.166189323170816,1.602491457248012);
\begin{scriptsize}
\draw [fill=ududff] (3.3,-0.75) circle (2.5pt);
\draw [fill=xdxdff] (4.166189323170816,1.602491457248012) circle (2.5pt);
\end{scriptsize}
\end{tikzpicture}
</script>
--->

![Closest points grid](/images/closest_points_circle.svg)

Так как в каждом квадрате лежит не больше $4$ точек, нам придется перебрать не более $9 \cdot 4 = 36$ точек в поиске пары для новой точки. То есть добавление новой точки будет происходить за константное время. Однако если мы все таки нашли новую пару, то нам придется перестроить всю структуру квадратов, потому что $d$ уменьшится.

Кажется, что такой алгоритм будет работать за квадратичное время, однако вспомним, что мы добавляем точки в случайном порядке! Заметим, что если мы перестроили структуру после добавления $k$-й точки, то это одна из двух точек в паре самых близких. Так как эта точка была выбрана случайно, то вероятность такого события — $\frac{2}{k}$ (если есть несколько одинаковых минимальных расстояний, то либо до добавления этой точки расстояние уже было таким, и ничего перестраивать не надо, либо же во всех таких минимальных расстояниях одной из точек является наша новая точка, и тогда вероятность еще меньше — $\frac{1}{k}$). Если это событие произошло, то нам нужно перестроить заново структуру. Это происходит за $O(k)$. Поэтому ожидаемое время работы равно $\sum_{k = 1}^{n} \frac{2}{k} \cdot k = \sum_{k = 1}^{n} 2 = 2n = O(n)$. Что и требовалось доказать.

**Замечание:**
Если координаты точек целые, то в алгоритме можно обойтись без вещественных чисел. Вместо минимального расстояния будем хранить его квадрат, а делить на квадраты будем со стороной не $d$, а $\left\lfloor d \right\rfloor$. Очевидно, от этого асимптотика не поменяется.


**Замечание:**
Чтобы получить номер квадрата, в котором находится точка, вы скорее всего будете делить его координаты на $d$. Будьте внимательны, что если в множестве есть совпадающие точки, то $d$ может стать равно нулю. В этом случае нужно сразу завершиться, потому что более близких точек точно уже не будет.


С реализацией можно ознакомиться по [ссылке](https://pastebin.com/zwSY4tHq).

**Замечание:**
Легко обобщить этот алгоритм для бóльших размерностей. Нужно побить пространство на кубы со стороной $d$ и искать пару для новой точки во всех соседних кубах. Для фиксированной размерности алгоритм будет все еще линейным.



## Задачи для практики

- [https://codeforces.com/contest/120/problem/J](https://codeforces.com/contest/120/problem/J)

