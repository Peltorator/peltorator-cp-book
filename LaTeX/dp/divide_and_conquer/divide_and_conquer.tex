echapter{Оптимизация разделяй-и-властвуй} \label{divide-and-conquer-optimization}

Разделяй-и-властвуй (divide-and-conquer)~--- стандартная оптимизация динамики, позволяющая решать задачи об оптимальном разбиении массива из $n$ элементов на $k$ подотрезков за $O(n k \log n)$ (если эта динамика удовлетворяет некоторому условию, о котором мы поговорим позже), в то время как наивная динамика решает эту задачу за $O(n^2 k)$. Иными словами, мы оптимизируем динамику такого вида:

$$dp[ki][ni] = \min_{i < ni} dp[ki - 1][i] + w(i, ni)$$

где $dp[ki][ni]$~--- оптимальная стоимость разбить первые $ni$ элементов массива на $ki$ подотрезков оптимальным образом, а $w(i, ni)$~--- стоимость подотрезка $(i, ni]$.

Воспринимать материал на какой-то абстрактной задаче может быть тяжело, поэтому давайте сразу сформулируем конкретный пример задачи.

\section{Алгоритм}

\begin{problem}
    Дан массив неотрицательных чисел $a$ длины $n$. Назовем мощностью подотрезка квадрат суммы его элементов. Необходимо разбить массив $a$ на $k$ подотрезков таким образом, чтобы минимизировать сумму мощностей подотрезков разбиения. Иными словами, выделить такие $k - 1$ чисел (границы подотрезков разбиения) $i_1$, $i_2$, $\ldots$, $i_{k - 1}$, чтобы

    $$(a_1 + a_2 + \ldots + a_{i_1 - 1})^2 + (a_{i_1} + a_{i_1 + 1} + \ldots + a_{i_2 - 1})^2 + \ldots + (a_{i_{k - 1}} + \ldots + a_{n})^2$$

было минимально.
\end{problem}

В нашем случае $dp[ki][ni]$~--- минимальная стоимость разбиения первых $n$ элементов на $ki$ подотрезков, а $w(i, ni)$~--- мощность подотрезка $(i, ni]$, то есть $(a_{i + 1} + a_{i + 2} + \ldots + a_{ni})^2$. Далее везде мы будем подразумевать, что $w(i, ni)$ можно считать за $O(1)$. Для этого необходимо заранее посчитать префиксные суммы массива $a$ и выразить мощность подотрезка через квадрат разности префиксных сумм его концов.

Базовый алгоритм решает эту задачу за $O(n^2 k)$: мы перебираем количество отрезков по возрастанию, перебираем индекс $ni$, после чего перебираем все возможные индексы $i$ и выбираем среди них оптимальный ответ. Сходу совершенно не ясно, где здесь есть место для улучшения.

Нашу динамику можно представить как таблицу $k \times n$, и $ki$-й ее слой пересчитывается через $ki-1$-й. Тогда давайте заметим, что не обязательно перебирать индексы $ni$ по возрастанию, мы можем перебирать их в любом порядке, в котором нам захочется. Давайте научимся находить очередной слой нашей динамики за $O(n \log n)$, тогда на подсчет $k$ слоев нам как раз понадобится $O(n k \log n)$ времени.

Давайте заметим, что если бы мы для каждой точки $ni$ откуда-то узнали оптимальные точки $i$, через которые нужно пересчитываться, то мы бы могли просто для каждого $ni$ обновить ответ $dp[ki][ni] := dp[ki - 1][i] + w(i, ni)$. Давайте обозначим такое оптимальное $i$ как $opt[ki][ni]$ (если есть несколько индексов $i$, дающих оптимальный ответ, выберем среди них наименьший). Тогда зная $opt[ki][ni]$, мы можем за $O(1)$ найти $dp[ki][ni]$.

Но как же нам найти $opt[ki][ni]$? В этом нам поможет то самое условие, которое мы должны наложить на динамику, чтобы оптимизация разделяй-и-властвуй работала, о котором говорилось в начале статьи.

\textbf{Условие монотонности точки разреза:} Оптимизация разделяй-и-властвуй работает тогда и только тогда, когда $opt[ki][ni] \le opt[ki][ni + 1]$ для любых $ki$ и $ni$.

Иными словами, при фиксированном $ki$ точка пересчета $opt[ki][ni]$ должна не убывать по $ni$, то есть чем правее $ni$, тем правее левый конец последнего отрезка.

О том, почему это условие выполняется в нашей задаче, мы поговорим позже. Пока что мы просто примем это на веру. На самом деле чаще всего в задачах на оптимизации динамики вы не доказываете, что необходимые условия выполняются, а лишь интуитивно это понимаете или просто верите в это.

Но как же условие монотонности точки разреза поможет нам быстро найти все значения $opt[ki][ni]$? Давайте вернемся к нашему алгоритму, который вычислял значения $dp[ki][ni]$ последовательно. По умолчанию мы знаем, что $opt[ki][ni]$~--- это какое-то число из интервала $[0, ni)$. Однако если мы уже посчитали $opt[ki][ni - 1]$, то так как $opt[ki][ni - 1] \le opt[ki][ni]$, то мы можем сократить интервал поиска до $[opt[ki][ni - 1], ni)$. С первого взгляда может показаться, что это уже помогает нам находить все значения $dp[ki][ni]$ за линейное время, но это не так. Представьте, что все значения $opt[ki][ni]$ равны нулю. Это никак не противоречит условию монотонности точки разреза, однако в этом случае наша оптимизация никак нам не помогает: мы все еще для каждого индекса $i$ перебираем все индексы от $0$ до $ni$.

\begin{observation}
    Здесь важно не путать метод разделяй-и-властвуй и метод двух указателей. Метод двух указателей работает при более сильных условиях на динамику. Ему кроме монотонности точки разреза также необходимо, чтобы при движении точки пересчета вправо ответ сначала улучшался, а потом после оптимальной точки пересчета начинал ухудшаться. В таком случае можно найти все оптимальные точки пересчета за $O(n)$. Однако в нашем случае никто не гарантирует нам, что стоимости пересчета убывают до оптимальной точки разреза и возрастают после нее. Нам лишь сказали, что для меньших индексов оптимальная точка разреза не может быть правее, чем для б\'{о}льших.
\end{observation}

Что же нам делать, раз наш линейный алгоритм не сработал? Давайте попробуем найти оптимальную точку разреза для индекса $m = \left\lfloor \frac{n}{2} \right\rfloor$ ($\left\lfloor . \right\rfloor$ означает округление вниз). Тогда если мы нашли $opt[ki][m]$, то мы знаем, что для всех индексов $i$, меньших $m$, верно, что $opt[ki][i] \le opt[ki][m]$, а для всех индексов $i$, б\'{о}льших $m$, верно, что $opt[ki][i] \ge opt[ki][m]$. Тогда мы разбили облость поиска оптимальной точки разреза для левой и правой половин массива на два множества, которые пересекаются только по $opt[ki][m]$. Тогда, если как в примере выше все $opt[ki][ni]$ равны нулю, то мы выясним, что $opt[ki][m] = 0$, и для всей левой половины массива мы значем, что оптимальная точка разреза тогда точно равна $0$.

Мы нашли оптимальную точку разреза для индекса $m$, после чего на границы поиска оптимальной точки разреза для левой и правой половин массива появились ограничения. Тогда давайте рекурсивно запустим поиск для левой и правой половин. Там мы будем искать оптимальные точки разреза для индекса $\left\lfloor \frac{n}{4} \right\rfloor$ от $0$ до $\min (opt[ki][m], \left\lfloor \frac{n}{4} \right\rfloor - 1)$, и для индекса $\left\lfloor \frac{3n}{4} \right\rfloor$ от $opt[ki][m]$ до $\left\lfloor \frac{3n}{4} \right\rfloor - 1$, и так далее.

Каждый раз нам дают некоторый отрезок $[L, R)$ индексов массива, для которых надо найти оптимальные точки разреза, а также с более высоких уровней рекурсии у нас уже есть некоторые ограничения на эти точки разреза: мы точно знаем, что они не меньше $cl$ и меньше $cr$. Тогда мы выбираем индекс $M = \left\lfloor \frac{L + R}{2}  \right\rfloor$, находим для него оптимальную точку разреза на интервале $[cl, \min(M, cr))$, после чего запускаемся рекурсивно для отрезка $[L, M)$, на котором нижнее ограничение~--- это все еще $cl$, а верхнее ограничение обновляется числом $opt[ki][M] + 1$ (ведь правая граница считается невключительно), потому что все индексы в левой половине отрезка меньше $M$; а также запускаемся рекурсивно из отрезка $[M + 1, R)$, на котором верхнее ограничение остается равным $cr$, а нижнее ограничение становится равно $opt[ki][M]$, потому что все индексы правой половины отрезка больше $M$.

Для большего понимания приведем код алгоритма:

\input{dp/divide_and_conquer/codes/recursive.cpp}

В конце такой рекурсивной процедуры мы найдем значения $dp[ki][ni]$ для всех индексов массива. Остается лишь понять, почему этот сложный рекурсивный процесс разделяй-и-властвуй работает за $O(n \log n)$.

Каждый раз мы делим длину рассматриваемых отрезков в два раза, поэтому глубина рекурсии будет равна $O(\log n)$. Давайте докажем, что все вызовы с одного уровня рекурсии суммарно отработают за $O(n)$.

В одном конкретном вызове мы делаем константное количество операций, а также запускаем цикл от $cl$ до $\min(cr, M)$. Можно считать, что один рекурсивный запуск работает за $O(cr - cl)$. На верхнем уровне рекурсии $cl = 0$ и $cr = n$, так что это $O(n)$. После чего на следующем уровне рекурсии полуинтервал $[cl, cr)$ делится на два: $[cl, opt]$ и $[opt, cr)$, и так далее. На каждом уровне рекурсии изначальный полуинтервал $[0, n)$ разбивается на несколько отрезков: $[0, i_1]$, $[i_1, i_2]$, $[i_2, i_3]$, $\ldots$ $[i_j, n)$. Соседние отрезки пересекаются по одному элементу, так что на одном уровне рекурсии каждый индекс $i$ будет использован для пересчета максимум два раза, поэтому всего мы сделаем $O(n)$ операций на одном уровне рекурсии, что в итоге даст нам $O(n \log n)$ на все уровни. Таким образом, итоговая асимптотика алгоритма~--- $O(n k \log n)$, что и требовалось доказать.

\begin{observation}
    Обратите внимание на то, что мы нигде не пользовались тем, чему собственно равны $opt[ki][ni]$, нам только важно, что они не убывают. С первого взгляда может показаться, что нам нужно, чтобы $opt$ тоже делил отрезок $[cl, cr]$ примерно пополам, но как видно из доказательства, это нигде не используется.
\end{observation}

\textbf{Последующие разделы не являются необходимыми при первом знакомстве с оптимизацией разделяй-и-властвуй. Рекомендуется прочитать их тогда, когда вы уже будете иметь некоторый опыт решения задач этим методом.}

\section{Достаточное условие для монотонности точки разреза}

Как мы уже поняли, необходимым и достаточным условием для работы оптимизации разделяй-и-властвуй является условие монотонности точки разреза, то есть $opt[ki][ni] \le opt[ki][ni + 1]$ для любых $ki$ и $ni$. Однако практика показывает, что доказать это утверждение обычно сложно, если не знать, как к нему подступиться. В этом разделе мы познакомимся с достаточным условием на то, чтобы условие монотонности точки разреза выполнялось, которое чаще всего несложно проверить.

Это условие~--- неравенство четырехугольника для функции $w$.

\textbf{Неравенство четырехугольника:} Говорят, что функция $w$ удовлетворяет неравенству четырехугольника, если для любых индексов $a \le b \le c \le d$ выполнено неравенство:

$$w(a, c) + w(b, d) \le w(a, d) + w(b, c)$$

\begin{proof}
    
Почему же из этого условия следует, что $opt[ki][ni] \le opt[ki][ni + 1]$? Предположим, что это не так, то есть $opt[ki][ni] > opt[ki][ni + 1]$. Обозначим $a = opt[ki][ni + 1]$ и $b = opt[ki][ni]$. Тогда раз $b$ является самой левой оптимальной точкой разреза для $ni$, то верно, что $dp[ki][ni] = dp[ki - 1][b] + w(b, ni)$, но при этом $a$ не является оптимальной точкой разреза для $ni$, поэтому

$$dp[ki - 1][b] + w(b, ni) < dp[ki - 1][a] + w(a, ni)$$

Аналогично, $a$~--- оптимальная точка разреза для $ni + 1$, поэтому

$$dp[ki - 1][a] + w(a, ni + 1) \le dp[ki - 1][b] + w(b, ni + 1)$$

\graytext{Здесь неравенство нестрогое, потому что $a < b$, и на самом деле точка $b$ тоже может являться оптимальной точкой разреза для $ni + 1$, но ее индекс больше, поэтому мы ее не выбрали.}

Если мы сложим эти два неравенства, то получим

$$dp[ki - 1][b] + w(b, ni) + dp[ki - 1][a] + w(a, ni + 1) < dp[ki - 1][a] + w(a, ni) + dp[ki - 1][b] + w(b, ni + 1)$$

Теперь если мы сократим одинаковые слагаемые в обеих частях, то получим

$$w(b, ni) + w(a, ni + 1) < w(a, ni) + w(b, ni + 1)$$

Теперь если мы обозначим $c = ni$ и $d = ni + 1$, то мы получим противоречие с неравенством четырехугольника:

$$w(b, c) + w(a, d) < w(a, c) + w(b, d)$$

Противоречие!

\end{proof}

\begin{observation}
Обратите внимание, что это условие является достаточным, но не необходимым. То есть если оно выполняется, то оптимизацию разделяй-и-властвуй можно применять, однако из того, что оно не выполняется, не следует, что эту оптимизацию применять нельзя.
\end{observation}

\begin{observation}
    Это условие иногда еще называется \textbf{вогнутым} неравенством четырехугольника. Оно достаточно для задачи минимизации. Если же знак в неравенстве стоит в другую сторону, то это \textbf{выпуклое} неравенство четырехугольника, и оно, соответственно, является достаточным для задачи максимизации (представьте, что мы просто заменили функцию $w$ на $-w$, тогда мы перейдем к задаче минимизации с вогнутым неравенством четырехугольника).
\end{observation}

Проверять условие на $w$ намного проще, чем условия на $opt[ni][ki]$, потому что функция $w$ нам уже известна, а значения $opt[ni][ki]$ как-то сложно зависят от динамики.

Безусловно, не во всех задачах неравенство четырехугольника верно, но чаще всего оно все таки выполняется. И если оно верно, то обычно его очень легко проверить. Давайте сделаем это для нашей задачи. В нашем случае $w$~--- это сумма квадратов элементов на отрезке. Давайте обозначим за $x$ сумму элементов на $[a, b)$, за $y$ сумму элементов на $[b, c)$ и за $z$ сумму элементов на $[c, d)$. Тогда неравенство четырехугольника в нашем случае можно переписать как

$$(x + y)^2 + (y + z)^2 \le (x + y + z)^2 + y^2$$

Раскрыв скобки, мы получим

$$x^2 + 2xy + y^2 + y^2 + 2yz + z^2 \le x^2 + 2xy + y^2 + 2yz + z^2 + 2xz + y^2$$

Сокращая одинаковые слагаемые с обеих сторон, мы получим

$$0 \le 2xz$$

Что верно, потому что оба числа $x$ и $z$ неотрицательны (здесь мы как раз пользуемся тем, что элементы изначального массива были неотрицательны).

Тем самым мы доказали, что в нашей задаче выполняется монотонность точки разреза, а значит, наше решение методом разделяй-и-властвуй корректно.

Рекомендую в качестве упражнения попытаться воспользоваться этим методом и доказать корректность решения других задач методом разделяй-и-властвуй. В большинстве случаев это возможно сделать.

\subsection{Ослабленное неравенство четырехугольника}

Кроме того есть \textbf{ослабленное неравенство четырехугольника}, которое говорит, что при $a < c$ верно

$$w(a, c) + w(a + 1, c + 1) \le w(a, c + 1) + w(a + 1, c)$$

Это то же самое неравенство четырехугольника, но $b = a + 1$ и $d = c + 1$. Однако по индукции можно доказать, что из ослабленного неравенства четырехугольника следует обычное неравенство четырехугольника, поэтому на самом деле необходимо проверять только ослабленное. В некоторых задачах это может упростить доказательство. К примеру, в этой:

\begin{problem}
    На дороге расставлены $n$ домов. Необходимо построить $k$ магазинов так, чтобы суммарное расстояние от каждого дома до ближайшего магазина было минимально.
\end{problem}

\subsection{Лямбда-оптимизация и 1D1D~--- не панацея}

Если вы уже читали статью про лямбда-оптимизацию (\ref{lambda-optimization}), вы могли заметить, что если функция $w$ удовлетворяет неравенству четырехугольника, то задачу оптимального разбиения на $k$ подотрезков можно решить при помощи комбинациии лямбда-оптимизации и 1D1D-оптимизации за $\O(n \log n \log C)$, что чаще всего лучше, чем $\O(n k \log n)$ у разделяй-и-властвуй. Получается, в большинтве ситуаций разделяй-и-властвуй бесполезна? Не совсем!

Во-первых, разделяй-и-властвуй находит ответ не только для какого-то фиксированного $k$, но и для всех меньших, в то время как лямбда-оптимизация помогает нам найти ответ только для конкретного $k$. Если в задаче нужно вывести ответ для всех $ki \le k$, то разделяй-и-властвуй будет работать быстрее.

Во-вторых, разделяй-и-властвуй написать чаще всего проще. Особенно в случаях, когда надо восстанавливать ответ.

В-третьих, стоит заметить, что решение лямбда-оптимизацией работает за $\O(n \log n \log C)$ при условии, что функцию $w$ можно легко вычислять за $\O(1)$, однако это не всегда так! Иногда вычисление функции $w$~--- это сложно и может занимать хоть линейное время.

Но ведь разделяй-и-властвуй тоже пользуется тем, что функцию $w$ мы вычисляем быстро, скажете вы. На самом деле это необязательно, давайте разберемся с этим в следующем разделе.

\section{Разделяй-и-властвуй для трудновычислимых стоимостей подотрезков разбиения}

Когда мы раньше говорили про стоимость подотрезка $w(i, ni)$, мы всегда подразумевали, что эту стоимость можно легко вычислить за $\O(1)$, но это не всегда так. Что делать в противном случае? Рассмотрим пример задачи:

\begin{problem}
    Дан массив чисел длины $n$. Стоимостью подотрезка этого массива назовем количество пар элементов этого подотрезка, значения которых совпадают. Необходимо разбить массив на $k$ подотрезков, минимизировав суммарную стоимость подотрезков разбиения.
\end{problem}

В нашем случае $w$~--- это количество пар одинаковых элементов на подотрезке. Несложно доказать, что $w$ удовлетворяет неравенству четырехугольника, однако совершенно неясно, как находить $w$ для произвольного подотрезка быстро. Что же делать?

Первым делом стоит потратить $\O(n \log n)$ времени и сжать элементы массива (можно и $\O(n)$, но это непринципиально). Теперь все элементы массива не превосходят $n$, но при этом какие элементы были одинаковыми, такие и остались. Теперь можно легко вычислять $w(l, r)$ за $\O(r - l)$: пройдемся по отрезку, посчитаем массив $cnt$, в котором для каждого значения сохраним количество элементов с таким значением, после чего ответом будет сумма $\frac{cnt[c] \cdot (cnt[c] - 1)}{2}$ по всем числам $c$. Тогда итоговая асимптотика разделяй-и-властвуй будет $\O(n^2 k \log n)$ вместо $\O(n k \log n)$. Нельзя ли сделать как-то лучше?

На самом деле можно. Давайте заметим, что если у нас есть массив $cnt$ и ответ для отрезка $[a, b]$, то мы можем легко пересчитать этот массив и ответ для подотрезка $[a - 1, b]$. Пусть на позиции $a - 1$ стоит элемент $x$. Тогда $w(a - 1, b) = w(a, b) + cnt[x]$, а в массиве $cnt$ нужно лишь прибавить единицу на позиции $x$. Давайте заметим, что для фиксированной правой границы $m$ в процессе работы разделяй-и-властвуй мы перебираем левую границу из динапазона $[cl, cr]$. Тогда если мы изначально за $\O(n)$ посчитаем  $w(cr, m)$, то далее все остальные $w(i, m)$ мы сможем посчитать суммарно за $\O(cr - cl)$, что как раз таки совпадает с асимптотикой, если бы мы считали $w$ за константное время.

Посмотрим, какая в этом случае будет асимптотика: на каждом уровне динамики для каждой позиции массива мы один раз насчитываем $w(cr, m)$ за $\O(n)$, а потом все остальное будет работать как и раньше суммарно за $\O(n \log n)$. Поэтому итоговая асимптотика~--- $\O(n^2 k + n k \log n) = \O(n^2 k)$. Немного лучше, но все еще плохо. За такую же асимптотику работало бы решение динамикой без оптимизации, если бы мы воспользовались трюком с расширением отрезка. Нужно улучшать сильнее!

Давайте попробуем еще чаще переиспользовать уже посчитанные значения $w$. Давайте заметим, что аналогично переходу от отрезка $[a, b]$ к $[a - 1, b]$, мы можем перейти и к отрезку $[a + 1, b]$, а также мы аналогично можем двигать и правую границу. Тогда пускай мы сейчас ищем оптимальный ответ для позиции $m$ с отрезка $[l, r]$, пересчитываясь через все позиции из отрезка $[cl, cr]$. Мы перебрали все эти позиции, к примеру, по убыванию, поняли, что оптимальная среди них~--- это $cm$, и в данный момент у нас посчитан массив $cnt$ для отрезка $[cl, m]$. После чего нам нужно рекурсивно запуститься из левой и правой половин и искать оптимальные точки пересчета для индексов $m_l = \left\lfloor \frac{l + m - 1}{2} \right\rfloor$ и $m_r = \left\lfloor \frac{m + 1 + r}{2} \right\rfloor$ среди позиций $[cl, cm]$ и $[cm, cr]$ соответственно. Но ведь эти позиции не так далеко от текущего отрезка $[cl, m]$, для которого на данный момент посчитан массив $cnt$. Давайте будем двигать левую и правую границу текущего отрезка, пока он не станет равен $[cm, m_l]$, после чего мы сможем продолжить рекурсивно считать динамику для левой половины, затем, когда мы закончим рекурсивный вызов из левой половины, мы сможем подвинуть текущий отрезок в $[cr, m_r]$ и продолжить рекурсивное вычисление динамики из левой половины.

Таким образом, мы не начинаем считать массив $cnt$ для каждой правой границы по отдельности, а переиспользуем уже вычисленные значения. В любой момент времени если нам надо посчитать $w$ для отрезка $[a, b]$, а на данный момент у нас есть массив $cnt$ для отрезка $[c, d]$, мы просто постепенно двигаем левую и правую границу отрезка на $1$, пока не получим нужный отрезок.

\begin{observation}
    Обратите внимание, что если, к примеру, $a < b < c < d$, то если мы будем двигать сначала правую границу от $d$ до $b$, а потом левую от $c$ до $a$, то в какой-то момент у нас будет массив $cnt$ для отрезка $[c, b]$ отрицательной длины, что может привести к каким-то ошибкам. Аналогичная ситуация может произойти, если $c < d < a < b$. Чтобы избежать такой проблемы, стоит сначала применять операции, которые расширяют отрезок, а потом уже те, которые его укорачивают. То есть сначала нужно уменьшать левую границу и увеличивать правую, пока это нужно, а потом уже увеличивать левую и уменьшать правую.
\end{observation}

Давайте оценим время работы получившегося алгоритма. Кроме стандартных $\O(n k \log n)$ на разделяй-и-властвуй, мы теперь еще тратим время на передвижение левых и правых границ текущего отрезка, на котором посчитано $w$. Но при этом передвижение границы на $1$ занимает $\O(1)$ времени, так что нам достаточно лишь посчитать количество таких перемещений.

Давайте докажем, что когда мы запустились от подотрезка $[l, r]$ и ищем для этих индексов оптимальные точки пересчета среди точек на отрезке $[cl, cr]$, на текущем уровне рекурсии мы сделаем $\O((cr - cl) + (r - l))$ перемещений. Почему это так? Изначально границы отрезка стоят на $[cr, m]$, после чего мы постепенно передвигаем левую границу вплодь до $cl$, на что мы тратим $cr - cl$ перемещений. Затем нам нужно переместить границы в $[cm, m_l]$. При этом левая граница все еще остается на отрезке $[cl, cr]$, а правая все еще остается на отрезке $[l, r]$, поэтому количество перемещений не будет превышать $(cr - cl) + (r - l)$. После чего мы запустимся рекурсивно из левой половины массива, там мы будем как-то двигать границы, но это нас не касается, потому что эти перемещения учтутся на более глубоких уровнях рекурсии. После окончания рекурсивного вызова границы текущего отрезка $w$ могут быть абсолютно произвольными, однако мы точно знаем, что левая граница все еще лежит на отрезке $[cl, cr]$, а правая лежит на $[l, r]$, потому что внутри рекурсии мы пытаемся пересчитывать динамику для индексов с отрезка $[l, r]$ через отрезок $[cl, cr]$, поэтому чтобы от текущего отрезка перейти к отрезку $[cr, m_r]$, нам опять понадобится не более $(cr - cl) + (r - l)$ операций перемещения. Больше перемещений на текущем уровне рекурсии не будет, так что мы доказали, что мы сделаем $\O((cr - cl) + (r - l))$ операций перемещения.

Раньше на одном уровне рекурсии мы работали за $\O(cr - cl)$, поэтому добавление еще одного $\O(cr - cl)$ будет все еще суммироваться в $\O(n k \log n)$. Осталось лишь доказать то же самое про $\O(r - l)$. Но это можно оценить точно так же! Это ведь длины отрезков нашего разделяй-и-властвуй. На каждом уровне сумма длин этих отрезков не превышает $n$, потому что эти отрезки не пересекаются. А так как уровней рекурсии будет $\O(\log n)$, то итоговая асимптотика будет равна $\O(n k \log n)$. Точно такая же, как и для $w$, вычисляемой за $\O(1)$. С примером кода можно ознакомиться по \href{https://codeforces.com/contest/868/submission/136528300}{ссылке}.

\begin{observation}
    Как вы могли уже понять, никуда специально двигать границы запроса на самом деле не нужно. Просто когда мы хотим узнать стоимость какого-то подотрезка $[a, b]$, мы двигаем границы от той позиции, в которой они сейчас находятся, к нужному отрезку.
\end{observation}

% попытаться найти примеры задач на d&c dp opt другого типа (?)

% нерекурсивный вариант написания (?)


\section{Источники}

\begin{itemize}
    \item \href{https://codeforces.com/blog/entry/8219}{Источник информации по разным оптимизациям динамики}
\end{itemize}

\section{Задачи}

\begin{itemize}
    \item \href{https://codeforces.com/problemset/problem/673/E}{Несложное применение идеи}
    \item \href{https://codeforces.com/contest/321/problem/E}{Стандартная задача на разделяй-и-властвуй (не забудьте про быстрый ввод)}
    \item \href{https://codeforces.com/contest/1527/problem/E}{Задача изначально не на разделяй-и-властвуй, но его можно применить}
    \item \href{https://codeforces.com/contest/868/problem/F}{Задача из раздела про трудновычислимую стоимость подотрезков разбиения}
    \item \href{https://www.spoj.com/problems/LARMY/}{Еще одна задача}
    \item \href{https://oj.uz/problem/view/COI15_nafta}{Неожиданное применение идеи разделяй-и-властвуй}
    \item ОСТОРОЖНО!!! СПОЙЛЕРЫ К IOI!!! \href{https://oj.uz/problem/view/IOI14_holiday}{Сложная задача с IOI 2014}
\end{itemize}
