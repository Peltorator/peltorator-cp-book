\chapter{Нахождение обратных ко всем остаткам за $\O(p)$}\index{All inverses}

Часто бывает так, что в задаче нужно делить по модулю много раз. Это можно делать обычным алгоритмом взятия обратного по модулю за $\O(\log p)$ на запрос. Если мы сделаем $n$ запросов, то асимптотика будет $\O(n \log p)$. Сейчас мы рассмотрим алгоритм, который изначально предпосчитает обратные ко всем остаткам за $\O(p)$, и тогда на запросы мы будем отвечать за $\O(1)$. Если $n$ порядка $p$ или больше, то этот вариант будет более эффективен.

Есть много разных алгоритмов, которые делают это. Здесь будут представлены два, пожалуй, самых простых: один очень простой в понимании и написании, а другой еще легче в написании, однако не настолько очевидный с точки зрения понимания и придумывания.

\section{Метод обратных факториалов}\index{All inverses!factorials}

Идея первого алгоритма заключается в том, что мы посчитаем все возможные факториалы и обратные факториалы, а любое обратное к какому-то остатку представим как отношение двух факториалов.

\begin{theorem}
    \label{Wilson}
    Теорема Вильсона гласит, что если $p$~--- простое число, то

    $$
    (p - 1)! \equiv -1 \pmod p
    $$
\end{theorem}

\begin{proof}
    Давайте заметим, что все остатки от $1$ до $p - 1$ разбиваются на пары вида $x$, $x^{-1}$. Произведение чисел в паре равно единице по модулю $p$.
    Есть один крайний случай: когда $x = x^{-1}$. Это происходит в том случае, если $x^2 \equiv 1 \pmod p$, то есть
    $x^2 - 1 = (x - 1) \cdot (x + 1) \divby p$. Значит, $x \equiv \pm 1 \pmod p$. Тогда в итоге $(p - 1)!$ по модулю $p$ состоит из произведения нескольких единиц, а также одной $-1$. Так что $(p - 1)! \equiv -1 \pmod p$. Что и требовалось доказать.
\end{proof}

Зная этот факт, мы можем сразу понять, что $\left((p - 1)!\right)^{-1} \equiv -1 \pmod p$, потому что обратное к $-1$~--- это $-1$. Таким образом, обратное к $(p - 1)!$ мы уже посчитали.

\begin{observation}
На самом деле не обязательно было пользоваться этой формулой. Можно было посчитать за $\O(p)$ число $(p - 1)!$, а потом бинарным возведением в степень найти к нему обратное за $\O(\log p)$. Итоговая асимптотика бы от этого не пострадала.
\end{observation}

Мы уже нашли обратное к $(p - 1)!$. Как же найти обратное к $(p - 2)!$ теперь?
Заметим следующий факт:

$$
\frac{1}{k!} = \frac{k + 1}{(k + 1)!}
$$


Так что алгоритм нахождения всех обратных факториалов следующий: идем с конца, изначально устанавливаем, что обратное к $(p - 1)!$~--- это $-1$, а затем пересчитываем по очереди обратное к $k!$ как обратное к $(k + 1)!$, умноженное на $k + 1$.

Теперь пусть мы посчитали все факториалы и все обратные факториалы за $\O(p)$. Как найти обратные ко всем остаткам? С этим нам поможет следующая формула:

$$
\frac{1}{k} = \frac{(k - 1)!}{k!}
$$

А отношение двух факториалов~--- это произведение первого факториала на обратное ко второму.

Представим код алгоритма:

\input{number_theory/all_mod_inv/codes/all_mod_inv.cpp}

Весь алгоритм~--- это два прохода по числам от $1$ до $p - 1$, так что работает он за $\O(p)$.
Потребление памяти тоже $O(p)$, потому что нужно хранить массивы факториалов и обратных факториалов.
От одного из них можно избавиться, если вычислять ответ на лету (в приведенном коде мы не хранили факториалы), однако не от обоих.

\begin{exercise}
    Придумайте модернизацию этого алгоритма, которая работает за $\O(p)$, но при этом потребляет $\O(\sqrt{p})$ памяти (считайте, что ответы~--- вектор \verb+inverses+~--- вы можете просто выводить на экран, и вам не нужно их хранить).
\end{exercise}

\begin{observation}
    Заметим, что можно считать обратные факториалы, начиная не обязательно с $p - 1$. Если нам нужно найти обратные ко всем остаткам от $1$ до $n$, то можно за $\O(n)$ посчитать $n! \bmod p$, найти к нему обратное за $\O(\log p)$ и потом аналогично представленному выше способу насчитать все обратные факториалы от $1$ до $n$. Тогда подсчет обратных ко всем остаткам от $1$ до $n$ будет работать за $\O(n + \log p)$.
\end{observation}


Как вы можете видеть, алгоритм очень простой. Однако его редко получится где-то применить, потому что, во-первых, нахождение всех обратных по отдельности работает за $\O(p \log p)$, что тяжело отсечь от $\O(p)$ на неучебной задаче,
а во-вторых, модуль чаще всего~--- это число порядка $10^9$, поэтому вы не имеете возможности посчитать обратные ко всем остаткам, и использование стандартного алгоритма за $\O(n \log p)$ дает более эффективное решение.


\section{Алгоритм одного цикла}\index{All inverses!oneCycle}

Второй алгоритм пишется всего одним циклом. Однако чтобы его вспомнить, придется написать пару формул на бумажке.

Алгоритм основывается на одном простом факте:

\begin{theorem}
    $$
    \frac{1}{k} \equiv -\left\lfloor \frac{p}{k} \right\rfloor \cdot \frac{1}{p \bmod k} \pmod p
    $$
\end{theorem}

\begin{proof}
    Давайте представим $p$ в виде $k \cdot x + y$, где $x = \left\lfloor \frac{p}{k} \right\rfloor$ и $y = p \bmod k$.

    Необходимо проверить, что

    $$k \cdot \left(-\left\lfloor \frac{p}{k} \right\rfloor \cdot \frac{1}{p \bmod k} \right) \equiv 1 \pmod p$$

    $$
    k \cdot (-x \cdot \frac{1}{y}) = - (k \cdot x) \cdot \frac{1}{y} = - \left((k \cdot x + y) - y\right) \cdot \frac{1}{y} = - (p - y) \cdot \frac{1}{y} \equiv y \cdot \frac{1}{y} \equiv 1 \pmod p
    $$

    Что и требовалось доказать.
\end{proof}

Таким образом, мы можем посчитать обратное к $k$, если уже посчитано обратное к $p \bmod k$. Заметим, что это число меньше, чем $k$,
поэтому все обратные можно вычислять по порядку.

Реализация у этого алгоритма крайне проста:

\input{number_theory/all_mod_inv/codes/all_mod_inv_2.cpp}

Также преимуществом этого метода является то, что это просто один цикл \verb+for+ по возрастанию, поэтому можно считать обратные не ко всем остаткам, а к первым $n$ остаткам за $\O(n)$ очень легко. Однако не очень ясно, для чего это может вам понадобиться.


При тестировании на $p$ порядка $10^8$ второй алгоритм работает примерно в два раза быстрее, чем первый.



